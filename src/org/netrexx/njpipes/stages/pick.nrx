-- pick.nrx NJPipe Stage
/*
 *  Copyright (C) 1997-2020 Ed Tomlinson
 *
 *  Distributed under the ICU 1.8.1 Licence with NO WARRANTIES of ANY kind.
 *  See LICENSE for the licence and information on using, copying, modifying,
 *  and distributing this program.
 *
 */

/*
 20/ 5/16  NOPAD, CASELESS
 20/ 5/15  add \== and /==. Jeff Hennick
 99/05/15  use Emsg.  ejt
 99/05/09  use mrc() instead of rc().  ejt
 98/07/30  use SelIRange.  ejt
 98/07/11  initial release. EJT
*/

/** pick

           +-NOPAD----+
 >>--PICK--+----------+--+------------+--+------------+--+-==--+--+-----------------+-->
           +-PAD xorc-+  +-ANYcase-(1)+  +-inputRange-+  +-^==-+  +-inputRange------+
                         +-CASEANY----+                  +-<<--+  +-delimitedString-+
                         +-CASEIGNORE-+                  +-<<=-+
                         +-CASELESS---+                  +->>--+
                         +-IGNORECASE-+                  +->>=-+
                                                         +-\==-+(2)
                                                         +-/==-+
                                                         +-=---+
                                                         +-^=--+
                                                         +-<---+
                                                         +-<=--+
                                                         +->---+
                                                         +->=--+
                                                         +-\=--+(2)
                                                         +-/=--+


 Notes:
  (1) Can be before PAD/NOPAD. Depreciated.
  (2) The backslash (\) may need to be escaped, doubled, in some systems shells.

*/
/** pick CMS

            +-NOPAD-----+
 >>--PICK---+-----------+--+------------+---->
            +-PAD--xorc-+  +-ANYcase----+
                           +-CASEANY----+
                           +-CASEIGNORE-+
                           +-CASELESS---+
                           +-IGNORECASE-+

 >--+--+---------------------+---| List |-+--><
    |  +-+-FROM-+--+-------+-+            |
    |  | +-TO---+  +-AFTER-+ |            |
    |  +-WHILE---------------+            |
    +-| Fromto |--------------------------+

 Fromto:
 |--FROM--+-------+--| List |--+-TO-+-------+--| List |-+--|
          +-AFTER-+            |    +-AFTER-+           |
                               +-COUNT--number----------+

 List:
 |--+-------------------+--| Test |--|
    +-| List |--+-AND-+-+
                +-OR--+

 Test:
 |--| RangeString |--+--| NonEqualOp |--| RangeString |--+--|
                     +--| EqualOp |----| CommaList |-----+

 CommaList:
    +---,---------------+
 |--v--| RangeString |--+--|

 RangeString:
 |--+-inputRange-------+--|
    +-delimitedString--+
    +-number+----------+

 Character Operators:
  == ^== \== /== << <<= >> >>= IN NOTIN

 Numeric Operators
  = ^= < <= > >=

*/

options nostrictcase nostrictargs nostrictsignal
package org.netrexx.njpipes.stages

import org.netrexx.njpipes.pipes.

class pick extends stage uses IRange binary

cc = int

anycase = boolean 0

method run()

   robj = rexx
   w1   = rexx
   args = rexx
   pad  = rexx ' '
   rc = int
   i  = int
   n1 = int
   r1 = IRange[]
   n2 = int
   r2 = IRange[]
   out0flag = boolean
   out1flag = boolean

   args = arg()

   w = args.upper().wordpos('NOPAD')
   if w>0 then do
      args = args.delword(w,1)
   end

   w = args.upper().wordpos('PAD')
   if w>0 then do
      pad = GetXorc(args.word(w+1))
      args = args.delword(w,2)
   end

   parse args w1 rest
   w1 = w1.upper()

   anycase = rexx 'ANYCASE'.abbrev(w1, 3) | 'CASEANY IGNORECASE CASEIGNORE CASELESS'.wordpos(w1) > 0
   if anycase then args = rest

   r1 = GetIRanges(args)
   n1 = r1[0].Number()
   args = r1[0].Residue()

   if n1=0 then
      Emsg(11,'Error -' getName() 'Range expected but none found')

   parse args comp args
   cc = '== ^== << <<= >> >>= \\== /=='.wordpos(comp)
   if cc > 6 then cc = 2
   if cc=0 then do
     cc = '. . . . . . = ^= < <= > >= \\= /='.wordpos(comp)
     if cc > 12 then cc = 8
   end
   if cc=0 then
      Emsg(11,'Error -' getName() 'Compare operator expected found: 'comp)

   r2 = GetIRanges(args)
   n2 = r2[0].Number()
   args = r2[0].Residue()
   if n2=0 then
      y = DString(args).String

   out0flag = outStreamState()=0
   do
      out1flag = 1
      selectOutput(1)
   catch StageError
      out1flag = 0
   end

   select
      when out0flag & out1flag then
         loop forever
            aobj = peekto()
            robj = Rexx aobj
            j = 1
            x = r1[j].SelIRange(robj,pad)
            loop i=2 to n1
               x = x||r1[i].SelIRange(robj,pad)
               if r1[j].endcol()>=r1[i].startcol() then
                  Emsg(8,'Error -' getName() 'Invalid range (end before start)')
               j = i
            end
            if n2>0 then do
               j = 1
               y = r2[j].SelIRange(robj,pad)
               loop i=2 to n2
                  y = y||r2[i].SelIRange(robj,pad)
                  if r2[j].endcol()>=r2[i].startcol() then
                     Emsg(8,'Error -' getName() 'Invalid range (end before start)')
                  j = i
               end
            end
            if comp(x,y) then
               do
                  selectOutput(0)
                  output(aobj)
               end
            else
               do
                  selectOutput(1)
                  output(aobj)
               end
            readto()
        end
     when out1flag then do
         selectOutput(1)
         loop forever
            aobj = peekto()
            robj = Rexx aobj
            j = 1
            x = r1[j].SelIRange(robj,pad)
            loop i=2 to n1
               x = x||r1[i].SelIRange(robj,pad)
               if r1[j].endcol()>=r1[i].startcol() then
                  Emsg(8,'Error -' getName() 'Invalid range (end before start)')
               j = i
            end
            if n2>0 then do
               j = 1
               y = r2[j].SelIRange(robj,pad)
               loop i=2 to n2
                  y = y||r2[i].SelIRange(robj,pad)
                  if r2[j].endcol()>=r2[i].startcol() then
                     Emsg(8,'Error -' getName() 'Invalid range (end before start)')
                  j = i
               end
            end
            if \comp(x,y) then
               output(aobj)
            readto()
         end
      end
   otherwise
      selectOutput(0)
      loop forever
         aobj = peekto()
         robj = Rexx aobj
         j = 1
         x = r1[j].SelIRange(robj,pad)
         loop i=2 to n1
            x = x||r1[i].SelIRange(robj,pad)
            if r1[j].endcol()>=r1[i].startcol() then
               Emsg(8,'Error -' getName() 'Invalid range (end before start)')
            j = i
         end
         if n2>0 then do
            j = 1
            y = r2[j].SelIRange(robj,pad)
            loop i=2 to n2
               y = y||r2[i].SelIRange(robj,pad)
               if r2[j].endcol()>=r2[i].startcol() then
                  Emsg(8,'Error -' getName() 'Invalid range (end before start)')
               j = i
            end
         end
         if comp(x,y) then
            output(aobj)
         readto()
      end
   catch StageError
   end

   rc = mrc()
   exit(rc*(rc<>12))


method comp(x=rexx,y=rexx) returns boolean

   if anycase then
      select
         when cc=1 then return x.upper()==y.upper()
         when cc=2 then return x.upper()\==y.upper()
         when cc=3 then return x.upper()<<y.upper()
         when cc=4 then return x.upper()<<=y.upper()
         when cc=5 then return x.upper()>>y.upper()
         when cc=6 then return x.upper()>>=y.upper()
         when cc=7 then return x.upper()=y.upper()
         when cc=8 then return x.upper()\=y.upper()
         when cc=9 then return x.upper()<y.upper()
         when cc=10 then return x.upper()<=y.upper()
         when cc=11 then return x.upper()>y.upper()
         when cc=12 then return x.upper()>=y.upper()
         otherwise
            return 0
      end
   else
      select
         when cc=1 then return x==y
         when cc=2 then return x\==y
         when cc=3 then return x<<y
         when cc=4 then return x<<=y
         when cc=5 then return x>>y
         when cc=6 then return x>>=y
         when cc=7 then return x=y
         when cc=8 then return x\=y
         when cc=9 then return x<y
         when cc=10 then return x<=y
         when cc=11 then return x>y
         when cc=12 then return x>=y
         otherwise
            return 0
      end
