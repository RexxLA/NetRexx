-- take.nrx NJPipe Stage
/*
 *  Copyright (C) 1998  Jeffrey Hennick, JHennick@Delphi.Com
 *  Distributed under the ICU 1.8.1 Licence with NO WARRANTIES of ANY kind.
 *  See LICENSE for the licence and information on using, copying, modifying,
 *  and distributing this program.
 */

/*
 19/09/05 Bug fix for FIRST NUMBER; add secondary output streams
 19/09/03 Major fixes in LAST and BYTES. Needs SECONDARY for BYTES. JH
 98/09/20 support secondary output streams.  ejt
 98/06/12 Up to CMS Documentation. JHennick
*/

/** take


             +-FIRST-+  +-1------+
   >>--TAKE--+-------+--+--------+--+-------+-----------------------------><
             +-LAST--+  +-number-+  +-BYTES-+
                        +-*------+

*/
options nostrictcase nostrictargs nostrictsignal nobinary
package org.netrexx.njpipes.stages

import org.netrexx.njpipes.pipes.RingBuf
import org.netrexx.njpipes.pipes.

class take extends stage

method run()
  first = boolean 1
  n = rexx 1
  rc = rexx 0
  
  args = rexx arg().upper()
  
  parse args type numb .
  
  bytes = boolean (args.pos('BYTES') > 0)
  last = boolean (args.pos('LAST') > 0)
  if last then do
    first = 0
    parse args . type .
  end
  
  select
    when type = 'FIRST' then do
      n = numb
    end
    when type = 'LAST' then do
      first = 0
      n = numb
    end
    when type = '*' then n = 9.copies(digits)
    when type.datatype('W') then n = type
    otherwise
      args = args '.'
  end
  
  if n = '*' then n = 9.copies(digits)
  if \n.datatype('W') then n = 1
  
  select
    when n < 0 then do
      exit(-58)
    end
    when first & bytes then                                     -- FIRST BYTES
      do
        res = ''
        loop i = rexx 0 to n - 1
          line = rexx peekto()
          i = i + line.length()
          if i > n then do
            break = i - n + 1
            parse line line =(break) res
          end
          output(line)
          i = i - 1
          readto()
        catch StageError
          rc = rc()
        end
        do
          selectoutput(1)
          if res \= '' then output(res)
          shortStreams()
        catch StageError
          rc = rc()
        end
      end
    when first then                                             -- FIRST records
      do
        loop for n
          aobj = peekto()
          output(aobj)
          readto()
        catch StageError
          rc = rc()
        end
        do
          selectoutput(1)
          shortStreams()
        catch StageError
          if rc()=4 then
            rc(12)
        end
      end
    when bytes then                                            -- LAST BYTES
      do
        buf = Vector()
        do
          loop forever
            buf.addElement(readto())
          end
        catch StageError
          rc = rc()
          if rc<>12 then
            signal StageError
        end
	
        size = buf.size() - 1
        line = Rexx ''
        loop i = size by -1 to 0
          rec = Rexx buf.get(i)
          line = line || rec
          if line.length() >= n then leave
        end
        n = n.min(line.length)
        i = i.max(0)
        if line.length = n then do
          do
            selectoutput(0)
            loop i = i to size
              output(buf.get(i))
            end
          catch StageError
            rc = rc()
          end
        do
          selectoutput(1)
          loop i = 0 to i - 1
            output(buf.get(i))
          end
        catch StageError
          rc = rc()
        end
        end
  else do
    do
      rec = Rexx buf.get(i)
      break = line.length - n + 1
      parse rec res =(break) rec
      selectoutput(0)
      output(rec)
      loop i = i + 1 to size
        output(buf.get(i))
      end
    catch StageError
      rc = rc()
    end
  do
    selectoutput(1)
    loop i = 0 to i - 1
      output(buf.get(i))
    end
    output(res)
  catch StageError
    rc = rc()
  end
  end
      end
    otherwise                                                 -- LAST records
      do
        buf = Vector()
        do
          loop forever
            buf.addElement(readto())
          end
        catch StageError
          rc = rc()
          if rc<>12 then
            signal StageError
        end
	
        size = buf.size()
        n = n.min(size)
        cut = size - n
        do
          selectOutput(0)
          loop i = cut to size - 1
            aobj = rexx buf.get(i)
            output(aobj)
          end
        catch StageError
          rc = mrc()
        end
        selectOutput(1)
        loop i = 0 to cut - 1
          aobj = buf.get(i)
          output(aobj)
        end
      catch StageError
        rc = mrc()
      end
  catch StageError
    rc = mrc()
  end
  exit(rc*(rc<>12))
  