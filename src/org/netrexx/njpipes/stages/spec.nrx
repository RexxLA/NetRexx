-- spec
/*
 *  Copyright (C) 1997-2011 Ed Tomlinson, 2020-2023 RexxLA
 *
 *  Distributed under the ICU 1.8.1 Licence with NO WARRANTIES of ANY kind.
 *  See LICENSE for the licence and information on using, copying, modifying,
 *  and distributing this program.
 *
 */

/*

 23/ 1/ 4 Make getSep caseless. Jeff Hennick
 23/ 1/ 2 Add "." for input range = 0.0. Jeff Hennick
 22/12/30 Add "," as optional group separator. Jeff Hennick
 22/12/29 Fix "." for output position = ignore.  Jeff Hennick
 22/12/28 Add fields and fieldids. Jeff Hennick
 22/12/27 "." for output position = ignore.  Jeff Hennick
 22/12/26 Auto RETURN DATA for NetRexx. Jeff Hennick
 22/12/23 Outstream. Fix WRITE with WRITEFINAL. Ignore COUNTERS option. Jeff Hennick
 22/12/22 Removed restriction on RECNO/NUMBER being limited to one per stage.  Jeff Hennick
 22/12/22 Add NETREXX & NR converters to run user functions.  Jeff Hennick
 22/12/15 Fix X2C. READ works, READSTOP does not. Jeff Hennick
 22/12/01 Major update in handling of multiple input streams. Jeff Hennick
 22/11/ 3 Adding Fields and Separators. Jeff Hennick
 22/ 7/ 4 Clarify RECNO positioning vs. CMS. Jeff Hennick
 20/ 7/18 Fix for partial extra output with multiple input streams. Jeff Hennick
 20/03/28 Added FIRST and SECOND; CENTRE Jeff Hennick
 20/03/26 various range specifiers; major fix for backward ABBREVs Jeff Hennick
 20/03/17 B2c, D2c, TODclock added. Jeff Hennick
 20/02/20 Hexidecimal & Binary handling. Jeff Hennick
 20/02/19 NUMBER, Alignment abbreviations; space optional on words & fields; additional tests on option names. Jeff Hennick
 20/02/18 rename to spec for abbreviated name Jeff Hennick
 20/02/18 Can be used as a Driver stage, first in pipe. C2D, C2X, X2C, RECNO added. Jeff Hennick
 20/02/17 X,H, & Bstrings; Fix PAD; Documentation. Jeff Hennick
 20/02/14 Added NW for Nextword; pad: hexchar, BLANK, SPACE. Jeff Hennick
 99/05/06 fixed error with -n;-1 where n is longer than the string.  ejt
 99/01/12 fixed error with -1;-1  ejt
 99/01/03 changed error message.  ejt
 98/07/30 use StageError(13,... in stageExit.  ejt
 98/07/17 fix pad operations, output next.n was inserting a space.  EJT
*/

/** specs
            +-STOP--ALLEOF----+ (3)
 >>--SPECs--+-----------------+-------+-----------------+-------->
            +-STOP-+-ANYEOF-+-+ (3)   +-COUNTERS-number-+ (12)
                   +-n------+   (3)


       v------------------------------------------------------------+
   >---+--+-| Group |--------------------------+--+--------------+--+--><
          +-READ-------------------------------+  +-(1),-(4)(13)-+
          +-READSTOP---------------------------+ (3)
          +-WRITE------------------------------+
          +-SELECT-+-streamnum-+---------------+
          |        +-streamid--+               |
          +-OUTSTREAM--streamnum---------------+
          +-PAD--+-char----+-------------------+
          |      +-hexchar-+                   |
          |      +-BLANK---+                   |
          |      +-SPACE---+                   |
          +-+-WORDSEParator---+--+--char-----+-+  (7)
            +-WS--------------+  +-hexchar---+
            +-FIELDSEparator--+  +-BLANK-----+
            +-FS--------------+  +-TAB-------+
                                 +-hexstring-+
                                 +-qword-----+    (4)(6)
Group:
 |--| Id |--| Input |--| Conversion |--| Output |--| Alignment |--|

Id:
 |-letter--(14)--:-(2)--|

Input:
 |--+-Words-(1)-wnumberrange----------------------+-------|
    +-Fields-(1)-fnumberrange---------------------+
    +-cnumberrange--------------------------------+
    +-/string/------------------------------------+
    +-Xhexstring----------------------------------+
    +-Hhexstring----------------------------------+
    +-Bbinstring----------------------------------+
    |            +-FROM--1-------+ +-BY--1-----+  |
    +-+-RECNO--+-+---------------+-+-----------+--+  (8)
    | +-NUMBER-+ +-FROM--fromnum-+ +-BY--bynum-+  |
    +-TODclock------------------------------------+  (3)
    +-.-------------------------------------------+  (4)(15)

Conversion:
 |-+-------+--+------------------------------+------|
   +-STRIP-+  +-B2C--------------------------+
              +-B2X--------------------------+ (4)
              +-C2B--------------------------+
              +-C2D--------------------------+
              +-C2F--------------------------+ (3)
              +-C2I--------------------------+ (3)
              +-C2P-+------------+-----------+ (3)
              |     +-(2)(scale)-+           | (3)
              +-C2V--------------------------+ (3)
              +-C2X--------------------------+
              +-D2C--------------------------+
              +-D2X--------------------------+ (4)
              +-F2C--------------------------+ (3)
              +-I2C--------------------------+ (3)
              +-P2C-+------------+-----------+ (3)
              |     +-(2)(scale)-+           | (3)
              +-V2C--------------------------+ (3)
              +-X2B--------------------------+ (4)
              +-X2C--------------------------+
              +-X2D--------------------------+ (4)
              +-F2T--------------------------+ (3)
              +-LOWER------------------------+ (4)
              +-UPPER------------------------+ (4)
              +-STRING-----------------------+ (4)(11)
              +-+-NETREXX-+-delimited_string-+ (4)(10)
                +-NR------+                    (4)
Output:
 |--+-Next-+-------+-------+--|
    |      +-(2).n-+       |
    +-NEXTWord-+-+-------+-+
    +-NWord----+ +-(2).n-+ |
    +-columnrange----------+
    +-.--------------------+

Alignment:
    +-Left---+
 |--+--------+--|
    +-Center-+
    +-Right--+

Notes:
 (1) Blanks are optional in this position.
 (2) Blanks are not allowed here.
 (3) CMS only. Not yet implemented in njpipes
 (4) NetRexx only. Not yet implemented in CMS
 (5) NetRexx only: READ is giving the same output as READSTOP when
     the streams are different length.
 (6) A Qword is an optionally quoted word, with single or double marks.
     If it contains spaces or begins with a quote mark, it must be quoted.
     It can not begin with a space (the quote mark will be considered
     a single character, and rest jibberish).
     If is unquoted and an even number of hexadecimal characters,
     it will be used as a hexchar or hexstring.
 (7) NetRexx Pipelines ONLY: a single quote character is NOT allowed,
     use "'" or '"' as appropriate.
 (8) CMS Pipelines, without documenting it, places this right by defualt
     NetRexx Pipelines follows the documentation and places this left by defualt.
     Specify the alignment you want to override these defaults.
 (9) CMS has a mini-programming language built in. It uses Control Breaks and
     Structured Data.
     NetRexx does not yet have these, but see the NETREXX converter (10).
(10) The delimited string is any valid NetRexx code. [Yes, you can get in trouble!]
     It is put into a method and executed for each record.  The selected input data
     is in the variable DATA. The returned string is output.  The persistent
     variable array COUNTER[] is available for your use. Each COUNTER is
     initially 0, but can hold any NetRexx value, including strings. COUNTERs
     are shared across all NETREXX converters in a stage. Index can be number or string.
     Fields identified by a fieldid are accessed as field["id"] when the quotes are
     required, the id is a single letter, case is respected
(11) The data is processed by the toString() method.
(12) CMS Only. NetRexx ignores COUNTERS n; it has an unlimited number. See the NETREXX converter.
(13) NetRexx Only. A comma may be used to separate groups for readability.
(14) Letter is a single character, a-zA-Z.  Case is respected. BLANK is not permited between
     letter and : .  The resulting data is available in the NETREXX code as field["letter"].
(15) NetRexx Pipelines ONLY: A "." for input is "0.0", no data is selected. Variable data is "".

Examples:
CMS Pipelines has built into the SPEC stage its own programming language.
It is Rexx-like-but-not-quite-Rexx.  For NetRexx Pipelines we have built in the worlds best scripting language: NetRexx.
This gives all the power, but with a somewhat different syntax, of the CMS version.
It is incorporated into the "Conversion" phase, with the key word NETREXX (or NR)
and a delimitedString containing the NetRexx source.  In running, this code is encapsulated in a method.
The data selected in the Input phase is available as the variable data.
And whatever is returned is passed to the Output phase of the stage.
(As a convenience, if the last statement is not RETURN, the statement "return data" is automatically added.)
So all of these pipes work the same (giving cba):

    pipe "literal abc | spec 1-* NR /return data.reverse/ 1 | cons"
    pipe "literal abc | spec 1-* NR @rev = data.reverse; return rev@ 1 | cons"
    pipe "literal abc | spec 1-* NR %data = data.reverse% 1 | cons"
    pipe "spec /abc/ NR /data = data.reverse/ 1 | cons"

Using COUNTERS:
    pipe "literal abc | spec 1-* NR /counter[7]=counter[7]+1;ret=data.reverse counter[7];return ret/ 1 | cons"
gives cba 1

Using Field Ids (and "." for output position).  In this case the variable data is not used at all.:
    pipe "literal abc | spec T:1-* . 1 NR @rev = field['T'].reverse; return rev@ 1 | cons"
    pipe "literal abc | spec T:1-* . t:1 NR @rev = field['T'].reverse; return rev@ 1 | cons"
"T:" and "t:" are different.

Using comma to separate groups:
    pipe "literal abc | spec T:1-* 10-16, 1.2 NR @rev = field['T'].reverse; return rev@ 1 | cons"

**/

options nostrictcase nostrictargs nostrictsignal nobinary
package org.netrexx.njpipes.stages

import org.netrexx.njpipes.pipes.

class spec extends stage

  ufn = 0 -- number of user methods
  uf = Rexx '' -- lines of user functions
  uln = 0 -- linenumber in user functions

  rno = 0 -- number of RECNOs

  -- The run method of specs should never get called

  method run()
    rc = 16
    exit(rc)


  method stageExit(pInfo=Rexx,code=Rexx) returns boolean signals StageError

    /*
     * pInfo    = name of pipe,
     * pInfo[1] = stage number in pipe
     * pInfo[2] = stage label, null if no label
     * pInfo[3] = stage name
     * pInfo[4] = stage arguments
     * pInfo[5] = rest of pipe
     * pInfo[6] = sep
     * pInfo[7] = end
     * pInfo[8] = not modifier active
     * pInfo[9] = stage is a driver
     * code     = ''
     * code[0]  = 0
     *
     * When compilerExit returns with true, the compiler expects:
     *
     * pInfo[2] = stage label
     * pInfo[3] = name of stage
     * pInfo[4] = stage arguments
     * pInfo[5] = rest of the pipe
     * code[0]  = number of lines generated
     * code[n]  = line n of lines generated
     *
     */

    pid  = pInfo
    name = pInfo[3]
    b    = pInfo[4]

    if pInfo[8] then
      signal StageError(13,'Error (specs) - 'pInfo' - not valid at 'pInfo[3]' 'pInfo[4])

    n   = Rexx 0
    p   = Rexx 0        -- true if a peek has been done
    s   = Rexx '0'      -- the currently selected input stream, "S" for Second Read Station
    outstream = Rexx 0  -- the currently selected outout stream
    pr  = Rexx 0        -- peakto required flag
    pad = Rexx ' '      -- default pad char
    recnoline = Rexx 0

    x = Rexx
    y = Rexx
    fid = Rexx ""; fid = fid

    cname = stageName(name,pid,pInfo[1])
    n=n+1;code[n] ='class 'cname' extends stage private'
    n=n+1;code[n] ='-- trace results'
    n=n+1;code[n] ='-- trace methods'
    n=n+1;code[n] ='-- trace var data outp'
    n=n+1;code[n] ='  safespace = Rexx ""'
    n=n+1;code[n] ='  safesep = Rexx ""'
    n=n+1;code[n] ='  records = Rexx ""' -- Array of inputs indexed by stream, -1 is the previous 0.
    n=n+1;code[n] ='  record  = Rexx ""' -- The currently selected records[].
    n=n+1;code[n] ='  counter = Rexx 0' -- available for use in user functions
    n=n+1;code[n] ='  field = Rexx ""' -- contents of named fields
    n=n+1;code[n] ='  field2 = Rexx ""' -- contents of named fields in second read station
    n=n+1;code[n]='method run()'
    n=n+1;code[n]="  recno = Rexx 0; recno = recno" -- Array of RECNO variables
    n=n+1;code[n]="  recno_byn = Rexx 1; recno_byn = recno_byn" -- Array of RECNO BY variables
    n=n+1;code[n]='' -- reserved for RECNO initialization
    recnoline = n
--    n=n+1;code[n]="-- reserved for 'tod'"
    n=n+1;code[n]='   data = Rexx ""'
    n=n+1;code[n]='   fid = Rexx ""; fid = fid' -- fieldid letter for current field
    n=n+1;code[n]='   curoutstream = Rexx 0'  -- the current recently selected outout stream
    n=n+1;code[n]='   lastoutstream = Rexx 0'  -- the most recently selected outout stream

    cnts    = Rexx 1    -- count of how many streams we are going to use
    flgs    = Rexx 1
    flgs[0] = 0

    parse b 'select' sn work
    sn = sn.strip('T',',')
    loop while sn.datatype('W')
      if flgs[sn] then do
        cnts = cnts+1
        flgs[sn] = 0
      end
      parse work 'select' sn work
      sn = sn.strip('T',',')
    end
    all = cnts          -- default to 'stop alleof' to end on all streams at eof

    n=n+1;code[n] = '   reqcon =' cnts -- set the required connections to all, the number we stated with
    n=n+1;code[n] = '   outp = Rexx ""'
    n=n+1;code[n] = '   eoff = Rexx 1; eoff = eoff'
    n=n+1;code[n] = '   eofc = Rexx 0; eofc = eofc'
    if pInfo[9] then do  -- driver stage
      n=n+1;code[n] = ''
      n=n+1;code[n] = ''
    end
    n=n+1;code[n] = '   read = boolean 1'
    n=n+1;code[n] = '   inselect = 0; inselect = inselect'
    n=n+1;code[n] = '   loop label body loopcount = 1 while read'
    n=n+1;code[n] = '      read = 0'

    if b.word(1)<>'select' then     -- start with standard input
      b = 'select 0' b
    if b.word(b.words())<>'write' then     -- and end with a write
      b = b' writefinal'

    ob = b
    parse b t b

    firstpass = 1

    wsep = ' '    -- Blank                          -- WordSeparator
    fsep = '\t'   -- Tab                            -- FieldSeperator

    loop label body while t<>''

      -- process options

      loop label options forever
        if t <> ',' then
          t = t.strip('T',',')
        if t = "." then
          t = "0.0"

        select
          when t = ',' then do
            parse b t b
            iterate
          end
          when t='stop' then do
            parse b t b
            select
              when t='alleof' then
                all = cnts
              when t='anyeof' then
                all = 1
              when t.datatype('W') then do
                if t>cnts then
                  signal StageError(13,'Error (specs) - 'pInfo' - there are only 'cnts' streams used')
              all = t
              end
              otherwise
                signal StageError(13,'Error (specs) - 'pInfo' - stop option 't' not supported')
            end
          end

          when t='pad' then do
            parse b t b
            if t.substr(2) = ',' then
               t = t.substr(1,1)
            else
               t = t.strip('T',',')
            select
               when t.length = 1 then nop
               when t.length = 2 & t.datatype('X') then t = t.x2c
               when t = 'blank', t = 'space' then t = ' '
               otherwise
                 signal StageError(13,'Error (specs) - 'pInfo' - pad must be a single char, hexchar, BLANK or SPACE not 't)
            end
            pad = t
            parse b t b 1 ob
            iterate options
          end

          when t='read' then do
            n=n+1;code[n] = '         selectInput('s')'
            n=n+1;code[n] = '         readto()'
            n=n+1;code[n] = '      do'
            n=n+1;code[n] = '         record = Rexx peekto()'
            n=n+1;code[n] = '      catch StageError'
            n=n+1;code[n] = '         record = ""'
            n=n+1;code[n] = '      end'
          end

          when t='readstop' then do
            signal StageError(13,'Error (specs) - 'pInfo' - READSTOP is not yet supported')
          end

          when t='write' then do                 -- write if its required
            n=n+1;code[n] = '      if eofc = 0 then do -- 325'
            n=n+1;code[n] = '        if curoutstream <> lastoutstream then do'
            n=n+1;code[n] = '          selectOutput(curoutstream)'
            n=n+1;code[n] = '          lastoutstream = curoutstream'
            n=n+1;code[n] = '        end'
            n=n+1;code[n] = '        output(outp)'
            n=n+1;code[n] = '        outp = ""'
            n=n+1;code[n] = '      catch StageError'
            n=n+1;code[n] = '        rc = rc()'
            n=n+1;code[n] = '      end'
          end

          when t='writefinal' then do                 -- write if its required
            n=n+1;code[n] = '      if eofc = 0 then do'
            n=n+1;code[n] = '        if curoutstream <> lastoutstream then do'
            n=n+1;code[n] = '          selectOutput(curoutstream)'
            n=n+1;code[n] = '          lastoutstream = curoutstream'
            n=n+1;code[n] = '        end'
            n=n+1;code[n] = '        output(outp)'
            n=n+1;code[n] = '        outp = ""'
            n=n+1;code[n] = '      catch StageError'
            n=n+1;code[n] = '        rc = rc()'
            n=n+1;code[n] = '      end'


            n=n+1;code[n] = '      loop stream = 0 for' cnts
            n=n+1;code[n] = '        selectInput(stream)'
            n=n+1;code[n] = '        readto()'
            n=n+1;code[n] = '      catch StageError'
            n=n+1;code[n] = '        rc = rc()'
            n=n+1;code[n] = '      end stream'

            loop i over p                          -- issue readto for peeked streams
              if p[i] then do
                n=n+1;code[n] = '      do'
                if s<>i  then do
                  n=n+1;code[n] = '         selectInput('i')'
                  s = i
                end
                n=n+1;code[n] = '         readto()'
                n=n+1;code[n] = '      catch StageError'
                n=n+1;code[n] = '         rc = rc()'
                n=n+1;code[n] = '      end'
                p[i] = 0
              end
              p["S"] = 0
            end
          end

          when t = 'counters' then do  -- ignore it if well formed
            parse b counterval t b
            if \counterval.strip('T',',').datatype('W') then do
              signal StageError(13,'Error (specs) - COUNTERS:' counterval 'must be a whole number.')
            end
            iterate
          end

          otherwise
             /* **** New 6/22 **** */
           havesep = 0

           nn = getSep(t b, 'WORDSEParator', 7)
           if nn[0] = 3 then do
             wsep = nn[1]
             b = nn[2]
             havesep = 1
           end

           nn = getSep(t b, 'WS', 2)
           if nn[0] = 3 then do
             wsep = nn[1]
             b = nn[2]
             havesep = 1
           end

           nn = getSep(t b, 'FIELDSEparator', 7)
           if nn[0] = 3 then do
             fsep = nn[1]
             b = nn[2]
             havesep = 1
           end

           nn = getSep(t b, 'FS', 2)
           if nn[0] = 3 then do
             fsep = nn[1]
             b = nn[2]
             havesep = 1
           end
             /* **** End new ***** */
           if \havesep then
             leave options
        end -- select


        if t='writefinal' then           -- force specs to finish
          leave body

        ob = b
        parse b t b

      end options

      -- wait for a record and peekto it for processing

    if firstpass then do
      firstpass = 0
      n=n+1;code[n] = '      records[-1] = records[0]'
      n=n+1;code[n] = '      loop var over field2'
      n=n+1;code[n] = '        field2[var] = null'
      n=n+1;code[n] = '      end'
      n=n+1;code[n] = '      loop var over field'
      n=n+1;code[n] = '        field2[var] = field[var]'
      n=n+1;code[n] = '        field[var] = null'
      n=n+1;code[n] = '      end'
      n=n+1;code[n] = '      connections = 0'
                           -- get data from all streams, if disconnected, leave as is
                           -- when all streams are disconnected exit
      n=n+1;code[n] = '      rc = 0'
      n=n+1;code[n] = '      if' cnts '> 1 then loop stream = 0 for' cnts
      n=n+1;code[n] = '        selectInput(stream)'
      n=n+1;code[n] = '        records[stream] = Rexx peekto()'
      n=n+1;code[n] = '        connections = connections + 1'
      n=n+1;code[n] = '        read = 1'
      n=n+1;code[n] = '      catch StageError'
      n=n+1;code[n] = '        rc = rc()'
      n=n+1;code[n] = '        records[stream] = ""'
      n=n+1;code[n] = '      end stream'
      n=n+1;code[n] = '      else do'
      n=n+1;code[n] = '        connections =' cnts
      n=n+1;code[n] = '        records[0] = Rexx peekto()'
      n=n+1;code[n] = '        read = 1'
      n=n+1;code[n] = '      catch StageError'
      n=n+1;code[n] = '        rc = rc()'
      n=n+1;code[n] = '        records[stream] = ""'
      n=n+1;code[n] = '      end'
      n=n+1;code[n] = '      if rc <> 0 & connections <= reqcon & loopcount > 1 then do'
      n=n+1;code[n] = '        if outp<>"" then do'
      n=n+1;code[n] = '          output(outp)'
      n=n+1;code[n] = '          outp = ""'
      n=n+1;code[n] = '        end'
      n=n+1;code[n] = '        leave body'
      n=n+1;code[n] = '      end'
    end

      -- process an input range
      type = ''
      t = t.strip('T',',')

            /* is there a Field Identifier? */
      parse t . 2 sc 3 .
      if sc = ":" then do
        parse t fid 2 . 3 rest
        if rest = '' then
          parse b t b
        else
          t = rest
      n=n+1;code[n] = '      fid = "'fid'"; fid=fid'
        iterate
      end

      fc = t.left(1).lower
      select case fc
        when 'w' then do       -- handle word [space] range
          fn = t.verify('-1234567890','M')
          if fn > 0 then do
            parse t t =(fn) num
            b = num b
          end
          if \'words'.lower.abbrev(t) then signal StageError(13,'Error (specs) - Unrecognized option:' t 'In:' t b)
          type = 'w'
          parse b t b
          t = 'word't
        end

        when 'f' then do       -- handle field [space] range
          fn = t.verify('-1234567890','M')
          if fn > 0 then do
            parse t t =(fn) num
            b = num b
          end
          if \'fields'.lower.abbrev(t) then signal StageError(13,'Error (specs) - 't b' - Unrecognized option:' t)
          type = 'f'
          parse b t b
          t = 'field't
        end

        when 'x', 'h' then do       -- handle hexadecimal range

          type = 'a'
          parse t 2 ds
          ds = ds.strip('T',',')
          if \ds.datatype('X') then signal StageError(13,'Error (specs) - 't b' - Invalid hex number ')
          ds = xl2c(ds)
          parse b t b
        end

        when 'b' then do       -- handle binary range
          type = 'a'
          parse t 2 ds
          ds = ds.strip('T',',')
          if \ds.datatype('B') then signal StageError(13,'Error (specs) - 't b' - Invalid binary number ')
          ds = xl2c(ds.b2x)
          parse b t b
        end

        when 'r', 'n' then do       -- handle recno
          if " recno number".pos(t.lower) = 0 then signal StageError(13,'Error (specs) - 't b' - Unrecognized option:' t)
          type = 'r'
          parse b fkey skey r
          fkey = fkey.strip('T',',')
          skey = skey.strip('T',',')
          fromn = Rexx 1 -- default
          if fkey = 'from' then do
            if \skey.datatype('W') then signal StageError(13,'Error (specs) - "from number" is not numeric 'b)
            fromn = skey
          end
          else r = b
          byn = Rexx 1 -- default
          if r.word(1) = 'by' then do
            parse r . skey r
            skey = skey.strip('T',',')
            if \skey.datatype('W') then signal StageError(13,'Error (specs) - "by number" is not numeric 'b)
            byn = skey
          end
          b = r
        end

        when 's' then do       -- handle select
          if t <> 'select' then
            signal StageError(13,'Error (specs) - 't b' - option is not SELECT')
          parse b t b 1 ob
          t = t.strip('T',',')
          select
            when t = 'first' then t = 0
            when t = 'second' then t = -1
            when \t.datatype('W') then
              signal StageError(13,'Error (specs) - 'pInfo' - select number must be numeric. found 't)
            when t < -1 | t > all then
              signal StageError(13,'Error (specs) - 'pInfo' - select number out of range of connected streams. found 't)
            otherwise
              nop
          end

          n=n+1;code[n] = '      record = records['t']'
          parse b t b 1 ob
          x = ''
          y = ''

          iterate
        end

        when 'o' then do  -- handle outstream number
          parse b outstream t b 1 ob
          outstream = outstream.strip('T',',')
          n=n+1;code[n] = '      curoutstream =' outstream
          iterate
        end

        when 't' then do       -- handle timeofday
          signal StageError(13,'Error (specs) - 't b' - TODclock option is not yet implemented')
        end

        otherwise
           if fc.datatype('W') | fc = "-" then do
              type = 'n'
           end
           else do
              type = 's'
           end
      end

      rf = 0                    -- make sure we have a range
      select
        when type = 'w' then
          x = t.substr(5).strip('L')
        when type = 'f' then
          x = t.substr(6).strip('L')
        when type = 'l' then
          nop
        otherwise
          x = t.strip('L')
      end
      select
        when 'next'.abbrev(t) then
          rf = 1
        when ('nextword'.abbrev(t,5) | 'nword'.abbrev(t,2)) then
          rf = 1
        when type = 's' then do
          dsobj = DString(t b)
          ds = dsobj.string
          if ds \== '' then do  -- we have a dstring
            b = dsobj.residue
            t = ''
            rf = 1
            x = 0
            y = 0
          end
        end
        when x.pos(';')>1 then do
          parse x x ';' y
        end
        when x.pos('.')>1 then do
          parse x x '.' y
        end
        when x.pos('-', 2)>1 then do
          if x.left(1) = '-' then do
            parse x '-' x '-' y
            x = '-'x
          end
          else
            parse x x '-' y
        end
        when type <> 'a' then do
          y = 1
          t = t'.1'
        end
        otherwise
          y = '\n'
      end
      if x='*' then
        x = 1

      rf = rf | x.datatype('W')&(y.datatype('W')|y='*'|y='\n')

        /* *** New 6/22 **** */
      if type = 'w' & wsep \== ' ' then do
        n=n+1;code[n] = '      record = codew(record, 'wsep')'
      end

      if type = 'f' & fsep \== ' ' then do
        if fsep = " " then fsep = '"fsep"'
        n=n+1;code[n] = '      record = codew("E"record,' fsep', 1)'
      end

      mtype = type = 'w' | type = 'f'
        /* **** End new ***** */

      select
        when rf & mtype & t.pos('.')>0 then do
          if \x.datatype('W') | \y.datatype('W') then
            signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric. Found:  't)
          if x < 0 then do
            n=n+1;code[n] = '      x = record.words() +1' x
          end
          else do
            n=n+1;code[n] = '      x = ' x
          end
          if y < 0 then do
            n=n+1;code[n] = '      y = record.words()' y
          end
          else do
            n=n+1;code[n] = '      y = ' y
          end
          n=n+1;code[n] = '      data = record.subword(x,y)'
        end
        when rf & mtype & t.right(2)='-*' then do
          if \x.datatype('W') then
            signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric. Found:  't)
          if x<0 then
            signal StageError(13,'Error (specs) - 'pInfo' - Invalid range 't)
          n=n+1;code[n] = '      data = record.subword('x')'
        end
        when rf & mtype & t.pos(';')>0 then do
          if \x.datatype('W') | \y.datatype('W') then
            signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric. Found:  't)
          if x < 0 then do
            n=n+1;code[n] = '      x = record.words() +1' x
          end
          else do
            n=n+1;code[n] = '      x = ' x
          end
          if y < 0 then do
            n=n+1;code[n] = '      y = record.words()' y' + 2 - x'
          end
          else do
            n=n+1;code[n] = '      y = ' y' + 1 - x'
          end
          n=n+1;code[n] = '      data = record.subword(x,y)'
        end
        when rf & mtype & t.pos('-', 2)>0 & y \= '\n' then do
          if x < 0 then do
            n=n+1;code[n] = '      x = record.words() +1' x
          end
          else do
            n=n+1;code[n] = '      x = ' x
          end
          if y < 0 then do
            n=n+1;code[n] = '      y = record.words() 'y' + 2 - x'
          end
          else do
            n=n+1;code[n] = '      y = ' y' +1 - x'
          end
          n=n+1;code[n] = '      data = record.subword(x,y)'
        end
        when rf & mtype then do
          if \x.datatype('W') then
            signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric. Found:  't)
          if x < 1 then do
            n=n+1;code[n] = '      wp = record.words() +1' x
            n=n+1;code[n] = '      if wp > 0 then data = record.word(wp)'
            n=n+1;code[n] = '      else data = ""'
          end
          else do
            n=n+1;code[n] = '      data = record.word('x''
          end
        end
        when rf & t.pos('.')>0 then do
          if \x.datatype('W') | \y.datatype('W') then
            signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric. Found:  't)
          if x < 0 then do
            n=n+1;code[n] = '      startp = 0.max(record.length() + 'x' + 1)'
          end
          else do
            n=n+1;code[n] = '      startp = 1.max('x')'
          end
          if y<0 then
            signal StageError(13,'Error (specs) - 'pInfo' - Invalid range 't)
          n=n+1;code[n] = '      endp = 'y
          n=n+1;code[n] = '      data = record.substr(startp,endp)'
        end
        when rf & t.right(2)='-*' then do
          if \x.datatype('W') then
            signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric. Found:  't)
          if x<0 then
            signal StageError(13,'Error (specs) - 'pInfo' - Invalid range' t)
          if x = 1 then do
            n=n+1;code[n] = '      data = record'
          end
          else do
            n=n+1;code[n] = '      data = record.substr('x')'
          end
        end
        when rf & t.pos(';')>0 then do
          if \x.datatype('W') | \y.datatype('W') then
            signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric. Found:  't)
          if x < 0 then do
            n=n+1;code[n] = '      startp = 0.max(record.length() + 'x' + 1)'
          end
          else do
            n=n+1;code[n] = '      startp = 1.max('x')'
          end
          if y < 0 then do
            n=n+1;code[n] = '      endp = 0.max(record.length() + 'y' + 1) - startp'
          end
          else do
            n=n+1;code[n] = '      endp = 'y'.min(record.length()) + 1 - startp'
          end
          n=n+1;code[n] = '      data = record.substr(startp,endp)'
        end
        when rf & t.pos('-', 2)>0 then do
          if \x.datatype('W') | \y.datatype('W') then
            signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric. Found:  't)
          if x < 0 then do
            n=n+1;code[n] = '      startp = 0.max(record.length() + 'x' + 1)'
          end
          else do
            n=n+1;code[n] = '      startp = 1.max('x')'
          end
          if y < 0 then do
            n=n+1;code[n] = '      endp = 0.max(record.length() + 'y' + 1) - startp'
          end
          else do
            n=n+1;code[n] = '      endp = 'y'.min(record.length()) + 1 - startp'
          end
          n=n+1;code[n] = '      data = record.substr(startp,endp)'
        end
        when rf & (type = 'a' | type = 's') then do
          ds = ds.changestr('"','""')
          ds = ds.changestr('\\','\\\\')
          n=n+1;code[n] = '      data = "'ds'"'
          b = t b
        end
        when type = 'r' then do
          rno = rno + 1
          code[recnoline] = code[recnoline]";recno["rno"]=Rexx" fromn";recno_byn["rno"]=Rexx" byn
          n=n+1;code[n] = '      data = recno['rno'].right(10)'
          n=n+1;code[n] = '      recno['rno'] = recno['rno'] + recno_byn['rno']'
        end
        when rf then
          signal StageError(13,'Error (specs) - 'pInfo' - unreconized range 't)
        when type = 'a' then do
            ds = ds.changestr('"','""')
            ds = ds.changestr('\\','\\\\')
            n=n+1;code[n] = '      data = "'ds'"'
        end
        when t = 'SELECT' then
          nop
        otherwise do
          delim = t.left(1)' '
          if ob.pos(delim)=0 then
            signal StageError(13,'Error (specs) - 'pInfo' - Missing data selector at 't)
          parse ob 2 t (delim) b
          parse t 'arg(' x ')'
          if t='arg()' | x.datatype('W') then do
            n=n+1;code[n] = "      data = "t
          end
          else do
            t = t.changestr('"','""')
            t = t.changestr('\\','\\\\')
            n=n+1;code[n] = "      data = '"t"'"
          end
      end
    end

         /* ***** New 6/22 ***** */
    if type = 'w' & wsep \== ' ' then do
      n=n+1;code[n] = '      data = decodew(data,' wsep')'
      n=n+1;code[n] = '      record = decodew(record,' wsep')'
    end

    if type = 'f' & fsep \= ' ' then do
      n=n+1;code[n] = '      data = decodew(data,' fsep', 1)'
      n=n+1;code[n] = '      record = decodew(record,' fsep', 1)'
    end
        /* **** End new ***** */

    if fid \= '' then do
      n=n+1;code[n] = '      field["'fid'"] = data'
      n=n+1;code[n] = '      fid = ""'
      fid = ""
    end

    -- process a string
    parse b t b
    if t = 'strip' then do
      n=n+1;code[n] = '      data = data.strip("B")'
      parse b t b
    end

    -- process conversion functions
    select
      when t = 'b2c' then do
        n=n+1;code[n] = '      data = xl2c(data.b2x())'
        parse b t b
      end
      when t = 'b2x' then do
        n=n+1;code[n] = '      data = data.b2x()'
        parse b t b
      end
      when t = 'c2b' then do
        n=n+1;code[n] = '      data = c2xl(data).x2b'
        parse b t b
      end
      when t = 'c2d' then do
        n=n+1;code[n] = "      datar = Rexx data;l= datar.length;out=''"
        n=n+1;code[n] = '      loop i=1 to l'
        n=n+1;code[n] = '        out=out || datar.substr(i,1).c2d().right(2,0)'
        n=n+1;code[n] = '      end'
        n=n+1;code[n] = '      data=out'
        parse b t b
      end
      when t = 'c2x' then do
        n=n+1;code[n] = "      datar = Rexx data.strip('T');l= datar.length;out=''"
        n=n+1;code[n] = '      loop i=1 to l'
        n=n+1;code[n] = '        co = datar.substr(i,1).c2x()'
        n=n+1;code[n] = '        out=out""(00""co).right(2)' -- NetRexx strips 0s and blanks
        n=n+1;code[n] = '      end'
        n=n+1;code[n] = '      data=out'
        parse b t b
      end
      when t = 'd2c' then do
        n=n+1;code[n] = '      data = xl2c(data.d2x)'
        parse b t b
      end
      when t = 'd2x' then do
        n=n+1;code[n] = '      data = data.d2x()'
        parse b t b
      end
      when t = 'x2b' then do
        n=n+1;code[n] = '      data = data.x2b()'
        parse b t b
      end
      when t = 'x2c' then do
        n=n+1;code[n] = "      datar = Rexx data"
        n=n+1;code[n] = "      l= datar.length;out=''"
        n=n+1;code[n] = '      loop i=1 to l by 2'
        n=n+1;code[n] = '        out=out||datar.substr(i,2).x2c()'
        n=n+1;code[n] = '      end'
        n=n+1;code[n] = '      data=out'
        parse b t b
      end
      when t = 'x2d' then do
        n=n+1;code[n] = '      data = data.x2d()'
        parse b t b
      end
      when ' c2f c2i c2p c2v f2c f2t i2c p2c v2c'.pos(t) > 0 then do
        signal StageError(13,'Error (specs) -' t b '- Conversion not yet available in Njpipes: 't)
      end
      when t = 'lower' then do
        n=n+1;code[n] = '      data = data.lower()'
        parse b t b
      end
      when t = 'upper' then do
        n=n+1;code[n] = '      data = data.upper()'
        parse b t b
      end
      when t = 'string' then do
        n=n+1;code[n] = '      data = data.toString()'
        parse b t b
      end
              /* **** New 12/22 **** */
      when t='netrexx',t='nr' then do
        nrc = getKeyWord(t b, 'netrexx', 7, 'D')
        if nrc[5] = 0 then
          nrc = getKeyWord(t b, 'nr', 2, 'D')
        b = nrc[1]
        ufn = ufn + 1
        n=n+1;code[n] = '      data = user'ufn'(data)'

             /* ensure the user fuction ends with "return data" if needed */
        ucode = nrc[2].strip('B').strip('T',';') -- clean it up
        lsc = ucode.lastpos(';') + 1
        parse ucode . =(lsc) verb object rest  -- what is last statement?
        if verb \= 'return' then ucode = ucode';return data' -- add a return if needed

        uln=uln+1;uf[uln] = 'method user'ufn'(data)'
        uln=uln+1;uf[uln] = ' 'ucode

        parse b t b 1 ob
      end
              /* **** End New 12/22 **** */
      otherwise
        nop
    end

    -- process formater options
    word = b.word(1)
    word = word.strip('T',',')
    select
      when 'right'.abbrev(word,1) then do
        conv = '.strip("B").right('
        n = n+1
        b = b.subword(2)
      end
      when 'left'.abbrev(word,1) then do
        conv = '.strip("B").left('
        n = n+1
        b = b.subword(2)
      end
      when 'center'.abbrev(word,1) | 'centre'.abbrev(word,1)then do
        conv = '.strip("B").center('
        n = n+1
        b = b.subword(2)
      end
      otherwise
        conv = ''
    end

    -- output selector logic here
    if pad = '"' then pad = '""'
    if pad = '\\' then pad = '\\\\'

    t = t.strip.strip('T',',')

    tlow = t.lower()
    parse tlow tlowone '.'

    if t.pos('-')>0 then do
      parse t x '-' y
      if y = '*' then
      t = x
    end
    if t.pos(';')>0 then do
      parse t x ';' y
      if y = '*' then
      t = x
    end

    select
      when t = '', t = '.' then do   -- dot = ignore output
        nop
      end
      when ('nextword'.abbrev(tlowone,5) | 'nword'.abbrev(tlowone,2)) & t.pos('.')>0 then do
        parse t '.' x
        if \x.datatype('W') then
          signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric. Found:  't)
        if conv<>'' then
          conv = conv||x',"'pad'")'
        else
          conv = '.left('x',"'pad'")'
        n=n+1;code[n] = '      if data \\== "" then'
        n=n+1;code[n] = '        outp = outp" "data'conv  '-- 991'
      end
      when 'next'.abbrev(tlowone) & t.pos('.')>0 then do
        parse t '.' x
        if \x.datatype('W') then
          signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric. Found:  't)
        if conv<>'' then
          conv = conv||x',"'pad'")'
        else
          conv = '.left('x',"'pad'")'
        n=n+1;code[n] = '      outp = outp||data'conv
      end
      when ('nextword'.abbrev(tlow,5) | 'nword'.abbrev(tlow,2)) then do
        if conv<>'' then
          signal StageError(13,'Error (specs) - 'pInfo' - field 't' has no implied length')
        n=n+1;code[n] = '      if data \\== "" then'
        n=n+1;code[n] = '        outp = outp" "data'
      end
      when 'next'.abbrev(tlow) then do
        if conv<>'' then
          signal StageError(13,'Error (specs) - 'pInfo' - field 't' has no implied length')
        n=n+1;code[n] = '      outp = outp||data'
      end
      when t = 'write' then nop
      when t='1' then do
        if conv<>'' then
          signal StageError(13,'Error (specs) - 'pInfo' - field 't' has no implied length')
        n=n+1;code[n] = '      outp = data'
      end
      when t.datatype('W') then do
        if conv<>'' then
          signal StageError(13,'Error (specs) - 'pInfo' - field 't' has no implied length')
        n=n+1;code[n] = '      outp = outp.overlay(data,'t',data.length(),"'pad'")'
      end
      when t.pos('.')>0 then do
        parse t x '.' y
        if \x.datatype('W') | \y.datatype('W') then
          signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric. Found:  't)
        if x<0 | y<0 then
          signal StageError(13,'Error (specs) - 'pInfo' - Invalid range 't)
        if conv<>'' then
          conv = conv||y',"'pad'")'
        n=n+1;code[n] = '      leftpart = outp.substr(1,'x-1')'
        n=n+1;code[n] = '      rightpart = outp.substr('x+y')'
        n=n+1;code[n] = '      outp = outp.overlay(data'conv'.left('y'), 'x')'
        n=n+1;code[n] = '      outp = leftpart || data'conv'.left('y') || rightpart'
      end
      when t.pos(';')>0 then do
        parse t x ';' y
        if \x.datatype('W') | \y.datatype('W') then
          signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric. Found:  't)
        if x>0 | y<x then
          signal StageError(13,'Error (specs) - 'pInfo' - Invalid range 't)
        if conv<>'' then
          conv = conv||x.abs()+y+1',"'pad'")'
        n=n+1;code[n] = '      outp = outp.overlay(data'conv',outp.length()'x+1','x.abs()+y+1',"'pad'")'
      end
      when t.pos('-')>0 then do
        parse t x '-' y
        if \x.datatype('W') | \y.datatype('W') then
          signal StageError(13,'Error (specs) - 'pInfo' - Target range should be numeric. Found:  't)
        if x<0 | y<x then
          signal StageError(13,'Error (specs) - 'pInfo' - Invalid target range 't)
        if conv<>'' then
          conv = conv||y-x-1',"'pad'")'
        n=n+1;code[n] = '      outp = outp.overlay(data'conv','x','y-x+1',"'pad'")'
      end
      otherwise
        signal StageError(13,'Error (specs) - 'pInfo' - Missing target selector at 't)
    end

    ob = b
    parse b t b
  end

                /* end of stage input processing */

  if pr then
    p[s] = 1

  loop i over p                          -- issue readto for peeked streams
    if p[i] then do
      n=n+1;code[n] = '      do -- 1073'
      if s<>i & s \= "-1" then do
        n=n+1;code[n] = '         selectInput('i')'
        s = i
      end
      n=n+1;code[n] = '         readto() -- 1078'
      n=n+1;code[n] = '      catch StageError'
      n=n+1;code[n] = '         rc = rc()'
      n=n+1;code[n] = '      end'
      p[i] = 0
    end
    p["S"] = 0
  end
  if s<>0 then do
    n=n+1;code[n] = '      do'
    n=n+1;code[n] = '      selectInput(0)'
    n=n+1;code[n] = '      catch StageError'
    n=n+1;code[n] = '         rc = rc()'
    n=n+1;code[n] = '      end'
    s = 0
  end

  n=n+1;code[n] = '   catch StageError'
  n=n+1;code[n] = '      rc = rc()'
  n=n+1;code[n] = '   end'

  n=n+1;code[n] = 'exit(rc*(rc<>4)*(rc<>12))'

/* ****** New 6/22 **** */
  n=n+1;code[n] = 'method codew(data=Rexx, wsep=Rexx, isfield=Rexx 0) returns Rexx signals ThreadQ'
  n=n+1;code[n] = ' safesep = ""'
  n=n+1;code[n] = ' loop count = 0 to 99'        -- find a non-occuring character string
  n=n+1;code[n] = '  safespace = time("L").right(6)'
  n=n+1;code[n] = '  if data.pos(safespace) = 0 then leave'
  n=n+1;code[n] = ' end'
  n=n+1;code[n] = ' if count > 99 then do'
  n=n+1;code[n] = '   say "Codew could not get safespace"'
  n=n+1;code[n] = '   exit(13)'
  n=n+1;code[n] = ' end'
  n=n+1;code[n] = ' if isfield then do'
  n=n+1;code[n] = '  loop count = 0 to 99'
  n=n+1;code[n] = '   safesep = time("L").right(6) + 1'
  n=n+1;code[n] = '   if data.pos(safesep)=0 & safesep <> safespace then leave'
  n=n+1;code[n] = '  end'
  n=n+1;code[n] = '  if count > 99 then do'
  n=n+1;code[n] = '   say "Codew could not get safesep"'
  n=n+1;code[n] = '   exit(13)'
  n=n+1;code[n] = '  end'
  n=n+1;code[n] = ' end'
  n=n+1;code[n] = ' if data.substr(1,wsep.length) = wsep then data = safesep""data'
  n=n+1;code[n] = ' data = data.changestr(" ", safespace)'
  n=n+1;code[n] = ' data = data.changestr(wsep, " "safesep)'  -- makes sure each field has a character in it
  n=n+1;code[n] = 'return data'

  n=n+1;code[n] = 'method decodew(data=Rexx, wsep=Rexx, isfield=Rexx 0) returns Rexx'
  n=n+1;code[n] = ' data = data.changestr(" "safesep, wsep)'
  n=n+1;code[n] = ' data = data.changestr(safesep, "")'
  n=n+1;code[n] = ' data = data.changestr(safespace, " ")'
  n=n+1;code[n] = 'return data'

  n=n+1;code[n] = 'method xl2c(hex) returns Rexx' -- hex string to character string ala Rexx
  n=n+1;code[n] = ' if hex.length()//2 = 1 then hex = "0"hex'
  n=n+1;code[n] = '  cs = ""'
  n=n+1;code[n] = '  loop i = 1 by 2 to hex.length()'
  n=n+1;code[n] = '   cs = cs || hex.substr(i,2).x2c()'
  n=n+1;code[n] = '  end'
  n=n+1;code[n] = 'return cs'

  n=n+1;code[n] = 'method c2xl(cs) returns Rexx' -- character string to hex string ala Rexx
  n=n+1;code[n] = ' hex = ""'
  n=n+1;code[n] = ' loop i = 1 to cs.length'
  n=n+1;code[n] = '  hex = hex || cs.substr(i,1).c2x()'
  n=n+1;code[n] = ' end'
  n=n+1;code[n] = 'return hex'
/* ***** End new 6/22 ******* */

/* ***** New 12/22 ***** */
   -- include the user functions
  loop i = 1 to uln
    n=n+1;code[n] = uf[i]
  end
/* ***** End new 12/22 ******* */

  code[0]=n

  pInfo[3] = cname
  pInfo[4] = 'arg(_)'                     -- magic passthru value for arg()

  ss = 1 -- show generated source
  ss = 0 -- comment out to show generated source

  if ss then do
   trace off   -- Leave. This is for the source code out.
   say " "
   say "###########################################################"
   loop i = 1 for code[0]
    say i code[i]
   end
  end

  return 1

method getSep(opts, tok, len) returns Rexx[]
  wsep = Rexx null
  wsepa = Rexx ''
  if \ tok.lower.abbrev(opts.word(1).lower, len) then return [1]

--  /*  I have not been able to get these through OK. 12/22 Jeff Hennick
  select case opts.word(2).lower()
    when 'lf' then wsep = '\x0D'
    when 'cr' then wsep = '\x0A'
    when 'crlf' then wsep = '\x0A\x0D'
    otherwise wsep = null
  end
--   */

  if wsep \== null then do
    wsepa[1] = opts.subword(3)
  end
  else do
    wsepa = getKeyWord(opts, tok, len, 'S')
    do
      wsep = getXorc(wsepa[2])    -- PROBLEM! with getXorC('@')
    catch BadArgumentException
      wsep = null
    end
    /* we have either a single character or null */
  end

  if wsep == null then do
    if wsepa[2].datatype('X') & wsepa[2].length()//2 = 0 then do
      hs = wsepa[2]
      wsep = ''
      loop i = 1 by 2 to hs.length()/2 + 1
       wsep = wsep || hs.substr(i,2).x2c()
      end
    end
  end

   /* We have a string of one or more charcters from hex numbers */
  if wsep == null then do
    wsepa = getKeyWord(opts, tok, 2, 'Q')
    if wsepa[2] \= '' then do
      wsep = wsepa[2]
      rest = wsepa[1]
    end
  end

   /* We have a word, qword, or null */
  rest = wsepa[1]

  if wsep \== ' ' then do
    wsep = "'" || wsep.changestr("'", "''") || "'"
    rest = wsepa[1]
  end

  ret = [3, wsep, rest]
return ret

method xl2c(hex) returns Rexx -- hex string to character string ala Rexx
  if hex.length()//2 = 1 then hex = "0"hex
  cs = ""
  loop i = 1 by 2 to hex.length()
    cs = cs || hex.substr(i,2).x2c()
  end
return cs
