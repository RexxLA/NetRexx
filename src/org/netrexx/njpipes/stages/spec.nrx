-- specs
/*
 *  Copyright (C) 1997-2011 Ed Tomlinson
 *
 *  Distributed under the ICU 1.8.1 Licence with NO WARRANTIES of ANY kind.
 *  See LICENSE for the licence and information on using, copying, modifying,
 *  and distributing this program.
 *
 */

/*

 20/03/28 Added FIRST and SECOND; CENTRE
 20/03/26 various range specifiers; major fix for backward ABBREVs
 20/03/17 B2c, D2c, TODclock added.
 20/02/20 Hexidecimal & Binary handling.
 20/02/19 NUMBER, Alignment abbreviations; space optional on words & fields; additional tests on option names. Jeff Hennick
 2020/02/18 rename to spec for abbreviated name
 20/02/18 Can be used as a Driver stage, first in pipe. C2D, C2X, X2C, RECNO added. Jeff Hennick
 20/02/17 X,H, & Bstrings; Fix PAD; Documentation. Jeff Hennick
 20/02/14 Added NW for Nextword; pad: hexchar, BLANK, SPACE. Jeff Hennick
 99/05/06 fixed error with -n;-1 where n is longer than the string.  ejt
 99/01/12 fixed error with -1;-1  ejt
 99/01/03 changed error message.  ejt
 98/07/30 use StageError(13,... in stageExit.  ejt
 98/07/17 fix pad operations, output next.n was inserting a space.  EJT
*/

/** spec
            +-STOP--ALLEOF----+ (3)  v----------------------------------------+
 >>--SPECs--+-----------------+------+--+-| Group |-------------------------+-+-----------><
            +-STOP-+-ANYEOF-+-+ (3)     +-READ------------------------------+ (5)
                   +-n------+   (3)     +-READSTOP--------------------------+
                                        +-WRITE-----------------------------+
                                        +-SELECT-+-streamnum-+--------------+
                                        |        +-streamid--+              |  (3)
                                        |        +-FIRST-----+              |
                                        |        +-SECOND----+              |
                                        +-PAD--+-char----+------------------+
                                        |      +-hexchar-+                  |
                                        |      +-BLANK---+                  |
                                        |      +-SPACE---+                  |
                                        +-+-WORDSEParator---+--+--char---+--+  (3)
                                          +-WS------------- +  +-hexchar-+     (3)
                                          +-FIELDSEparator- +  +-BLANK---+     (3)
                                          +-FS------------- +  +-SPACE---+     (3)

Group:
 |--| Input |--| Conversion |--| Output |--| Alignment |--|

Input:
 |--+-Words-(1)-wnumberrange----------------------+-------|
    +-Fields-(1)-fnumberrange---------------------+  (3)
    +-cnumberrange--------------------------------+
    +-/string/------------------------------------+
    +-Xhexstring----------------------------------+
    +-Hhexstring----------------------------------+
    +-Bbinstring----------------------------------+
    |            +-FROM--1-------+ +-BY--1-----+  |
    +-+-RECNO--+-+---------------+-+-----------+--+
    | +-NUMBER-+ +-FROM--fromnum-+ +-BY--bynum-+  |
    +-TODclock------------------------------------+

Conversion:
 |-+-------+--+--------------------+------|
   +-STRIP-+  +-B2C----------------+
              +-B2D----------------+ (4)
              +-B2X----------------+ (4)
              +-C2B----------------+
              +-C2D----------------+
              +-C2F----------------+ (3)
              +-C2I----------------+ (3)
              +-C2P-+------------+-+ (3)
              |     +-(2)(scale)-+ | (3)
              +-C2V----------------+ (3)
              +-C2X----------------+
              +-D2C----------------+
              +-D2X----------------+ (4)
              +-F2C----------------+ (3)
              +-I2C----------------+ (3)
              +-P2C-+------------+-+ (3)
              |     +-(2)(scale)-+ | (3)
              +-V2C----------------+ (3)
              +-X2B----------------+ (4)
              +-X2C----------------+
              +-X2D----------------+ (4)
              +-f2t----------------+
              +-LOWER--------------+ (4)
              +-UPPER--------------+ (4)
              +-STRING-------------+ (4)

Output:
 |--+-Next-+-------+-------+--|
    |      +-(2).n-+       |
    +-NEXTWord-+-+-------+-+
    +-NWord----+ +-(2).n-+ |
    +-collumnrange---------+

Alignment:
 |--+--------+--|
    +-Left---+
    +-Center-+
    +-Centre-+
    +-Right--+

Ranges (cnumberrange, fnumberrange (3), wnumberrange):
 |--+-snumber-+--(2)--+-------------------------+--|
    +---*-----+       +--.-----(2)----number----+
                      +- - -+--(2)--+-snumber-+-+
                      +--;--+       +---*-----+

Notes:
 (1) Blanks are optional in this position.
 (2) Blanks are not allowed here.
 (3) CMS only. Not yet implemented in njpipes
 (4) Njpipes only. Not yet implemented in CMS
 (5) READ is giving the same output as READSTOP when the streams are different length.
 [6] This senses if it is the first stage, but comment stages will fool it into not
     producing any output.

**/

options nostrictcase nostrictargs nostrictsignal nobinary
package org.netrexx.njpipes.stages

import org.netrexx.njpipes.pipes.

class spec extends stage

  -- The run method of specs should never get called

  method run()
    rc = 16
    exit(rc)


    /*
     * pInfo    = name of pipe,
     * pInfo[1] = stage number in pipe
     * pInfo[2] = stage label, null if no label
     * pInfo[3] = stage name
     * pInfo[4] = stage arguements
     * pInfo[5] = rest of pipe
     * pInfo[6] = sep
     * pInfo[7] = end
     * pInfo[8] = not modifier active
     * pInfo[9] = stage is a driver
     * code     = ''
     * code[0]  = 0
     *
     * When compilerExit returns with true, the compiler expects:
     *
     * pInfo[2] = stage label
     * pInfo[3] = name of stage
     * pInfo[4] = stage arguements
     * pInfo[5] = rest of the pipe
     * code[0]  = number of lines generated
     * code[n]  = line n
     *
     */

  method stageExit(pInfo=Rexx,o=Rexx) returns boolean signals StageError

    pid  = pInfo
    name = pInfo[3]
    b    = pInfo[4]

    if pInfo[8] then
      signal StageError(13,'Error (specs) - 'pInfo' - not valid at 'pInfo[3]' 'pInfo[4])

    n   = o[0]          -- we update this stem and return it
    p   = rexx 0        -- true if a peek has been done
    s   = rexx '0'      -- the currently selected stream
    pr  = rexx 0        -- peakto required flag
    pad = rexx ' '      -- default pad char
    recnoline = rexx 0
    todline = rexx 0

    x = rexx
    y = rexx

    cname = stageName(name,pid,pInfo[1])
    o[n+1] ='class 'cname' extends stage private'
    o[n+2] ='--trace results'
    o[n+3]='method run()'
    o[n+4]="-- reserved for 'recno'"
    recnoline = n+4
    o[n+5]="-- reserved for 'tod'"
    todline = n+5
    o[n+7]='   data = Rexx ""'
    o[n+8]='   previous = Rexx ""; previous = previous'
    n = n+8

    cnts    = rexx 1    -- figure out how many stream we are going to use
    flgs    = rexx 1
    flgs[0] = 0

    parse b 'select' sn work
    loop while sn.datatype('W')
      if flgs[sn] then do
        cnts = cnts+1
        flgs[sn] = 0
      end
      parse work 'select' sn work
    end
    all = cnts          -- default to 'stop alleof' to end on all streams at eof

    o[n+1]='   outp = rexx ""'
    o[n+2]='   eoff = rexx 1; eoff = eoff'
    o[n+3]='   eoff["s"] = 0'
    o[n+4]='   eofc = rexx 0'
    if pInfo[9] then do  -- driver stage
      o[n+3]=''
      o[n+4]=''
    end
    o[n+5]='   read = boolean 1'
    o[n+7]='   loop label body while read'
    o[n+9] = '      read = 0'
    n = n+10

    if b.word(b.words())<>'write' then     -- and end with a write
      b = b' write'

    parse b t b 1 ob
                                -- prime loop
    loop label body while t<>''

      -- process stop / pad / read / readstop / select / write

      loop label options forever

        select

          when t='stop' then do
            parse b t b 1 ob
            select
              when t='alleof' then
                all = cnts
              when t='anyeof' then
                all = 1
              when t.datatype('W') then do
                if t>cnts then
                  signal StageError(13,'Error (specs) - 'pInfo' - there are only 'cnts' streams used')
              all = t
              end
              otherwise
                signal StageError(13,'Error (specs) - 'pInfo' - stop option 't' not supported')
            end
          end

          when t='pad' then do
            parse b t b 1 ob
            select
               when t.length = 1 then nop
               when t.length = 2 & t.datatype('X') then t = t.x2c
               when t = 'blank', t = 'space' then t = ' '
               otherwise
                 signal StageError(13,'Error (specs) - 'pInfo' - pad must be a single char, hexchar, BLANK or SPACE not 't)
            end
            pad = t
            parse b t b 1 ob
            iterate options
          end

          when t='select' then do
            parse b t b 1 ob
            if t.lower = 'second' then do
              s = 's'
              o[n+1] = '      ls = previous'
              n = n+1
            end
            else do
              if t.lower = 'first' then t = 0
              if \t.datatype('W') then
                signal StageError(13,'Error (specs) - 'pInfo' - select number must be numeric. found 't)
              if pr then do
                o[n+1] = '      do'
                o[n+2] = '         l's' = Rexx peekto(); l's' = l's
                o[n+3] = '         read = 1'
                o[n+4] = '      catch StageError'
                o[n+5] = '         rc = rc()'
                o[n+6] = '         eofc = eofc+eoff['s']'
                o[n+7] = '         eoff['s'] = 0'
                o[n+8] = '         if eofc>='all' then do'
                  o[n+9] = '            if outp<>"" then'
                  o[n+10]= '               output(outp)'
                  o[n+11]= '            leave body'
                  o[n+12]= '         end'
                  o[n+13]= '         l's' = ""'
                  o[n+14]= '      end'
                  n = n+15
                  p[s] = 1
                  pr = 0
              end
              o[n+1] = '      do'
              o[n+2] = '         selectInput('t')'
              o[n+3] = '      catch StageError'
              o[n+4] = '         rc = rc()'
              o[n+5] = '      end'
              n = n+6
              pr = 1
              s = t
            end
          end

          when t='read' then do
            -- This is giving the same result as READSTOP when the streams are differnt length.
            if s\='s' & s<0 then
              s = 0
            o[n+1] = '      do'
            n = n+1
            if p[s] then do
              o[n+1] = '         readto()'
              n = n+1
              o[n+1] = '         previous = l0'
              n = n+1
              p[s] = 0
            end
            o[n+1] = '         l's' = Rexx peekto(); l's' = l's
            o[n+2] = '         read = 1'
            o[n+3] = '      catch StageError'
            o[n+4] = '         rc = rc()'
            o[n+5] = '         eofc = eofc+eoff['s']'
            o[n+6] = '         eoff['s'] = 0'
            o[n+7] = '         if eofc>='all' then do'
            o[n+8] = '            if outp<>"" then'
            o[n+9] = '               output(outp)'
            o[n+10]= '            leave body'
            o[n+11]= '         end'
            o[n+12]= '         l's' = ""'
            o[n+13]= '      end'
            n = n+14
            pr = 0
            p[s] = 1
          end

          when t='readstop' then do
            if s\='s' & s<0 then
              s = 0
            o[n+1] = '      do'
            n = n+1
            if p[s] then do
              o[n+1] = '         readto()'
              n = n+1
              o[n+1] = '         previous = l0'
              n = n+1
              p[s] = 0
            end
            o[n+1] = '         l's' = Rexx peekto(); l's' = l's
            o[n+2] = '         read = 1'
            o[n+3] = '      catch StageError'
            o[n+4] = '         rc = rc()'
            o[n+5] = '         if outp<>"" then'
            o[n+6] = '            output(outp)'
            o[n+7] = '         leave body'
            o[n+8] = '      end'
            n = n+8
            pr = 0
            p[s] = 1
          end

          when t='write' then do                 -- write if its required
            o[n+1] = '      output(outp)'
            o[n+2] = '      outp = ""'
            n = n+3
          end

          otherwise
            leave options

        end -- select

        if t='write' & b='' then           -- force specs to finish
          leave body

 --         ob = b
          parse b t b 1 ob

      end options

      -- wait for a record and peekto it before processing

      if \p[s] & \pInfo[9] & s \= 's' then do
        o[n+1] = '      do'
        o[n+2] = '         l's' = Rexx peekto(); l's' = l's
        o[n+3] = '         read = 1'
        o[n+4] = '      catch StageError'
        o[n+5] = '         rc = rc()'
        o[n+6] = '         eofc = eofc+eoff['s']'
        o[n+7] = '         eoff['s'] = 0'
        o[n+8] = '         if eofc>='all' then do'
          o[n+9] = '            if outp<>"" then'
          o[n+10]= '               output(outp)'
          o[n+11]= '            leave body'
          o[n+12]= '         end'
          o[n+13]= '         l's' = ""'
          o[n+14]= '      end'
        n = n+15
        pr = 0
        p[s] = 1
      end

      -- process an input range
      type = ''
      tl = t.lower
      fc = tl.left(1)

      if tl = 'write' then fc = 's'
      select case fc
        when 'w' then do       -- handle word [space] range
          fn = t.verify('-1234567890','M')
          if fn > 0 then do
            parse tl tl =(fn) num
            b = num b
          end
          if \'words'.abbrev(tl,1) then signal StageError(13,'Error (specs) - 't b' - Unrecognized option:' t)
          type = 'w'
          parse b t b 1 ob
          t = 'word't
        end

        when 'f' then do       -- handle field [space] range
          fn = t.verify('1234567890','M')
          if fn > 0 then do
            parse tl tl =(fn) num
            b = num b
          end
          if \'fields'.abbrev(tl,1) then signal StageError(13,'Error (specs) - 't b' - Unrecognized option:' t)
          type = 'f'
          parse b t b 1 ob
          t = 'field't
        end

        when 'x', 'h' then do       -- handle hexidecimal range
          type = 'a'
          parse t 2 ds
          if \ds.datatype('X') then signal StageError(13,'Error (specs) - 't b' - Invalid hex number ')
          ret = Rexx ''
          loop i = 1 to ds.length by 2
            ret = ret || ds.substr(i,2).x2c
          end
          ds = ret
          parse b t b 1 ob
        end

        when 'b' then do       -- handle binary range
          type = 'a'
          parse t 2 ds
          if \ds.datatype('B') then signal StageError(13,'Error (specs) - 't b' - Invalid binary number ')
          ret = Rexx ''
          loop i = 1 to ds.length by 8
            cc = ds.substr(i,8)
            cc = cc
            ret = ret || ds.substr(i,8).b2x.x2c
          end
          ds = ret
          parse b t b 1 ob
        end

        when 'r', 'n' then do       -- handle recno
          if " recno number".pos(tl) = 0 then signal StageError(13,'Error (specs) - 't b' - Unrecognized option:' t)
          type = 'r'
          parse b fkey skey r
          fromn = Rexx 1 -- default
          if fkey = 'from' then do
            if \skey.datatype('W') then signal StageError(13,'Error (specs) - "from number" is not numeric 'b)
            fromn = skey
          end
          else r = b
          byn = Rexx 1 -- default
          if r.word(1) = 'by' then do
            parse r . skey r
            if \skey.datatype('W') then signal StageError(13,'Error (specs) - "by number" is not numeric 'b)
            byn = skey
          end
          b = r
        end
        when 't' then do       -- handle timeofday
          if \'todclock'.abbrev(tl,3) then signal StageError(13,'Error (specs) - 't b' - Unrecognized option:' t '::' tl)
          type = 't'
          parse b t b 1 ob
        end
        otherwise
           if fc.datatype('W') then do
              type = 'n'
           end
           else do
              type = 's'
           end
      end

                        -- make sure we have a range
      rf = 0
      tr = Rexx t
      tl = t.lower

      if type = 'w' then
        x = tr.substr(5).strip('L')
      else
        x = tr.strip('L')
      select
        when x.pos(';')>1 then
          parse x x ';' y
        when x.pos('.')>1 then
          parse x x '.' y
        when x.countstr('-')>1 then do
          if x.substr(1,1) = '-' then do
            parse x '-' x '-' y
            x = -x
          end
          else parse x x '-' y
        end
        when x.pos('-')>1 then
          parse x x '-' y
        otherwise
          y = '\n'
      end
      if x='*' then
        x = 1

      rf = x.datatype('W')&(y.datatype('W')|y='*'|y='\n')
      if \rf then do
        parse tl th '.'
        rf = ('next'.abbrev(th,1) | 'nextword'.abbrev(th, 5) | 'nw'.abbrev(th))
      end

      select
        when rf & type = 'w' & t.pos('.')>0 then do
          if \x.datatype('W') | \y.datatype('W') then
            signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric 't)
          if y<0 then
            signal StageError(13,'Error (specs) - 'pInfo' - Invalid range 't)
          if x=-1 then
            o[n+1] = "      stpos = l"s".words()"
          else if x<0 then
            o[n+1] = "      stpos = l"s".words()"x+1
          else
            o[n+1] = '      stpos =' x
          n = n+1
          o[n+1] = '      data = l's'.subword(stpos,'y') -- w.'
          n = n+1
        end
        when rf & type = 'w' & t.right(2)='-*' then do
          if \x.datatype('W') then
            signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric 't)
          if x<0 then
            signal StageError(13,'Error (specs) - 'pInfo' - Invalid range 't)
          o[n+1] = '      data = l's'.subword('x')'
          n = n+1
        end
        when rf & type = 'w' & t.pos(';')>0 then do
          if \x.datatype('W') | \y.datatype('W') then
            signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric 't)
          if x<0 then
            o[n+1] = "      stpos = l"s".words()"x+1
          else
            o[n+1] = '      stpos =' x
          n = n+1
          if y<0 then
            o[n+1] = "      len = l"s".words()"y"+2-stpos"
          else
            o[n+1] = '      len = 'y'-stpos+1'
          n = n+1
          o[n+1] = '      data = l's'.subword(stpos,len) -- w;'
          n = n+1
        end
        when rf & type = 'w' & t.substr(6).countstr('-')>1 then do
          if \x.datatype('W') | \y.datatype('W') then
            signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric 't)
          if x<0 then
            o[n+1] = "      stpos = l"s".words()"x+1
          else
            o[n+1] = '      stpos =' x
          n = n+1
          if y<0 then
            o[n+1] = "      len = l"s".words()"y"+2-stpos"
          else
            o[n+1] = '      len = 'y'-stpos+1'
          n = n+1
          o[n+1] = '      data = l's'.subword(stpos,len) -- -- w'
          n = n+1
        end
        when rf & type = 'w' & t.pos('-')>0 & y.datatype('W') then do
          if \x.datatype('W') | \y.datatype('W') then
            signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric 't)
          if y<0 then
            signal StageError(13,'Error (specs) - 'pInfo' - Invalid range 't)
          if x<0 then
            o[n+1] = "      stpos = l"s".words()"x+1
          else
            o[n+1] = '      stpos =' x
          n = n+1
          o[n+1] = '      len = 'y'-stpos+1'
          n = n+1
          o[n+1] = '      data = l's'.subword(stpos,len) -- w-'
          n = n+1
        end
        when rf & type = 'w' then do
          if \x.datatype('W') then
            signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric 't)
          if x<0 then
            o[n+1] = "      stpos = l"s".words()"x+1
          else
            o[n+1] = '      stpos =' x
          n = n+1
          o[n+1] = '      data = l's'.word(stpos)'
          n = n+1
        end
        when rf & t.pos('.')>0 then do
          if \x.datatype('W') | \y.datatype('W') then
            signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric 't)
          if y<0 then
            signal StageError(13,'Error (specs) - 'pInfo' - Invalid range 't)
          if x<0 then
            o[n+1] = "      stpos = l"s".length()"x+1
          else
            o[n+1] = '      stpos =' x
          n = n+1
          o[n+1] = '      data = l's'.substr(stpos,'y') -- .'
          n = n+1
        end
        when rf & t.right(2)='-*' then do
          if \x.datatype('W') then
            signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric 't)
          if x<0 then
            o[n+1] = "      stpos = l"s".length()"x+1
          else
            o[n+1] = '      stpos =' x
          n = n+1
          o[n+1] = '      data = l's'.substr(stpos) -- -*'
          n = n+1
        end
        when rf & t.pos(';')>0 then do
          if \x.datatype('W') | \y.datatype('W') then
            signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric 't)
          if x<0 then
            o[n+1] = "      stpos = l"s".length()"x+1
          else
            o[n+1] = '      stpos =' x
          n = n+1
          if y<0 then
            o[n+1] = "      len = l"s".length()"y"+1-stpos"
          else
            o[n+1] = "      len =" y+1"-stpos"
          n = n+1
          o[n+1] = '      data = l's'.substr(stpos,len) -- ;'
          n = n+1
        end
        when rf & t.pos('-',2)>0 then do
          if \x.datatype('W') | \y.datatype('W') then
            signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric 't)
          if x<0 then
            o[n+1] = "      stpos = l"s".length()"x+1
          else
            o[n+1] = '      stpos =' x
          n = n+1
          if y<0 then
            o[n+1] = "      len = l"s".length()"y"+1-stpos"
          else
            o[n+1] = "      len =" y+1"-stpos"
          n = n+1
          o[n+1] = '      data = l's'.substr(stpos,len) -- -'
          n = n+1
        end
        when rf & t.datatype('W') & type \= 'a' then do
          if x<0 then
            o[n+1] = "      stpos = l"s".length()"x+1
          else
            o[n+1] = '      stpos =' x
          n = n+1
          o[n+1] = '      data = l's'.substr(stpos, 1) -- n'
          n = n+1
        end
        when rf & type = 'a' then do
          ds = ds.changestr('"','""')
          ds = ds.changestr('\\','\\\\')
          o[n+1] = '      data = "'ds'"'
          n = n+1
          b = t b
        end
        when type = 'r' then do
          o[recnoline] = "recno=Rexx" fromn";recno_byn=Rexx" byn
          o[n+1] = '      data = recno.right(10)'
          n = n+1
          o[n+1] = '      recno = recno + recno_byn'
          n = n+1
        end
        when rf & type = 't' then do
          o[todline] = '      todmils = Rexx java.lang.System.currentTimeMillis()'
          o[n+1] = '      data = todmils.d2b(64)'
          n = n+1
          b = t b
        end
        when rf then
          signal StageError(13,'Error (specs) - 'pInfo' - unreconized range 't)
        otherwise do
          delim = t.left(1)
          if ob.substr(2).pos(delim)=0 then
            signal StageError(13,'Error (specs) - 'pInfo' - Missing data selector at 't)
          parse ob (delim) t (delim) b
          parse t 'arg(' x ')'
          if t='arg()' | x.datatype('W') then
            o[n+1] = "      data = "t
          else do
            t = t.changestr('"','""')
            t = t.changestr('\\','\\\\')
            o[n+1] = "      data = '"t"'"
          end
          n = n+1
      end
    end

    -- process a string
    parse b t b 1 ob
    if t = 'strip' then do
      o[n+1] = '      datar = Rexx data'
      n = n+1
      o[n+1] = '      data = datar.strip("B")'
      n = n+1
      parse b t b 1 ob
    end

    -- process conversion functions

    select
      when t = 'b2c' then do
        o[n+1] = '      datar = Rexx data'
        n = n+1
        o[n+1] = '      datar = datar'
        n = n+1
        o[n+1] = '      data=""'
        n = n+1
        o[n+1] = '      loop i=1 to datar.length by 8'
        n = n+1
        o[n+1] = '        data=data||datar.substr(i,8).b2x.x2c()'
        n = n+1
        o[n+1] = '      end'
        n = n+1
        parse b t b 1 ob
      end
      when t = 'b2d' then do
        o[n+1] = '      data = data.b2x.x2d()'
        n = n+1
        parse b t b 1 ob
      end
      when t = 'b2x' then do
        o[n+1] = '      data = data.b2x()'
        n = n+1
        parse b t b 1 ob
      end
      when t = 'c2d' then do
        o[n+1] = "      datar = Rexx data;l= datar.length;out=''"
        n = n+1
        o[n+1] = '      loop i=1 to l'
        n = n+1
        o[n+1] = '        out=out||datar.substr(i,1).c2d()'
        n = n+1
        o[n+1] = '      end'
        n = n+1
        o[n+1] = '      data=out'
        n = n+1
        parse b t b 1 ob
      end
      when t = 'c2b' then do
        o[n+1] = "      datar = Rexx data;l= datar.length;out=''"
        n = n+1
        o[n+1] = '      loop i=1 to l'
        n = n+1
        o[n+1] = '        out=out||datar.substr(i,1).c2x.x2b()'
        n = n+1
        o[n+1] = '      end'
        n = n+1
        o[n+1] = '      data=out'
        n = n+1
        parse b t b 1 ob
      end
      when t = 'c2x' then do
        o[n+1] = '      datar = Rexx data'
        n = n+1
        o[n+1] = '      l= datar.length'
        n = n+1
        o[n+1] = '      out=""'
        n = n+1
        o[n+1] = '      loop i=1 to l'
        n = n+1
        o[n+1] = '        out=out||datar.substr(i,1).c2x'
        n = n+1
        o[n+1] = '      end'
        n = n+1
        o[n+1] = '      data=out'
        n = n+1
        parse b t b 1 ob
      end
      when t = 'd2c' then do
        o[n+1] = '      datar = Rexx data'
        n = n+1
        o[n+1] = '      data = datar.d2c()'
        n = n+1
        parse b t b 1 ob
      end
      when t = 'd2x' then do
        o[n+1] = '      data = data.d2x()'
        n = n+1
        parse b t b 1 ob
      end
      when t = 'x2b' then do
        o[n+1] = '      data = data.x2b()'
        n = n+1
        parse b t b 1 ob
      end
      when t = 'x2c' then do
        o[n+1] = "      datar = Rexx data"
        n = n+1
        o[n+1] = "      l= datar.length;out=''"
        n = n+1
        o[n+1] = '      loop i=1 to l by 2'
        n = n+1
        o[n+1] = '        out=out||datar.substr(i,2).x2c()'
        n = n+1
        o[n+1] = '      end'
        n = n+1
        o[n+1] = '      data=out'
        n = n+1
        parse b t b 1 ob
      end
      when t = 'x2d' then do
        o[n+1] = '      data = data.x2d()'
        n = n+1
        parse b t b 1 ob
      end
      when ' c2f c2i c2p f2c i2c p2c v2c'.pos(t) > 0 then do
        signal StageError(13,'Error (specs) -' t b '- Conversion not yet available in Njpipes: 't)
      end
      when t = 'lower' then do
        o[n+1] = '      data = data.lower()'
        n = n+1
        parse b t b 1 ob
      end
      when t = 'upper' then do
        o[n+1] = '      data = data.upper()'
        n = n+1
        parse b t b 1 ob
      end
      when t = 'string' then do
        o[n+1] = '      data = data.toString()'
        n = n+1
        parse b t b 1 ob
      end
      otherwise
        nop
    end

    -- process formater options

    word = b.word(1)
    select
      when 'right'.abbrev(word,1) then do
        conv = '.strip("B").right('
        n = n+1
        b = b.subword(2)
      end
      when 'left'.abbrev(word,1) then do
        conv = '.strip("B").left('
        n = n+1
        b = b.subword(2)
      end
      when 'center'.abbrev(word,1) | 'centre'.abbrev(word,1) then do
        conv = '.strip("B").center('
        n = n+1
        b = b.subword(2)
      end
      otherwise
        conv = ''
    end

    -- output selector logic here
    if pad = '"' then pad = '""'
    if pad = '\\' then pad = '\\\\'

    tl = t.lower
    parse tl th '.'

    -- positioning
    select
      when ('nextword'.abbrev(th, 5) | 'nw'.abbrev(th)) & tl.pos('.')>0 then do
        parse t '.' x
        if \x.datatype('W') then
          signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric 't)
        if conv<>'' then
          conv = conv||x',"'pad'")'
        else
          conv = '.left('x',"'pad'")'
        o[n+1] = '      outp = outp" "data'conv
        n = n+1
      end
      when 'next'.abbrev(th, 1) & t.pos('.')>0 then do
        parse t '.' x
        if \x.datatype('W') then
          signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric 't)
        if conv<>'' then
          conv = conv||x',"'pad'")'
        else
          conv = '.left('x',"'pad'")'
        o[n+1] = '      outp = outp||data'conv
        n = n+1
      end
      when ('nextword'.abbrev(th, 5) | 'nw'.abbrev(th, 2)) then do
        if conv<>'' then
          signal StageError(13,'Error (specs) - 'pInfo' - field 't' has no implied length')
        o[n+1] = '      outp = outp data'
        n = n+1
      end
      when 'next'.abbrev(th, 1) then do
        if conv<>'' then
          signal StageError(13,'Error (specs) - 'pInfo' - field 't' has no implied length')
        o[n+1] = '      outp = outp||data'
        n = n+1
      end
      when t='1' then do
        if conv<>'' then
          signal StageError(13,'Error (specs) - 'pInfo' - field 't' has no implied length')
        o[n+1] = '      outp = data'
        n = n+1
      end
      when t.datatype('W') then do
        if conv<>'' then
          signal StageError(13,'Error (specs) - 'pInfo' - field 't' has no implied length')
        o[n+1] = '      outp = outp.left('t-1',"'pad'")||data'
        n = n+1
      end
      when t.pos('.')>0 then do
        parse t x '.' y
        if \x.datatype('W') | \y.datatype('W') then
          signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric 't)
        if x<0 | y<0 then
          signal StageError(13,'Error (specs) - 'pInfo' - Invalid range 't)
        if conv<>'' then
          conv = conv||y',"'pad'")'
        o[n+1] = '      outp = outp.overlay(data'conv','x','y',"'pad'")'
        n = n+1
      end
      when t.pos(';')>0 then do
        parse t x ';' y
        if \x.datatype('W') | \y.datatype('W') then
          signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric 't)
        if x<0 | y<x then
          signal StageError(13,'Error (specs) - 'pInfo' - Invalid range 't)
        if conv<>'' then
          conv = conv||x.abs()+y+1',"'pad'")'
        o[n+1] = '      outp = outp.overlay(data'conv',outp.length()'x+1','x.abs()+y+1',"'pad'")'
        n = n+1
      end
      when t.pos('-')>0 then do
        parse t x '-' y
        if x.datatype('W') & y = '*' then do
          if conv<>'' then
            signal StageError(13,'Error (specs) - 'pInfo' - field 't' has no implied length')
          o[n+1] = '      outp = outp.left('x-1',"'pad'")||data'
          n = n+1
        end
        else do
          if \x.datatype('W') | \y.datatype('W') then
            signal StageError(13,'Error (specs) - 'pInfo' - Range should be numeric 't)
          if x<0 | y<x then
            signal StageError(13,'Error (specs) - 'pInfo' - Invalid range 't)
          if conv<>'' then
            conv = conv||y-x-1',"'pad'")'
          o[n+1] = '      outp = outp.overlay(data'conv','x','y-x+1',"'pad'")'
          n = n+1
        end
      end
      when tl = 'write' then b = t b
      when tl = 'pad' then b = t b
      otherwise
        signal StageError(13,'Error (specs) - 'pInfo' - Missing target selector at 't)
    end

    parse b t b 1 ob
  end

  if pr then
    p[s] = 1

  loop i over p                          -- issue readto for peeked streams
    if p[i] then do
      o[n+2] = '      do'
      n = n+2
      o[n+1] = '        previous = l0'
      n = n+1
      if s<>i then do
        o[n+1] = '         selectInput('i')'
        n = n+1
        s = i
      end
      o[n+1] = '         readto()'
      o[n+2] = '      catch StageError'
      o[n+3] = '         rc = rc()'
      o[n+4] = '      end'
      n = n+4
      p[i] = 0
    end
  end
  -- end loop with stream 0 selected
  if s<>0 then do
    o[n+2] = '      do'
    o[n+3] = '      selectInput(0)'
    o[n+4] = '      catch StageError'
    o[n+5] = '         rc = rc()'
    o[n+6] = '      end'
    n = n+6
    s = 0
  end

  o[n+2] = '   catch StageError'
  o[n+3] = '      rc = rc()'
  o[n+4] = '   end'

  o[n+6] = 'exit(rc*(rc<>12))'
  n=n+7

  o[0]=n+1

  pInfo[3] = cname
  pInfo[4] = 'arg(_)'                     -- magic passthru value for arg()

  return 1
