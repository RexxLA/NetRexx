/*
 *  Copyright (C) 1997-2011 Ed Tomlinson
 *  Copyright (C) 1998  Jeffrey Hennick
 *  Copyright (C) 2020  Jeffrey Hennick
 *
 *  Distributed under the ICU 1.8.1 Licence with NO WARRANTIES of ANY kind.
 *  See LICENSE for the licence and information on using, copying, modifying,
 *  and distributing this program.
 *
 */

/*
 20/ 9/ 3 added getKeyWord. Jeff Hennick
 98/07/23 added the unprotected methods _findin and _findout.  ejt
*/

package org.netrexx.njpipes.pipes

options binary nostrictargs nostrictmethods nostrictcase

-- private utilites used by package to find pnodes in a stage

class utils private extends Object

  properties constant

  WAIT_OUT     = int     1
  CLEAR_OUT    = int   (-2)
  WAIT_READ    = int     2
  CLEAR_READ   = int   (-3)
  WAIT_ANY     = int     4
  CLEAR_ANY    = int   (-5)
  WAIT_COMMIT  = int     8
  CLEAR_COMMIT = int   (-9)
  SEVER        = int    16
  CLEAR_SEVER  = int  (-17)
  AUTO_COMMIT  = int    32
  LEAVE_NULL   = int    48
  CLEAR_AUTO   = int  (-33)
  RUNNING      = int  (-16)
  WAITING      = int    15

  INCREMENT    = int  256

  properties shared

  in   = pnode              -- input stream pnodes
  out  = pnode              -- output stream pnodes


  -- build the basic object

  method utils()

    in  = null
    out = null


    -- find input stream by number

  method findin(stream=int) returns pnode protect shared

    curr = pnode
    prev = pnode

    do                                        -- move to front search
      if in.sout<>stream then do
	prev = in
	curr = in.nin
	loop forever
          if curr.sout=stream then do
            prev.nin = curr.nin
            curr.nin = in
            in = curr
            leave
          end
          prev = curr
          curr = curr.nin
	end
      end
      return in
    catch NullPointerException
      return null
    end


    -- find output stream by number

  method findout(stream=int) returns pnode protect shared
    curr = pnode
    prev = pnode

    do
      if out.sin<>stream then do
	prev = out
	curr = out.nout
	loop forever
          if curr.sin=stream then do
            prev.nout = curr.nout
            curr.nout = out
            out = curr
            leave
          end
          prev = curr
          curr = curr.nout
	end
      end
      return out
    catch NullPointerException
      return null
    end


    -- find input stream by number (unprotected, no move to front)

  method _findin(stream=int) returns pnode shared
    curr = pnode
    do                                        -- move to front search
      if in.sout<>stream then do
	curr = in.nin
	loop forever
          if curr.sout=stream then
            return curr
          curr = curr.nin
	end
      end
      return in
    catch NullPointerException
      return null
    end


    -- find output stream by number (unprotected, no move to front)

  method _findout(stream=int) returns pnode shared
    curr = pnode
    do
      if out.sin<>stream then do
	curr = out.nout
	loop forever
          if curr.sin=stream then
            return curr
          curr = curr.nout
	end
      end
      return out
    catch NullPointerException
      return null
    end


    /*
     * This method is an exit called by the compiler.  With it you can change
     * the unprocessed pipe definition, the definition of the current stage,
     * and you can pass generated code back to the compiler.  To use it override
     * it.  See stages\append, stages\prefix and stages\specs for examples of its
     * use.
     *
     * stageExit is ONLY called for stages in the stage directory
     *
     * pInfo     = name of pipe,
     * pInfo[1]  = stage number in pipe
     * pInfo[2]  = stage label, null if no label
     * pInfo[3]  = stage name
     * pInfo[4]  = stage arguments
     * pInfo[5]  = rest of pipe
     * pInfo[6]  = sep
     * pInfo[7]  = end
     * pInfo[8]  = not modifier active
     * pInfo[9]  = stage is a driver (no input streams)
     * pInfo[10] = stage is a sink (no output streams)
     * pInfo[12] = cont
     *
     * code      = ''
     * code[0]   = 0
     *
     * When compilerExit returns with true, the compiler expects:
     *
     * pInfo[2]  = stage label
     * pInfo[3]  = name of stage
     * pInfo[4]  = stage arguments - note 'arg(_)' is magic and passes the pipe's
     *             argument to the stage unchanged.  See the specs stage.
     * pInfo[5]  = rest of the pipe
     * pInfo[8]  = not modifier active.   See nfind, nlocate.
     * pInfo[11] = IF you change the name of THIS stage to an existing stage, call
     *             the stageExit in pInfo[11].  The current stage should not be
     *             generating code and the new stage might.  See nfind, nlocate.
     * code[0]   = number of lines generated for classes
     * code[n]   = line n of generated code
     *
     */

  method stageExit(pInfo=Rexx,code=Rexx) returns boolean signals StageError

    if pInfo='' then
      signal StageError('Error - pipes must be named')   -- to avoid warning
    return 0

  /**
   * The compiler needs to know when the argument of a stage is a rexx object.
   * The rexxArg() method returns the number of rexx object arguments.  See
   * stem, stema, over and var.
   *
   */
    -- 98/07/15 definition changed. ejt

  method rexxArg(a=Rexx) returns Rexx
    return ''


  /**
   * The compiler needs to know when the argument of a stage is a stage(s).
   * The stageArg() method returns the position where the stages start.  See
   * prefix and append.
   *
   */
    -- 98/07/15 definition changed. ejt

  method stageArg(a=Rexx) returns Rexx
    return ''


  /**
   *
   * Insert static shared methods after this comment please
   *
   **/


    -- create an intelligent class name for a stageExit
    -- 98/08/25  initial.  ejt

  method stageName(a=Rexx,pid=Rexx,n=Rexx) returns Rexx static
    w = a.changestr(pid,'').changestr(n,'')
    w = pid'_'w'_'n
    w = w.changestr('__','_')
    return w


  method GetXorc(xorc) returns Rexx static
    --  GetXorc NJPipe Method
    -- 98/06/17 JHennick

  /** GetXorc(xorc)
     Returns a Rexx character

     A character specified as itself (a one-character word) or its
     hexadecimal representation (a two-character word).  The blank is
     represented by the keyword BLANK, which has the synonym SPACE, or with
     its hex value, X'40'.  The default horizontal tabulate character (X'05')
     is represented by the keyword TABULATE, which can be abbreviated down to
     TAB.
   */

    xl = xorc.length()

    select
      when xl = 1 then s = xorc
      when xl = 2 then s = xorc.x2c()
      when xorc = 'BLANK' then s = ' '
      when xorc = 'SPACE' then s = ' '
      when 'TABULATE'.abbrev(xorc.upper,3) then s = '\t'
      otherwise s = null
    end
    return s


  method GetXRange(xr) returns Rexx signals StageError static
    --  GetXRange NJPipe Method
    -- 98/06/17 JHennick

  /** GetXRrange

     returns Rexx string of characters in the xrange
     signals Error:  BadXRange


     xrange:
     +--+-xorc--------+-------------------------+
     +-xorc-xorc---+
     +-xorc.number-+

   */

    r = GetXorc(xr)
    if r = null then do
      parse xr x1 '-' x2

      c = 1
      if x2 \= '' then c = 0
      else parse xr x1 '.' e

      s = GetXorc(x1)
      if s = null then signal StageError('BadXrange')

      if c then do
	e = s.c2d + e - 1
	if e > 255 then e = e - 256
	e = e.d2c
      end
      else do
	e = GetXorc(x2)
	if s = null then signal StageError('BadXrange')
      end

      if e > s then r = s.sequence(e)
      else r = s.sequence('\xff') || '\0'.sequence(e)
    end

    return r -- GetXRange


    -- convert an object to Rexx if possible
    -- 99/05/28  fix array logic tests.  eht
    -- 98/09/07  add byte[] logic.  eht
    -- 98/08/23  add toSting to otherwise logic.  ejt
    -- 98/08/13  initial.  ejt

  method object2rexx(a=java.lang.Object) returns Rexx static signals StageError

    select
      when a=null then             -- encapsulated classes from
        return Rexx('')           -- java.lang can be added
      when a<=Rexx then
        return (Rexx a)
      when [byte 0].getClass().isInstance(a) then
        return Rexx(String(byte[] a,0,(byte[] a).length))
      when [Char '0'].getClass().isInstance(a) then
        return Rexx(char[] a)
      when [String ' '].getClass().isInstance(a) then
        return Rexx(string[] a)
      when a<=String then
        return Rexx(String a)
      otherwise
        return Rexx(a.toString())
    catch NoSuchMethodError
      signal StageError(8,'Error - cannot convert object to rexx')
    end


    -- convert an object to a string if possible
    -- 99/05/28  fix array logic tests.  eht
    -- 99/05/25  added byte[].  ejt
    -- 98/08/13  initial.  ejt

  method object2string(a=java.lang.Object) returns String static signals StageError

    select
      when a<=String then            -- encapsulated classes from
        return (String a)           -- java.lang can be added
      when [byte 0].getClass().isInstance(a) then
        return String(byte[] a,0,(byte[] a).length)
      otherwise
        return a.toString()
    catch NoSuchMethodError
      signal StageError(8,'Error - no toString method, cannot convert object')
    end


  method pos(h=byte[],n=byte[]) returns int static

    if h=null | n=null then
      return -1

    if n.length>h.length then
      return -1

    loop i=0 to h.length-n.length
      if h[i]=n[0] then do
	loop j=1 to n.length-1
          k = i+j
          if h[k]<>n[j] then
            iterate i
	end j
      return i
      end
    end i

    return -1


/*
   getKeyWord(argString, keyword, minKeyLength = 0, type = 'K')

This searches a string for a word or its abbreviation.  It is for
searching argument strings for key words.  A minKeyLength of '' or 0
means the full length is needed.  The search is case independent.  What
it returns depends on the type.

 Type values (Only the first character is used):
  -- Key: return boolean exists;
  -- Subword: return next word;
  -- Dstring: return DString
  -- Qword: return QWord

It returns a Rexx Indexed string of what it found including the original
string with the keyword (and Subword, Dstring, or Qword) removed.  If
the key word is not found the original string is returned.

A key of "" and type of "DString" will search for a Dstring at the
beginning of the argString.

Note:  This version, when searching for a keyword, does not respect
quoted strings or delimited strings.  It simply finds the first word
that matches.

 returns:
 [0] 5 -- number of return strings
 [1] the argString without the keyword & subkeyword(s)
 [2] the subkeyword(s) value
     (or for type Key 1: keyword found | 0: keyword not found)
 [3] the actual keyword found, this may be an abbreviation or mixed case
 [4] the delimiter for types Dstring and Qword
 [5] the word number of the keyword, 0 for not found
*/

/*
  20/ 9/ 3 New. Jeff Hennick
*/

method getKeyWord(argString = Rexx, keyword = Rexx, minKeyLength = Rexx 0, type = Rexx 'K') static returns Rexx

retindex = Rexx ''
retindex[4] = '' -- delimiter
ret = Rexx  -- subkeyword value
retw = Rexx ''
del2 = 1

argStringUp = argString.upper
keyword = keyword.strip
if keyword = "''" | keyword = '""' then keyword = ''
keywordUp = keyword.upper
minKeyLength = minKeyLength.strip
if \minKeyLength.datatype('W') | minKeyLength = 0 then minKeyLength = keyword.length

type = type.strip.left(1).upper

if keyword = '' then do
  wp = 0
end
else if minKeyLength = keyword.length then
  loop wp = 1 to argStringUp.words()
    if keywordUp = argStringUp.word(wp) then leave
  end
else
  loop wp = 1 to argStringUp.words()
    if keywordUp.abbrev(argStringUp.word(wp), minKeyLength) then leave
  end
if wp > argString.words() then wp = 0

retindex[5] = wp

ret = wp > 0      -- key word found

if ret then retindex[3] = argString.word(wp)
else retindex[3] = ''

select
when type = 'S' & ret then do       -- Suboption word
  retw = argString.word(wp + 1)
  del2 = 1
  argString = argString.delword(wp, 2)
end
when type = 'D' & (ret | keyword = '') then do        -- DString
  if keyword = '' then do
    opt = argString
    first = ''
  end
  else do
    opt = argString.subword(wp + 1)
    first = argString.subword(1, wp - 1)
  end
  ds = DString(opt)
  if ds.String() =  '' & ds.Delimiter() = '' then do -- not found
    ret = ''
    retindex[4] = ''
  end
  else do
    retw = ds.String()
    argString = first ds.Residue
    argStringUp = argString.upper
    retindex[4] = ds.Delimiter()
  end
end
when type = 'Q' & ret then do        -- possibly quoted "word"
  opt = argString.subword(wp + 1)
  if opt = '' then do
    ret = ''
  end
  else do
    fc = opt.left(1)
    if fc = '"' | fc = "'" then do
      ds = DString(opt)
      retw = ds.String()
      argString = argString.subword(1, wp - 1) ds.Residue
    end
    else do
      fc = ''
      retw = argString.word(wp + 1)
      argString = argString.delword(wp, 2)
    end
    argStringUp = argString.upper
    retindex[4] = fc
  end
end
when type = 'D' | type = 'Q' then   -- no keyword found
  ret = ''
when ret > 0 then do
  w = 1
  if type \= 'K' & del2 then w = 2     -- Keyword alone
  argString = argString.delword(wp,w)
  argStringUp = argStringUp.delword(wp,w)
end
otherwise
  nop
end

if type \= 'K' & retw <> '' then ret = retw

retindex[0] = 5 -- number of returned indexed strings
retindex[1] = argString   -- without what we found
retindex[2] = ret         -- what we were looking for
-- 3 actual keyword found
-- 4 delimiter
-- 5 word position
return retindex  -- getKeyWord

