/* IBM Materials Licensed under International Components for Unicode  */
/* Licence version 1.8.1 (ICU Licence) - Property of IBM              */
/* IBM NetRexx                                                        */
/* Copyright (c) 1995-2009 IBM Corp.                                  */
/* Copyright (c) 2011- RexxLA                                         */
/* ------------------------------------------------------------------ */
/* NetRexx language processor                                     mfc */
/* Copyright (c) IBM Corporation 1996, 2000.  All Rights Reserved.    */
/* ------------------------------------------------------------------ */
/* RxParser                                                           */
/*                                                                    */
/*   This is the program parser for NetRexx. It is called three       */
/*   times, once for each pass.  Its provider is RxClauser, which     */
/*   supplies tokenized clauses on demand.                            */
/*                                                                    */
/*   All RxError signals will be caught and handled here; at the end  */
/*   of a pass, any such error is raised as an RxQuit; RxQuits always */
/*   percolate up to the caller.                                      */
/*                                                                    */
/*   Almost no code is generated by this module; later we should make */
/*   it no code at all.                                               */
/* ------------------------------------------------------------------ */
/* 1996.05.24 Initial                                                 */
/* 1996.08.07 Changes for 3-pass                                      */
/* 1996.08.29 Changes for signals checking                            */
/* 1996.08.31 Dropout (unreachable) changes                           */
/* 1996.10.31 Handle RxErrors, 'een                                   */
/* 1997.04.17 Use fastpath symbol parser for common LHS cases         */
/* 1997.07.12 Reorganize to use RxClauseParser                        */
/* 1997.07.19 New this/super processing                               */
/* 1997.08.12 Use RxTermParser                                        */
/* 1998.03.15 Support minor classes                                   */
/* 1998.05.24 Allow TRACE in prologue                                 */
/* 1998.05.26 Allow NUMERIC in prologue                               */
/* 1999.10.19 If exec set then collect clauses in methods and classes */
/* 2000.02.11 Prologue TRACE/NUMERIC defer scan as well as generate   */
/* 2000.02.18 Provide a parsing cursor object, always updated         */
/* ------------------------------------------------------------------ */
package org.netrexx.process
options binary nodecimal strictcase strictargs

class RxParser uses RxCode
 properties public
  cursor      =RxCursor       -- the parsing cursor

  -- the next two might move to the cursor, later
  thislevel   =NrLevel   null -- current level descriptor
  level       =int            -- structural depth: 0 is outer, 1=class, 2+=method

  lastclass   =RxClass   null -- previous class (possible parent or sibling)
  uniques     =0              -- unique name counter (at program level) for labels, etc.
  publicclass =Rexx           -- name of public class
  indention   =int            -- indention to use for output code in pass2
  programstartchunk=int 0     -- where package/import statements will go

 properties shared
  copyright=RxProcessor.copyright

 properties private
  rxt       =RxTranslator     -- super boss
  clauser   =RxClauser        -- our provider
  tracer    =RxTracer         -- our tracer
  clausenum =int              -- current clause number

  -- The next two are lookaside for the default RxClass and RxMethod
  -- objects (which have no associated clauses to be tucked away in).
  defclass  =RxClauseParser   -- lookaside for default class
  defmethod =RxClauseParser   -- lookaside for default method

 method RxParser(newowner=RxTranslator)
  super()
  rxt=newowner
  clauser=rxt.program.clauser -- local reference
  tracer =rxt.program.tracer  -- local reference
  cursor=RxCursor(rxt.program, null, null, null)  -- parsing cursor

 /* ----------------------------------------------------------------- */
 /* PARSEPROGRAM -- parse a whole input stream (pass 0, 1, or 2)      */
 /* ----------------------------------------------------------------- */
 method parseprogram
  /* Initialize parsing variables and state */
  clausenum=0                 -- clause number
  thislevel=null              -- clear stack
  pushlevel('PROGRAM')        -- .. and initialize [also sets level]
  lastclass=null              -- no last class yet

  if rxt.pass2 then do
    indention=0               -- initialize
    rxt.program.streamer.out('/* Generated from '''rxt.program.source.getName()''''-
                              rxt.getstarttime() '[v'rxt.program.babel.getVersion()'] */')
    rxt.program.streamer.out('/* Options:' rxt.program.flag.toConciseString() '*/')
    programstartchunk=rxt.program.streamer.chunks -- record point
    if rxt.program.flag.comments then rxt.program.streamer.out('') -- separator
    end

  /* Here:
     prolog     clauses are called on pass 0 [and 2, if PACKAGE]
     CLASS      clauses are called on pass 0, '0.5', 1, '1.5', and 2
     TRACE    ) clauses are called on pass 1 and 2
     NUMERIC  )
     property )
     METHOD   )

  */
  reparse=boolean 0 -- need to reparse clause
  loop label mainloop forever
    do label errorhandle
    if reparse then reparse=0
     else do
      clausenum=clausenum+1
      cursor.curclause=clauser.clause(clausenum)
      if cursor.curclause=null then leave         -- EOS
      end

    indention=level                               -- for formatter
    tok=cursor.curclause.tokens[0]
    if tok.type=RxToken.SP then iterate mainloop  -- comment null clause
    if tok.type=RxToken.END then signal RxQuit(rxt, null, 'internal.error', 'null clause 1')
    tok2=cursor.curclause.tokens[1]

    ass=boolean 0                                 -- assigny
    if tok2.type=RxToken.OP then if tok2.value[0]='=' then ass=1

    if tok.type=RxToken.SYM then select label sym -- symbol
      when ass then nop                           -- not a keyword
      when tok2.type=RxToken.LPAR then nop        -- not a keyword
      when tok2.type=RxToken.LBRK then nop        -- not a keyword
      when tok2.type=RxToken.DOT  then nop        -- not a keyword

      when iskey(tok.value,'PACKAGE') then do     -- sets package name
        if rxt.pass1 then iterate
        if rxt.pass0 then cursor.curclause.lookaside=NrPackage(rxt)
        thispackage=NrPackage cursor.curclause.lookaside
        thispackage.scan(rxt.pass)
        if rxt.pass2 then if rxt.program.flag.java then thispackage.generate()
        iterate; end
      when iskey(tok.value,'OPTIONS') then do     -- sets translator state
        if \rxt.pass0 then iterate
        cursor.curclause.lookaside=NrOptions(rxt)
        cursor.curclause.lookaside.scan(rxt.pass)
        iterate; end
      when iskey(tok.value,'IMPORT') then do      -- allows short ames
        if \rxt.pass0 then iterate
        cursor.curclause.lookaside=NrImport(rxt)
        cursor.curclause.lookaside.scan(rxt.pass)
        iterate; end
      when iskey(tok.value,'TRACE') then do       -- [1998.05.24 now allowed]
        if rxt.pass0 then iterate
        if rxt.pass1 then do
          cursor.curclause.lookaside=NrTrace(rxt)
          -- save for deferred scan and code generation
          rxt.program.pendtrace.addElement(cursor.curclause)
          end
        iterate; end
      when iskey(tok.value,'NUMERIC') then do     -- [1998.05.26 now allowed]
        if rxt.pass0 then iterate
        if rxt.pass1 then do
          cursor.curclause.lookaside=NrNumeric(rxt)
          -- save for deferred scan and generation
          rxt.program.pendnumeric.addElement(cursor.curclause)
          end
        iterate; end
      when iskey(tok.value,'CLASS') then do
        if level>=1 then cursor.curclass.endclass() -- end previous class
        if rxt.pass0 then do
          cursor.curclause.lookaside=RxClass(rxt)
          rxt.program.classes.addElement(cursor.curclause.lookaside)
          end
        cursor.curclass=RxClass cursor.curclause.lookaside
        cursor.curclass.scan(rxt.pass)
        if rxt.pass2 then if rxt.program.flag.java then cursor.curclass.generate()
        reparse=parseclassbody(0)
        iterate; end
      when iskey(tok.value,'METHOD') then do
        if cursor.curclass=null then do label defclass -- need default class
          if rxt.pass0 then do
            defclass=RxClass(rxt)
            rxt.program.classes.addElement(defclass)
            end
          cursor.curclass=RxClass defclass
          cursor.curclass.defaultscan(rxt.pass)
          if rxt.pass2 then if rxt.program.flag.java then do
            cursor.curclass.generate()
            indention=level             -- for formatter
            end
          deferredClass()               -- process deferred TRACE/NUMERIC
          end defclass
        if \rxt.pass0 then do
          if level>=2 then cursor.curmethod.endmethod()
          if rxt.pass1 then cursor.curclause.lookaside=NrMethod(rxt)
          cursor.curmethod=RxMethod cursor.curclause.lookaside
          cursor.curmethod.scan(rxt.pass)
          if rxt.pass2 then if rxt.program.flag.java then do
            cursor.curmethod.generate()
            /* Trace it if METHODS or higher */
            tracer.traceclause(cursor.curclause, RexxTrace.METHODS)
            cursor.curmethod.traceargs()  -- trace args if needed
           catch RxError                -- [maybe in the future]
            nop                         -- .. and carry on
            end
          end
        reparse=parsemethodbody(0)
        iterate; end
      otherwise nop
      end sym

    -- not a normal starter for a class; assume we need to construct and
    -- process default class and method
    if rxt.pass0 then do
      defclass=RxClass(rxt)
      rxt.program.classes.addElement(defclass)
      end
    cursor.curclass=RxClass defclass
    cursor.curclass.defaultscan(rxt.pass)
    if \rxt.pass0 then do
      if rxt.pass2 then if rxt.program.flag.java then do
        cursor.curclass.generate()   -- generate while at level 1
        indention=level            -- for formatter
        end
      deferredClass()              -- now process deferred TRACE/NUMERIC
      if rxt.pass1 then defmethod=NrMethod(rxt)
      cursor.curmethod=RxMethod defmethod
      cursor.curmethod.defaultscan(rxt.pass)
      if rxt.pass2 then if rxt.program.flag.java then cursor.curmethod.generate()
      end
    reparse=parsemethodbody(1)

    catch RxError
      -- simply move to next clause if recoverable error seen
      if rxt.program.flag.diag then say '# RxError caught in program'
    end errorhandle
    end mainloop

  /* here for EOS */
  if rxt.program.classes.size()=0 then
    signal RxQuit(rxt, null, 'no.class.in.program')
  -- at least one class
  do
    cursor.curclass.endclass()                 -- end the final class
    -- and if generating code, close the class and any minor ones
    if rxt.pass2 then lastclass.closeclasses(0)   -- [curclass now null]
  catch RxError
    signal RxQuit   -- convert to a quit to tell caller to give up
  end
  if rxt.program.errorcount>0 then signal RxQuit  -- tell caller to give up

  /* Program is good.  Add any pending IMPORT statements */
  if rxt.pass2 then if rxt.program.javaimports.size()>0 then do label addimports
    enum=rxt.program.javaimports.elements()  -- enumerate the packages to import
    loop while enum.hasMoreElements()        -- while some left
      importname=String enum.nextElement()   -- get next
      rxt.program.streamer.outinsert('import' importname';', programstartchunk, 0)
      end
    end addimports

  return

 /* ----------------------------------------------------------------- */
 /* PARSECLASSBODY -- parse the content of a class                    */
 /* Arg1 is reparse -- 1 if current clause is to be reparsed, 0       */
 /*         otherwise (1 is used after a default CLASS start)         */
 /* Returns 1 if current clause is to be reparsed, 0 otherwise        */
 /*                                                                   */
 /* Level will be 1: in class body                                    */
 /* We have had actual or default CLASS instruction                   */
 /* ----------------------------------------------------------------- */
 method parseclassbody(reparse=boolean)
  willexec=\rxt.wontexec & rxt.pass2

  deferredClass()   -- process any deferred TRACE or NUMERICs

  lastclause=RxClause null
  loop label mainloop
    do label errorhandle
    if reparse then reparse=0                -- [without leaving loop]
     else do
      clausenum=clausenum+1
      cursor.curclause=clauser.clause(clausenum)
      if cursor.curclause=null then leave    -- EOS
      end

    indention=level                          -- for formatter
    tok=cursor.curclause.tokens[0]
    if tok.type=RxToken.SP  then iterate mainloop -- A comment null clause
    if tok.type=RxToken.END then signal RxQuit(rxt, null, 'internal.error', 'null clause 2')

    /* in pass 0 we ignore everything except CLASS clauses */
    if rxt.pass0 then do
      tok2=cursor.curclause.tokens[1]
      /* Could be wrong here, due to variables, but will discover in pass 2 */
      if tok.type=RxToken.SYM then if tok2.type=RxToken.SP then
       if Rexx(tok.value).OpEq(null,'class') then return 1 -- [caseless compare]
      iterate mainloop
      end

    /* --- Here only for pass1 and pass2 --- */
    if tok.type\=RxToken.SYM then signal RxQuit(rxt, tok, 'property.or.keyword.expected')

    if willexec then do                 -- add clause to class chain
      if lastclause=null then cursor.curclass.classclauses=cursor.curclause
                         else lastclause.next=cursor.curclause
      cursor.curclause.last=lastclause
      lastclause=cursor.curclause
      end

    tok2=cursor.curclause.tokens[1]; t2=tok2.type
    /* Properties are allowed as we're outside method */
    /* To get here, we must be outside method.
       We expect either X; or X=expr; */
    if t2=RxToken.DOT | t2=RxToken.LBRK then
      signal RxError(rxt, tok, 'complex.property.name')
    /* Can only be a property if followed by either '=' or RxToken.END */
    isplain =boolean 0
    isassign=boolean 0
    if t2=RxToken.END then isplain=1
     else if t2=RxToken.OP then if tok2.value[0]='=' then isassign=1
    if isassign | isplain then do label property  -- should be a property
      /* In pass1 we can't always handle completely general
         initialization expressions, as they may contain forward
         references to methods in the current class.  This means
         that properties with such initialization can't be used in
         argument lists of methods as their type is not known.
         [1997.02.13: or as indirect properties.]
         To do the best we can here, we let Assign handle errors
         raised during pass1, and convert them to a result of 'void'
         on pass1.
         [1997.04.09] This replaces the pre-analysis strategy used
         for the year prior to this, which failed many perfectly
         reasonable codings, such as IFB's "piggy3".
         */
      /* Construct the term for the LHS.  We expect it to be unknown */
      term=rxt.tparser.parsesymbol(cursor, 0) -- [fastpath parser]
      if term.group\=T_UNKNOWN then do
        -- we've already used this name for a property
        if term.javacode==tok.value
          then signal RxError(rxt, tok, 'duplicate.property.name')
          else signal RxError(rxt, tok, 'ambiguous.property.name', term.javacode)
        end
      if rxt.pass1 then do
        assign=NrAssign(rxt)                 -- construct assignment
        cursor.curclause.lookaside=assign    -- save
        end
       else
        assign=NrAssign cursor.curclause.lookaside  -- retrieve
      assign.process(term, 1)           -- process RHS on both passes
      if rxt.pass2 then                 -- generate code
       if rxt.program.flag.java then assign.generate()
      iterate                           -- and go for next clause
      end property
    /* other cases drop through for different message */

    /* Expecting only PROPERTIES, NUMERIC, METHOD, TRACE, or CLASS
       keyword instructions at this point; handle these, also the
       prologue cases for better error messages */
    if t2\=RxToken.SP then
     if t2\=RxToken.END then
     if t2\=RxToken.STR then
     if t2\=RxToken.OP then             -- can't be keyword
      signal RxQuit(rxt, tok, 'not.allowed.outside.method') -- e.g., say()
    select
      when iskey(tok.value,'METHOD') then do
        if willexec then do -- this clause is not part of prologue after all
          if cursor.curclause.last\=null then cursor.curclause.last.next=null
                                         else cursor.curclass.classclauses=null
          end
        if level>=2 then cursor.curmethod.endmethod()
        if rxt.pass1 then cursor.curclause.lookaside=NrMethod(rxt)
        cursor.curmethod=RxMethod cursor.curclause.lookaside
        cursor.curmethod.scan(rxt.pass)
        if rxt.pass2 then if rxt.program.flag.java then do
          cursor.curmethod.generate()
          /* Trace it if METHODS or higher */
          tracer.traceclause(cursor.curclause, RexxTrace.METHODS)
          cursor.curmethod.traceargs()         -- trace args if needed
          end
        reparse=parsemethodbody(0)
        iterate; end
      when iskey(tok.value,'PROPERTIES') then do
        if rxt.pass1 then cursor.curclause.lookaside=NrProperties(rxt)
        props=NrProperties cursor.curclause.lookaside
        props.scan(rxt.pass)
        if rxt.pass2 then if rxt.program.flag.java then props.generate()
        iterate; end
      when iskey(tok.value,'NUMERIC') then do
        if rxt.pass1 then cursor.curclause.lookaside=NrNumeric(rxt)
        cursor.curclause.lookaside.scan(rxt.pass)
        if rxt.pass2 then if rxt.program.flag.java then cursor.curclause.lookaside.generate()
        iterate; end
      when iskey(tok.value,'TRACE') then do
        if rxt.pass1 then cursor.curclause.lookaside=NrTrace(rxt)
        trace=NrTrace cursor.curclause.lookaside
        trace.scan(rxt.pass)
        -- Trace level is needed in pass 1 for entry level for methods
        if rxt.pass1 then if cursor.curclass.tracelevel<trace.level then
          cursor.curclass.tracelevel=trace.level
        if rxt.pass2 then if rxt.program.flag.java then trace.generate()
        iterate; end
      when iskey(tok.value,'CLASS') then do
        if willexec then do -- this clause is not part of prologue after all
          if cursor.curclause.last\=null then cursor.curclause.last.next=null
                                         else cursor.curclass.classclauses=null
          end
        return 1
        end
      /* The next group are for better error messages */
      when iskey(tok.value,'OPTIONS') then NrOptions(rxt)
      when iskey(tok.value,'PACKAGE') then NrPackage(rxt)
      when iskey(tok.value,'IMPORT')  then NrImport(rxt)
      otherwise nop
      end
    signal RxQuit(rxt, tok, 'not.allowed.outside.method')

    catch RxError
      -- simply move to next clause if recoverable error seen
      if rxt.program.flag.diag then say '# RxError caught in classbody'
    end errorhandle
    end mainloop
  return 0  /* parseclassbody */

 /* ----------------------------------------------------------------- */
 /* PARSEMETHODBODY -- parse the content of a method                  */
 /* Arg1 is reparse -- 1 if current clause is to be reparsed, 0       */
 /*         otherwise (1 is used after a default METHOD start)        */
 /* Level 2 means in method body                                      */
 /* We have had actual or default METHOD instruction                  */
 /* Returns 1 if current clause is to be reparsed, 0 otherwise        */
 /*                                                                   */
 /* The 'neededcon' juggling, here, is a way to avoid the Java        */
 /* restriction of not allowing declarations before the first         */
 /* constructor call in a constructor.                                */
 /* ----------------------------------------------------------------- */
 method parsemethodbody(reparse=boolean)
  willexec=\rxt.wontexec      -- we can assume it's pass2

  lastclause=RxClause null
  loop label mainloop forever
    do label errorhandle
    if reparse then reparse=0
     else do
      clausenum=clausenum+1
      cursor.curclause=clauser.clause(clausenum)
      if cursor.curclause=null then return 0 -- EOS: end of stream
      end

    indention=level                          -- for formatter
    tok=cursor.curclause.tokens[0]; t=tok.type
    if t=RxToken.END then signal RxQuit(rxt, null, 'internal.error', 'null clause 3')
    tok2=cursor.curclause.tokens[1]; t2=tok2.type

    /* In pass 0 we ignore everything except CLASS clauses; these just
       end the method and trigger re-parse */
    if rxt.pass0 then do
      /* Could be wrong here, due to variables, but will discover in pass 2 */
      if t=RxToken.SYM then if t2=RxToken.SP then
       if Rexx(tok.value).OpEq(null,'class') then return 1 -- [caseless compare]
      iterate mainloop
      end

    /* In pass 1 we ignore everything except:
         CLASS EXIT METHOD NUMERIC RETURN TRACE
       clauses */
    if rxt.pass1 then do label pass1
      -- cannot be a keyword clause unless starts with a symbol
      if t\=RxToken.SYM then iterate mainloop
      -- must be 4-7 characters
      tlen=tok.value.length
      if tlen<4, tlen>7 then iterate mainloop

      -- cannot be a keyword clause unless symbol followed by usuals
      if t2\=RxToken.SP then
       if t2\=RxToken.STR then
       if t2\=RxToken.OP  then
       if t2\=RxToken.END then iterate mainloop
      -- if followed by an '=' it cannot be a keyword clause
      if t2=RxToken.OP then if tok2.value[0]='=' then iterate mainloop

      v=Rexx(tok.value).upper()
      /* Could be wrong here, due to variables, but will discover in pass 2 */
      if v=='CLASS' then return 1
      if v=='METHOD' then return 1

      /* Just note any EXITs, for exit processing */
      if v=='EXIT' then do
        rxt.hadexit=1
        iterate mainloop
        end

      /* We need to process all TRACEs in pass1, if only for empty cases */
      if v=='TRACE' then do
        trace=NrTrace(rxt)
        cursor.curclause.lookaside=trace           -- save for processing below
        trace.scan(rxt.pass)                 -- process the clause
        cursor.curmethod.methodtracechange=1 -- TRACE seen [need trace object]
        if cursor.curmethod.methodmaxtrace<trace.level
         then cursor.curmethod.methodmaxtrace=trace.level
        iterate mainloop
        end

      /* The only interesting instructions now have >1 token:
           RETURN with expression
           NUMERIC xxx
         so we can take a quick exit if the keyword is followed directly
         by RxToken.END */
      if t2=RxToken.END then iterate mainloop

      /* RETURN check is for automatically generating a return type of Rexx */
      -- Since RETURN is only interesting, here, if unknown and this
      -- RETURN returns a value, we test for unknown first.
      if \cursor.curmethod.methodrettypeknown then -- if we don't know type for sure
       if v=='RETURN' then do -- returning something
        if t2=RxToken.SP then begin=2; else begin=1
        cursor.curmethod.setrettype(RxType.REXX_TYPE, cursor.curclause.tokens[begin])
        iterate mainloop
        end
      /* NUMERIC check simply tests for existence */
      if \cursor.curmethod.methodhadnumeric then -- if we don't have a NUMERIC yet
       if v=='NUMERIC' then do
        cursor.curmethod.methodhadnumeric=1
        iterate mainloop
        end
      iterate mainloop
      end pass1

    /* --- Pass 2 -- real processing to be done on a clause --- */
    /* Handle the 'enders' -- CLASS or METHOD -- up front */
    if t=RxToken.SYM then do label endercheck
      if t2\=RxToken.SP then
       if t2\=RxToken.STR then
       if t2\=RxToken.OP  then
       if t2\=RxToken.END then leave endercheck
      if t2=RxToken.OP then if tok2.value[0]='=' then leave endercheck
      /* These two end the method; they need not be reachable */
      if iskey(tok.value,'CLASS'), iskey(tok.value,'METHOD') then do
        statecheck(null)           -- process IF/SELECT automatic ends
        return 1                   -- [indicating not an executable clause]
        end
      end endercheck

    /* Clause is part of the current method */
    if willexec then do                      -- if interpretation likely
      if lastclause=null then cursor.curmethod.methodclauses=cursor.curclause
                         else lastclause.next=cursor.curclause
      cursor.curclause.last=lastclause
      lastclause=cursor.curclause
      end

    /* Handle then ignore comment null clauses [leave lookaside null] */
    -- [they can never affect execution]
    if t=RxToken.SP then do
      if t2\=RxToken.END then signal RxQuit(rxt, null, 'internal.error', 'leading blank')
      /* Trace the clause (unless it is unreachable, because javac would
         then complain) */
      if \thislevel.terminal then
        tracer.traceclause(cursor.curclause) -- trace if needed
      iterate mainloop   -- ignore
      end

    /* process IF/SELECT automatic ends now */
    statecheck(cursor.curclause)   -- process IF/SELECT automatic ends

    /* Ready for a new 'real' clause within a method.
       Things allowed now:
         assignment/declaration
         delta expression (A+1 --> A=A+1)  [nyi]
         method call xx.yy.zz()
         keyword instruction [might be METHOD or CLASS, which end
           current method]
    */
    -- If method is supposed to be empty, then complain
    if cursor.curmethod.isNative() then
      signal RxQuit(rxt, tok, 'native.method.not.empty')
    if cursor.curmethod.isAbstract() then
      signal RxQuit(rxt, tok, 'abstract.method.not.empty')

    /* Handle things that start with terms: that is, everything. */
    /* [1997.04.15] Optimization: if the syntax can only be a keyword,
         or a simple variable name on the LHS, then simply use the
         RxTermParser 'fastpath' symbol parser.   This avoids 'heavy'
         term parsing and field lookup, giving measurable performance
         advantages for the usual case where a keyword is not a variable
         name and also for the very common simple assignment cases.
       [1997.07.19] improvement in processing recognizes this()/super()
         call at this point, as it has distinctive syntax.  This greatly
         simplifies the logic, at the expense of doing a little extra
         work here.
       [1998.04.10] extend to allow parent.super() and arg.super() for
         dependent classes.
       [2000.04.11] extend to allow xxx.Foo.this.super() for dependent classes.
       */
    term=RxCode null                         -- none so far
    firstcon  =boolean 0                     -- 1 if first clause in constructor
    specialcon=boolean 0                     -- 1 if found this()/super()
    if cursor.curthis=null then if \cursor.curmethod.methodstatic then do
      -- we are at start of a constructor
      firstcon=1                             -- this/super allowed
      if t=RxToken.SYM then do label slpar
        maybespec=0                          -- where we might have special
        -- any number of xx.xx. are allowed before the super/this
        loop while cursor.curclause.tokens[maybespec+1].type=RxToken.DOT
          if cursor.curclause.tokens[maybespec+2].type\=RxToken.SYM then leave
          maybespec=maybespec+2
          end
        if cursor.curclause.tokens[maybespec+1].type=RxToken.LPAR then do label lpar
          -- could be a special
          name=Rexx(cursor.curclause.tokens[maybespec].value)
          if \rxt.program.flag.strictcase then name=name.lower()
          if name=='this' | name=='super' then do
            -- 'this' cannot be qualified, so ignore if it is
            if maybespec>0 then if name=='this' then leave lpar
            -- if no error then we are special; let TermParser have a try
            term=rxt.tparser.parseterm(cursor, 0, 0) -- (we are on LHS)
            -- if we get back to here (no error), we were right
            specialcon=1                     -- remember we did, locally
            cursor.curthis=cursor.curmethod  -- indicate have instance
            end /* this/super */
          -- else RxMethod will add super() in endmethod
          end lpar
        end slpar /* S( or S.S( */
      finally
        -- whether this/super call is real or implied, we now have an instance
        cursor.curthis=cursor.curmethod      -- [any non-null will do]
      end /* noinstance */

    if t=RxToken.SYM then if term=null then do -- promising for fastpath
      -- note "foo;" could be a method call, so isn't a fastpath candidate
      if t2=RxToken.SP then             -- OK to use fastpath symbol parser
        term=rxt.tparser.parsesymbol(cursor, 0)
       else if t2=RxToken.OP then
        if tok2.value\=null then
        if tok2.value[0]='=' then
        term=rxt.tparser.parsesymbol(cursor, 0) -- OK to use fastpath constructor
      end
    if term==null then                  -- More complicated; use the slower way
      term=rxt.tparser.parseterm(cursor, 0, 0)  -- (we are on LHS)

    -- one way or another, we now have LHS term
    if term.begclause=null then signal RxQuit(rxt, tok, 'internal.error', 'RxParser: bcnull')
    n=term.endoff+1

    tokn=cursor.curclause.tokens[n]; tn=tokn.type

    /* Method call instructions are general terms that are methods and
       have nothing following them.
       This also handles constructor terms.
       [2000.02.20 create lookaside for these]
       */
    if tn=RxToken.END then
     if term.group=S_METHOD | term.group=S_CONSTR then do
      -- gentle warning if non-special constructor call first in constructor
      if term.group=S_CONSTR then            -- maybe warning
       if firstcon then if \specialcon then
        RxWarn(rxt, tok, 'unexpected.constructor')
      reachcheck()                           -- ensure reachable
      addexceptions(1, term.exceptions, tok) -- record exceptions
      tracer.traceclause(cursor.curclause)   -- trace if needed
      methcall=NrMethodcall(rxt)             -- construct clause
      cursor.curclause.lookaside=methcall    -- save
      -- We've already done the parsing, so no scan necessary
      methcall.process(term, specialcon)     -- record the term
      if rxt.program.flag.java then methcall.generate() -- generate code
      if specialcon then                     -- bump method start
        cursor.curmethod.methodstartchunk=rxt.program.streamer.chunks
      cursor.curmethod.methodtracedefer=0    -- now OK to release tracing
      iterate mainloop
      end

    /* Any needed-constructor has been handled -- no need to defer tracing */
    cursor.curmethod.methodtracedefer=0

    /* Assignments are any term followed by an '=' */
    if tn=RxToken.OP then if tokn.value[0]='=' then do
      reachcheck()                      -- ensure reachable
      assign=NrAssign(rxt)              -- construct assignment
      cursor.curclause.lookaside=assign -- save
      assign.process(term, n)           -- handle LHS and parse RHS
      -- [scan is not used, due to special processing]
      if rxt.program.flag.java then assign.generate()        -- generate code
      -- [Assign handles any errors and exceptions]
      iterate mainloop
      end

    /* [delta expressions not yet implemented/on hold] */

    /* Multi-token term can only be followed by '=' (or RxToken.END, if a
       method), which would have been handled by now; hence error if not
       a single-token term. */
    if n>1 then do
      if term.group=S_PROP | term.group=S_FINAL then
        signal RxError(rxt, tokn, 'no.equals.after.property')
      signal RxError(rxt, tokn, 'no.equals.after.term')
      end

    /* expecting a keyword instruction */
    if t\=RxToken.SYM then
      signal RxError(rxt, tok, 'keyword.expected')
    if t2\=RxToken.SP then
     if t2\=RxToken.END then
     if t2\=RxToken.STR then
     if t2\=RxToken.OP  then
      signal RxQuit(rxt, tok2, 'not.allowed.after.keyword')

    item=RxClauseParser                 -- built item
    do label constructkeyword

      /* Block-enders need not be reachable */
      /* [these also handle their own tracing] */
      if iskey(tok.value,'END')     then do
        item=NrEnd(rxt)
        leave constructkeyword; end
      if iskey(tok.value,'CATCH')   then do
        item=NrCatch(rxt)
        leave constructkeyword; end
      if iskey(tok.value,'FINALLY') then do
        item=NrFinally(rxt)
        leave constructkeyword; end

      reachcheck()                        -- ensure is reachable

      select
        /* The next group handle their own tracing for various reasons */
        when iskey(tok.value,'ELSE')       then item=NrElse(rxt)
        when iskey(tok.value,'WHEN')       then item=NrWhen(rxt)
        when iskey(tok.value,'DO')         then item=NrDo(rxt)
        when iskey(tok.value,'LOOP')       then item=NrLoop(rxt)
        when iskey(tok.value,'SELECT')     then item=NrSelect(rxt)
        when iskey(tok.value,'OTHERWISE')  then item=NrOtherwise(rxt)
        when iskey(tok.value,'PARSE')      then item=NrParse(rxt)

        /* The next group can be traced more simply, here */
        when iskey(tok.value,'IF')         then do
          tracer.traceclause(cursor.curclause)
          item=NrIf(rxt); end
        when iskey(tok.value,'THEN')       then do
          tracer.traceclause(cursor.curclause)
          item=NrThen(rxt); end
        when iskey(tok.value,'LEAVE')      then do
          tracer.traceclause(cursor.curclause)
          item=NrLeave(rxt); end
        when iskey(tok.value,'ITERATE')    then do
          tracer.traceclause(cursor.curclause)
          item=NrIterate(rxt); end
        when iskey(tok.value,'SAY')        then do
          tracer.traceclause(cursor.curclause)
          item=NrSay(rxt); end
        when iskey(tok.value,'EXIT')       then do
          tracer.traceclause(cursor.curclause)
          item=NrExit(rxt); end
        when iskey(tok.value,'NOP')        then do
          tracer.traceclause(cursor.curclause)
          item=NrNop(rxt); end
        when iskey(tok.value,'RETURN')     then do
          tracer.traceclause(cursor.curclause)
          item=NrReturn(rxt); end
        when iskey(tok.value,'SIGNAL')     then do
          tracer.traceclause(cursor.curclause)
          item=NrSignal(rxt); end
        when iskey(tok.value,'NUMERIC')    then do
          tracer.traceclause(cursor.curclause)
          item=NrNumeric(rxt); end
        when iskey(tok.value,'TRACE')      then do
          tracer.traceclause(cursor.curclause)
          item=cursor.curclause.lookaside          -- it was constructed in pass1
          end

        /* The remainder are constructed for better error messages */
        when iskey(tok.value,'PROPERTIES') then NrProperties(rxt)
        when iskey(tok.value,'OPTIONS')    then NrOptions(rxt)
        when iskey(tok.value,'PACKAGE')    then NrPackage(rxt)
        when iskey(tok.value,'IMPORT')     then NrImport(rxt)
        otherwise
          /* Improved error message -- symbol unrecognised */
          var=rxt.program.pooler.findvar(cursor, tok.value, tok, 0, 0, 0)
          select
            when var=null                                then key='keyword.expected'
            when (var.varatts & RxVariable.VAR_ARG)\=0   then key='bad.argument.use'
            when (var.varatts & RxVariable.VAR_LOCAL)\=0 then key='bad.variable.use'
            otherwise                                         key='bad.property.use'
            end
          signal RxQuit(rxt, tok, key)
        end /* select certains */
      end constructkeyword

    /* Clause was constructed (parsed) OK.  Now action it. */

    if item<=RxClauseParser then do
      cursor.curclause.lookaside=item
      item.scan(rxt.pass)
      if rxt.program.flag.java then item.generate()
      end

    catch RxError
      -- simply move to next clause if a recoverable error seen
      if rxt.program.flag.diag then say '# RxError caught in methodbody'
    end errorhandle
    end mainloop
  /* UnR */

 /* DEFERREDCLASS -- handle any pending TRACE or NUMERIC instructions */
 method deferredClass private
  -- These have been deferred from the prologue so they can be scanned
  -- and generate code in the right place.  Note that they can reappear
  -- for the default class, as well as explicit ones.
  -- They are ignored inside interface classes.
  if rxt.program.pendtrace.size()=0 then
   if rxt.program.pendnumeric.size()=0 then return       -- nowt pending
  if cursor.curclass.classinfo.isinterface then return -- not allowed

  indention=1                              -- for formatting
  saveclause=cursor.curclause
  loop t=0 for rxt.program.pendtrace.size()
    cursor.curclause=RxClause rxt.program.pendtrace.elementAt(t)
    trace=NrTrace cursor.curclause.lookaside
    trace.scan(rxt.pass)
    -- Trace level is needed in pass 1 for entry level for methods
    if rxt.pass1 then if cursor.curclass.tracelevel<trace.level then
      cursor.curclass.tracelevel=trace.level
    if rxt.pass2 then if rxt.program.flag.java then trace.generate()
   catch e=RxError
    -- if we get an error then throw away pending traces so not reprocessed
    rxt.program.pendtrace.removeAllElements()
    signal e   -- rethrow
    end t
  loop n=0 for rxt.program.pendnumeric.size()
    cursor.curclause=RxClause rxt.program.pendnumeric.elementAt(n)
    numer=NrNumeric cursor.curclause.lookaside
    numer.scan(rxt.pass)
    if rxt.pass2 then if rxt.program.flag.java then numer.generate()
   catch e=RxError
    -- if we get an error then throw away pending numerics so not reprocessed
    rxt.program.pendnumeric.removeAllElements()
    signal e   -- rethrow
    end n
  cursor.curclause=saveclause
  return

 /* CROSSCLASS -- parse cross-class references                        */
 -- this processes classes (superclass, etc.) referenced in the CLASS
 -- instructions.  It is done after all Pass 0/1s have been completed,
 -- so we may make forward references to later classes or programs.
 method crossclass
  loop i=0 for rxt.program.classes.size()
    cursor.curclass=RxClass rxt.program.classes.elementAt(i)
    if rxt.pass0 then cursor.curclass.scan05()  -- pass 0.5 processing for the class
    if rxt.pass1 then cursor.curclass.scan15()  -- pass 1.5 processing for the class
    end i
  cursor.curclass=null

 /* PUSHLEVEL -- add a new level.
    Arg1 is the keyword for the new level
    thislevel and level are updated
    */
 method pushlevel(key=Rexx)
  if thislevel=null then level=0        -- set depth
                    else level=level+1
  newlevel=NrLevel(key, cursor.curclause) -- initialise new level
  newlevel.prev=thislevel               -- chain it in to stack
  thislevel=newlevel                    -- and make it the new level

 /* SCRAPLEVEL -- drop a level, without checking
    thislevel and level are updated
    This simply undoes a PUSHLEVEL for a retry (DO -> LOOP)
    */
 method scraplevel
  level=level-1                         -- pop !
  thislevel=thislevel.prev              -- discard old level object
  if \rxt.pass2 then return
  /* advise formatter of new level */
  if rxt.program.flag.format then rxt.program.streamer.postindent(level)

 /* POPLEVEL -- drop a level.
    thislevel and level are updated
    pending exceptions are 'inherited' by the block above
    */
 method poplevel
  oldlevel=thislevel                    -- save old NrLevel
  level=level-1                         -- pop !
  thislevel=thislevel.prev              -- discard old level object

  /* Level checking, exceptions, and formatting code only relevant in pass2 */
  if \rxt.pass2 then return

  indention=level                       -- for formatter

  /* advise formatter of new level */
  if rxt.program.flag.format then rxt.program.streamer.postindent(level)

  /* If no dropout from previous level possible, indicate terminal at
      new level */
  if \oldlevel.dropout then do
    -- if rxt.program.flag.diag then if level>1 then say "#" level "block didn't dropout"
    thislevel.terminal=1
    end

  /* Now add unique (new) exceptions to the block at the new level */
  if oldlevel.signals=null then return  -- no inherited signals

  if thislevel.signals=null then do     -- all must be unique
    thislevel.signals=oldlevel.signals  -- easy .. copy the lot
    return
    end

  /* Already some, so comparisons needed */
  num=oldlevel.signals.size()             -- number of exceptions
  list=RxException[num]                 -- array from the exceptions
  oldlevel.signals.copyInto(list)       -- ..
  loop i=0 for num
    -- if it is already in list, don't need to add
    found=list[i].find(thislevel.signals)
    if found=null then                  -- it's new to new level
      thislevel.signals.addElement(list[i])
    end i
  return

 /* Add exceptions to level(s)
    Arg1 is 1 to add to signals list, 0 to add to catch list
    Arg2 is list of one or more fully-qualified Exception names,
            separated by commas [this may be null, if none]
    Arg3 is the reference point for exception
    Arg4 is 1 to force add to level above
    Exceptions are added, as RxException objects, to either
      the current level or (if within a Catch/Finally block, or Arg4)
      to the level above.
   */
 method addexceptions(signals=boolean, them=Rexx,-
                      tok=RxToken, forceup=boolean 0)
  if them=null then return              -- saves caller tests
  if rxt.program.flag.diag then say '#' level 'add exceptions:' them
  loop while them\==''
    parse them name ',' them
    if name=='' then iterate            -- we allowed empties in 1.0
    einfo=rxt.classer.findclass(cursor, name, tok, 1)
    if einfo=null then return           -- later make internal error
    excep=RxException(cursor, einfo, tok)    -- construct
    /* Decide on the level and list to add it to */
    if forceup then where=thislevel.prev     -- level above
     else if \signals then where=thislevel   -- CATCH always here
     else if thislevel.trystate=NrLevel.TRY_INIT then where=thislevel
     else where=thislevel.prev               -- level above
    if signals then v=where.signals
               else v=where.caught
    /* Initialize if needed */
    if v=null then do
      v=Vector(8)
      if signals then where.signals=v
                 else where.caught=v
      end
    /* Add unless already there */
    if excep.find(v)=null then v.addElement(excep)
    end
  return

 /* REACHCHECK -- check clause is reachable */
 method reachcheck
  /* Assure that (at current/new level) the clause can be reached */
  if thislevel.terminal then do
    thislevel.terminal=0         -- one error (here) only please
    RxError(rxt, cursor.curclause.tokens[0], 'clause.unreachable')
    end
  return

 /* STATECHECK -- handle control structure state machines
    Arg1 is the next 'real' clause.  It may be null if it is not a
            method body clause (i.e., METHOD or CLASS).
            [Arg1 is used as the 'next' clause for ENDIF]

    Ancient code, this .. not rigorous ['OTHERWISE=' accepted, for
    example .. but missed errors extremely rare and will be caught at
    end of construct] */
 method statecheck(nextclause=RxClause) private
  tok=cursor.curclause.tokens[0]
  if tok.type=RxToken.SYM then kw=Rexx tok.value
                          else kw='?'
  loop label ifnest
    if thislevel.key=='IF' then select
      when thislevel.ifstate=NrLevel.IF_THENEXP then do
        if \iskey(kw, 'THEN') then signal RxQuit(rxt, tok, 'if.expects.then')
        end
      when thislevel.ifstate=NrLevel.IF_THEN then do
        /* ELSE may not follow immediately */
        if iskey(kw, 'ELSE') then signal RxQuit(rxt, tok, 'unexpected.else')
        thislevel.ifstate=NrLevel.IF_ELSEOK
        end
      when thislevel.ifstate=NrLevel.IF_ELSEOK then do
        /* just left THEN-instruction/block */
        if \thislevel.terminal then thislevel.dropout=1
        thislevel.lastterm=thislevel.terminal
        thislevel.terminal=0       -- ELSE or following is reachable
        if iskey(kw, 'ELSE')
         then nop                  -- NrElse will make code
         else do                   -- ending the if
          thislevel.dropout=1      -- can always take (missing) ELSE path
          startif=NrIf thislevel.clause.lookaside
          startif.endif(nextclause)-- complete the IF
          iterate; end             -- maybe more
        end
      when thislevel.ifstate=NrLevel.IF_ELSE then
        thislevel.ifstate=NrLevel.IF_DONE
      when thislevel.ifstate=NrLevel.IF_DONE then do
        /* just left ELSE-instruction/block */
        if \thislevel.terminal then thislevel.dropout=1
        thislevel.lastterm=thislevel.terminal
        thislevel.terminal=0       -- [redundant, but be symmetrical]
        startif=NrIf thislevel.clause.lookaside
        startif.endif(nextclause)  -- complete the IF
        iterate; end               -- maybe more
      end
    leave ifnest
    end ifnest

  if thislevel.key=='SELECT' then do
    select
      when thislevel.selstate=NrLevel.SEL_WHENEXP then
       if \iskey(kw, 'WHEN') then signal RxQuit(rxt, tok, 'select.expects.when')
      when thislevel.selstate=NrLevel.SEL_THENEXP then
       if \iskey(kw, 'THEN') then signal RxQuit(rxt, tok, 'when.expects.then')
      when thislevel.selstate=NrLevel.SEL_THEN then do
        if iskey(kw, 'WHEN') then signal RxQuit(rxt, tok, 'unexpected.when')
        if iskey(kw, 'OTHERWISE') then signal RxQuit(rxt, tok, 'unexpected.otherwise')
        if iskey(kw, 'CATCH') then signal RxQuit(rxt, tok, 'unexpected.catch')
        if iskey(kw, 'FINALLY') then signal RxQuit(rxt, tok, 'unexpected.finally')
        if iskey(kw, 'END') then signal RxQuit(rxt, tok, 'unexpected.end')
        thislevel.selstate=NrLevel.SEL_ALLOK
        end
      when thislevel.selstate=NrLevel.SEL_ALLOK then do
        /* just had WHEN-THEN-instruction/block */
        if \thislevel.terminal then thislevel.dropout=1
        thislevel.lastterm=thislevel.terminal
        thislevel.terminal=0       -- WHEN or following is reachable
        if  \iskey(kw, 'WHEN') then
         if \iskey(kw, 'OTHERWISE') then
         if \iskey(kw, 'CATCH') then
         if \iskey(kw, 'FINALLY') then
         if \iskey(kw, 'END') then
          signal RxQuit(rxt, tok, 'select.when.otherwise.expected')
        end
      otherwise nop  -- OTHERWISE block .. just like a DO group
      end
    return; end
  return

 /* ENDBLOCK -- complete the ending of any of:
     o Main block (body) of a construct
     o Catch block
     o Finally block
  */
 method endblock
  if thislevel.trystate=NrLevel.TRY_FINAL then do      -- in FINALLY block
    if rxt.program.flag.diag then say '# try_final' thislevel.key 'drop, term:'-
                       thislevel.dropout thislevel.terminal
    if thislevel.terminal then thislevel.dropout=0     -- FINALLY overrides
    return
    end

  /* If final clause non-terminal then block drops out (unless LOOP or
     SELECT and not seen Otherwise block)
     [SELECT is a non-ender unless an OTHERWISE seen] */
  if \thislevel.terminal then select                   -- still going
    when thislevel.trystate=NrLevel.TRY_CATCH then thislevel.dropout=1
    -- otherwise still in body
    when thislevel.key=='LOOP' then nop
    when thislevel.key=='SELECT'-
       & thislevel.selstate\=NrLevel.SEL_OTHER then nop
    otherwise thislevel.dropout=1
    end
  if thislevel.trystate\=NrLevel.TRY_INIT then return  -- not in main body
  /* we are ending main body of construct */

  /* generate any code for the end of the main (initial) block */
  select
    /* end of true structure body */
    when thislevel.key=='DO' then do
      startdo=NrDo thislevel.clause.lookaside
      startdo.endinitial()
      end
    when thislevel.key=='SELECT' then do
      startsel=NrSelect thislevel.clause.lookaside
      startsel.endinitial()
      end
    when thislevel.key=='LOOP' then do
      startloop=NrLoop thislevel.clause.lookaside
      startloop.endinitial()
      end
    end

  thislevel.lastterm=thislevel.terminal
  thislevel.terminal=0 -- catch, finally, and their contents are reachable
  return

 /* CHECKNEST -- check constructs are properly closed
    This is called at end of methods (by end of method, class, or
    stream).  After it, level will be 2. */
 method checknest
  /* First close pending valid IFs */
  loop while thislevel.key=='IF'-
          & (thislevel.ifstate=NrLevel.IF_ELSEOK-
           | thislevel.ifstate=NrLevel.IF_DONE)
    if thislevel.ifstate=NrLevel.IF_ELSEOK
     then thislevel.dropout=1      -- can always take (missing) ELSE path
     else if \thislevel.terminal then thislevel.dropout=1
    startif=NrIf thislevel.clause.lookaside
    startif.endif(null)            -- complete the IF
    end
  if level<=2 then return
  errorkey=thislevel.key           -- error keyword
  errortok=thislevel.keytoken      -- where the error will be shown
  /* Report the error.  Don't SIGNAL it, as we may be on new METHOD
     or CLASS instruction */
  select
    when errorkey=='DO'     then RxError(rxt, errortok, 'do.missing.end')
    when errorkey=='LOOP'   then RxError(rxt, errortok, 'loop.missing.end')
    when errorkey=='SELECT' then RxError(rxt, errortok, 'select.missing.end')
    when errorkey=='IF'     then RxError(rxt, errortok, 'incomplete.if')
    otherwise
      signal RxQuit(rxt, errortok, 'internal.error',-
                    'RxParser checknest' errorkey level)
    end
  /* Drop the bad (extra) levels, for next method/class */
  loop while level>2; poplevel(); end
  return

 /* CHECKDUPLABEL -- check label isn't already active; error if so
    Arg1 is label to check for
    Arg2 is place for error message
    */
 method checkduplabel(lab=Rexx, tok=RxToken)
  control=thislevel.prev
  loop label lev for level-3
    if control.blocklabel.OpEq(null,lab) then RxError(rxt, tok, 'label.already.in.use')
    control=control.prev
    end lev

 /* CHECKDUPCONVAR -- check control variable isn't already in use; error if so
    Arg1 is label to check for
    Arg2 is place for error message
    */
 method checkdupconvar(varname=Rexx, tok=RxToken)
  control=thislevel.prev
  loop label lev for level-3
    if control.loopvarname.OpEq(null,varname) then
      RxError(rxt, tok, 'control.variable.already.in.use')
    control=control.prev
    end lev

 /* PACKSTRING -- pack a string to characters
    Arg1 is the string to pack
    Arg2 is whereabouts for error
    returns packed string
    -- used by NrParse
    */
 method packstring(in=char[], tok=RxToken) returns char[]
  out=char[in.length]         -- where build result
  count=0                     -- length of output string
  escape=char ' '             -- for calculations
  loop i=0 to in.length-1
    if in[i]\='\\' then /* ordinary character */ do
      out[count]=in[i]
      count=count+1
      iterate i
      end
    /* we have an escape sequence */
    i=i+1
    if i=in.length then signal RxError(rxt, tok, 'invalid.escape.position')
    echar=in[i]
    uchar=Character.toUpperCase(echar)
    select
      when uchar='T'  then escape='\x09'
      when uchar='N'  then escape='\x0a'
      when uchar='F'  then escape='\x0c'
      when uchar='R'  then escape='\x0d'
      when uchar='"'  then escape='\x22'
      when uchar="'"  then escape='\x27'
      when uchar='\\' then escape='\x5c'
      when uchar='0'  then escape='\x00'
      when uchar='X'  then do
        if i+2>=in.length then
          signal RxError(rxt, tok, 'hexadecimal.escape.too.short')
        escape=char(hexcheck(in[i+1], tok)*16 + hexcheck(in[i+2], tok))
        i=i+2
        end
      when uchar='U' then do
        if i+4>=in.length then
          signal RxError(rxt, tok, 'unicode.escape.too.short')
        escape=char(hexcheck(in[i+1], tok)*4096-
                  + hexcheck(in[i+2], tok)*256-
                  + hexcheck(in[i+3], tok)*16-
                  + hexcheck(in[i+4], tok))
        i=i+4
        end
      otherwise
        signal RxError(rxt, tok, 'invalid.escape.character', echar)
      end /* select */
    out[count]=escape
    count=count+1
    end i /* loop */
  if count=out.length then /* no escapes */ return out
  newout=char[count]
  System.arraycopy(out, 0, newout, 0, count)
  return newout

 /* HEXCHECK -- check and convert a hexadecimal character
    Arg1 is the char to check
    Arg2 is whereabouts for error
    returns int (0-15) if OK, else raises error
    */
 method hexcheck(h=char, tok=RxToken) returns int
  if h>='0' then if h<='9' then return int(h)-int('0')
  if h>='a' then if h<='f' then return int(h)-int('a')+10
  if h>='A' then if h<='F' then return int(h)-int('A')+10
  signal RxError(rxt, tok, 'invalid.hexadecimal.in.escape', h)

 /* ISKEY -- test for a keyword
   Arg1 is array of characters to check
   Arg2 is keyword to check -- must be in Uppercase
   Returns 1 if both args match (caseless) and word is not a variable
   */
 method iskey(al=char[], kr=String) returns boolean
  if al.length\=kr.length() then return 0
  ar=kr.toCharArray()
  loop i=0 to al.length-1
    cl=al[i]; cr=ar[i]
    if cl=cr then iterate
    cl=Character.toUpperCase(cl)
    if cl\=cr then return 0
    end
  /* The two words match (caseless) */
  if cursor.curclass=null then return 1           -- no variables possible yet
  if rxt.program.pooler.findvar(cursor, al, null, 0, 0, 0)=null then
    return 1 -- unknown
  return 0                                        -- is a variable

 /* CLAUSES: Return the number of known clauses
    After the first pass, this is the total in program. */
 method clauses returns int
  return clauser.clauses()      -- ask clauser for the magic number
