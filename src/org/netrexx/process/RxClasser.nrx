/* IBM Materials Licensed under International Components for Unicode  */
/* Licence version 1.8.1 (ICU Licence) - Property of IBM              */
/* IBM NetRexx                                                        */
/* Copyright (c) 1995-2009 IBM Corp.                                  */
/* Copyright (c) 2011- RexxLA                                         */
/* ------------------------------------------------------------------ */
/* Venta language processor                                       mfc */
/* Copyright (c) IBM Corporation 1996, 2004.  All Rights Reserved.    */
/* ------------------------------------------------------------------ */
/* RxClasser                                                          */
/*                                                                    */
/*   This is the generalized class processor.  The classer object     */
/*   handles everything to do with classes: finding them, testing     */
/*   for them, and so on.                                             */
/*                                                                    */
/*   This is gradually being rewritten to use the RxClassInfo object  */
/*   to represent the information known about a class.                */
/* ------------------------------------------------------------------ */
/* 1996.05.24 Initial                                                 */
/* 1996.08.21 Case-insensitive Type lookup                            */
/* 1996.08.23 Case-insensitive field lookup                           */
/* 1996.08.24 Statics-only findfield, for CLASS ... USES              */
/* 1996.08.28 Rework to use ClassImage instead of PublicAgent         */
/* 1996.09.01 Register and check ShortRefs                            */
/* 1996.09.09 Modify to work with local ZipFile access                */
/* 1996.10.25 Importclasses of current directory doesn't drill down   */
/* 1996.11.09 Include primitives as registered classes.               */
/* 1996.11.26 Visibility checking reworked for 'first peek' only      */
/* 1996.12.10 Limited imports of java/ tree, for JDK 1.1              */
/* 1997.03.29 Use ClassPool for registering/finding classes           */
/* 1997.04.06 Use RxFields for registerfield (etc.)                   */
/* 1997.04.13 Add javakey                                             */
/* 1997.04.17 Bulk loading of standard imports                        */
/* 1997.04.28 Separate imports by program, for multiple compilation   */
/* 1997.06.14 Importclasses won't import a standard package           */
/* 1997.06.21 Allow for 'shared' (default) field visibility           */
/* 1997.06.27 Use java.util.zip for access to Zip and Jar files       */
/* 1997.11.23 Strictcase no longer affects field registration key     */
/* 1998.01.31 Importclasses still did not handle subpackages in zips  */
/* 1998.02.08 Recognise externally-visible inner classes, by name     */
/* 1998.04.02 Enhanced search order for parent classes                */
/* 1998.05.06 Use RxFields from RxClassImage; remove string Fields    */
/* 1998.05.19 Revise imports again; add package/segment lookaside     */
/* 1998.09.30 Inhibit automatic imports if strictimport set           */
/* 1998.11.17 Explicit import disambiguates short references          */
/* 1998.12.12 Explicit imports recorded (for Java code)               */
/* 1999.11.15 Add 1.2 java extensions to classpath [MS Blg41]         */
/* 2000.02.21 Registerfield accepts local RxClass for properties      */
/* 2000.03.14 Give all local classes and fields unique integer IDs    */
/* 2000.04.07 Preserve the binary data from classImage, if -exec      */
/* 2000.10.16 Import '' finds classes in all CLASSPATH, not just '.'  */
/* 2001.03.31 Imported classes should be recoverable                  */
/* 2004.07.04 Import all jre\lib classes for IBM JVM 1.4.1            */
/* 2004.12.18 Protect against 1.4 loop on looping EXTENDS             */
/* 2008.02.25 Add standard location for classes.jar on MacOSX         */
/* 2011.10.03 Add compare costs of superclass methods to subclass     */
/* in searchfield method - KK  (issue 55)                             */
/* 2011.10.04 modify unimplemented method to check return signatures  */
/* for superclass/interface match - KK  (issue 17)                    */
/* 2011.10.07 add 1 to interface costs if not zero - allows converted */
/* access to implemented methods - KK  (issue 11)                     */
/* 2012.04.06 fix interface search  - KK  (issue NETREXX-76)          */
/* 2012.09.16 change constructor to allow auto (standard) import of a */
/* single package as well as a tree branch;  add java.lang to         */
/* strictimports to match javac  --KK  (issue NETREXX-61)             */
/* 2012.09.16 add assert and strictfp to javakeytable  --KK           */
/* (issue NETREXX-64)                                                 */
/* 2012.10.16 missing null check in unimplemented method causing null */
/* ptr errors  --KK  (no issue opened - non released code)            */
/* deleted standard classpath additions for MacOSX and z/OS -         */
/* cannot depend on these anymore --rvj                               */
/* 2015.05.24 -- KK -- fix for issue #115 =                           */
/* can't subclass ConcurrentHashMap in Java 8                         */
/*  2015.06.03 -- KK -- fix for issue #125 = chg from                 */
/* jre/lib+jre/lib/ext scan to sun.boot.class.path+java.ext.dirs scan */
/* 2020.12.19 -- MRE -- added support for JPMS on Java 9+             */
/* 2022.01.28 -- MRE -- added support for --[upgrade-]module-path     */
/* ------------------------------------------------------------------ */
-- may still have minor NetRexxisms (search order, etc.)

package org.netrexx.process
options binary nodecimal strictcase strictargs

import java.nio.file.Path
import java.nio.file.Paths
import java.nio.file.Files
import java.nio.file.FileSystem
import java.nio.file.FileSystems
import java.nio.file.OpenOption
import java.nio.file.LinkOption
import java.nio.file.StandardOpenOption

/**   This is the generalized class processor.  The classer object    */
/*   handles everything to do with classes: finding them, testing     */
/*   for them, and so on.                                             */
/*                                                                    */
class RxClasser

 --properties shared
  --copyright=RxProcessor.copyright

 properties private
  rxt=RxTranslator            -- our boss
  psep        =char           -- system  path separator
  fsep        =char           -- system  file (directory) separator
  zsep        =char '/'       -- zipfile file separator
  dot         =char '.'       -- extension or segment separator
  standpacks  =String[]       -- standard packages (imports)
  standpacksscope  =boolean[] -- standard packages (imports) flags to include subpackages - issue #61  -KK-20120916

  /* local dictionaries and lists */
  classpool   =RxClassPool    -- pool of known classes
  javakeytable=Hashtable      -- keyword lookup table
  packagetable=Hashtable      -- package lookup table
  -- the next two are used to give fields and classes a unique ID
  -- for rapid lookup from an int [for proxy use].  Localclasses is also
  -- used as a list of classes which can be recovered.
  localclasses=Vector         -- list of *all* local classes [RxClassInfo]
  localfields =Vector         -- list of *all* local fields [RxField]

  -- we also record recoverable imported classes
  importclasses=Vector        -- list of *all* imported classes [RxClassInfo]

  classpaths  =0              -- count of classpath segments
  classpathseg=Vector         -- Rexx string describing each segment
                              --  [no trailing ';', ':', '/' or '\']
  classpathzip=Vector         -- Zipfile object if segment is a zip file
                              --  [null otherwise]
  classpathpax=Vector         -- Lookaside for packages in each segment
                              --  [Hashtables, keyed by package name]
  classdefines=Vector         -- Lookasides during interpret [RxClassInfo]

  searchinginterfaces =boolean 0                --      flag is 1 while searching interfaces - KK

--MRE for Java 9 2020.12.13

   isJrt               =boolean 0                -- flag is 1 when running above java 1.1.8 
   jrtprefix           ='jrt:'                   -- (we'll add fsep later) could be jrt:/modules/$module or jrt:/$module CSR JDK-8227076
   modpacktable        =Hashtable                -- hashtable mapping package to module
   

 /** Constructor
    Arg1 is the translator object
    Arg2 is an array of standard import name-Strings
    */
 method RxClasser(newrxt=RxTranslator, standardimports=String[])
  rxt=newrxt
  fsep=System.getProperty('file.separator')  -- e.g., / or \
  psep=System.getProperty('path.separator')  -- e.g., : or ;

  classpathseg=Vector(50)          -- list of segment name strings
  classpathzip=Vector(50)          -- list of ZipFiles
  classpathpax=Vector(50)          -- list of packages in segment
  classdefines=Vector(5)           -- lookasides

  localclasses=Vector(10)          -- list of local classes
  localfields =Vector(30)          -- list of local fields
  importclasses=Vector(50)         -- list of imported classes

  packagetable=Hashtable(300)      -- all known packages

  classpool=RxClassPool(rxt)       -- make a classpool

/*  if \rxt.program.flag.strictimport then standpacks=standardimports
                                    else standpacks=String[0]                   */

/*  Check each standard import to see if subpackages were requested - part of mod for issue #61  --KK-20120916  */
   if \rxt.program.flag.strictimport then
     do
       standpacks=String[standardimports.length]
       standpacksscope=boolean[standardimports.length]
       loop i=0 for standardimports.length
         if Rexx(standardimports[i]).right(1)=='.' then
           do
             standpacks[i]=standardimports[i].substring(0,standardimports[i].length()-1)
             standpacksscope[i]=1
           end
         else
           do
             standpacks[i]=standardimports[i]
             standpacksscope[i]=0
           end
       end
     end

   else
     do         --              strictimport case
       standpacks=[String 'java.lang']                          --              Java always includes java.lang import   --  part of mod for issue #61  --KK-20120916  */
       standpacksscope=[boolean 0]                                      --              no subpackages
     end
  

   -- check for Java 9+
   
   modpacktable=Hashtable(300)      -- stores owning module per package

   jrtprefix=jrtprefix||zsep
   
   o=Object.class.getResource('Object.class')   -- check for 1.1.8+ 
   os=o.toString()
   if os.startsWith(jrtprefix) then do 
     isJrt = 1
     c=jrtprefix||os.substring(jrtprefix.length())
     p = Paths.get(URI.create(c))

     if \Files.isReadable(p) then do
       jrtprefix=jrtprefix||'modules'||zsep               -- CSR JDK-8227076, fix for GraalVM/OpenJDK 11
     end                                                  -- we assume it's readable, or RxQuit
     if rxt.superflag.diag then do
       say '# Running JDK9+ with jrt prefix' jrtprefix
     end  
     if rxt.superflag.diag then do
        say '# PACKMODFIND: start loop start'
        start=System.currentTimeMillis()
     end
     packmodfind('')                                      -- discover all packages in all modules
     if rxt.superflag.diag then do
       say '# PACKMODFIND loop end after' System.currentTimeMillis()-start'ms'
       say '# PACKMODFIND 'modpacktable.size()' directories found on jrt:/'
     end  
   end

 -- initialize and import standard classes
  
   initclasspath()                  -- get and parse classpath, loading Zips
   

   importclasses('*', 1, null, 1)   -- standard imports, with global access
                                    -- [note current directory only imported, later, if no PACKAGE]

   -- Register primitive types
   loop i=1 to RxType.PRIMITIVES.words()
     classpool.register('', RxType.PRIMITIVES.word(i), null, null, 1, null, 0)
   end i
   
   if rxt.superflag.diag then do
     classpool.stats()                          -- statistics please
     say '#' packagetable.size() 'packages'     -- ..
   end
   return

  /** INITCLASSPATH -- set and parse/check class path.
     Directory segments are just checked for reality at this point.
     Zip files have a Zipfile object created and cached -- this does the
     hard (slow) work of reading and parsing the Zipfile.
   */
  method initclasspath
    path=System.getProperty('java.class.path')
    /* Java 1.2 betas forget to add the home classes.zip/.jar, so we add
       them.  Later checks will filter them out if duplicates or unreal.
       Later 1.2 beta changes the name to rt.jar, and moves tools to a
       new jar at a higher level.
       Final 1.2 also adds extensions mechanism .. and .jar files in
       \lib\ext are automatically added to the classpath.

       In Java 1.4, some JVMs split and renamed rt.jar, so now we
       simply check all .jars in jre\lib
     */

    home=System.getProperty('java.home')

    lib=home||fsep'lib'fsep
    -- ancient1 name was classes.zip
    path=path||psep||lib'classes.zip'
    -- path=path||psep||home||fsep'..'fsep'lib'fsep'tools.jar'  -- 1.2b3K

    --   path=path||psep||lib'classes.zip'                              --              duplicate?      -- 2015.06.03 -- KK -- fix for issue #125 = chg from jre/lib+jre/lib/ext scan to sun.boot.class.path+java.ext.dirs scan
    -- add standard location for MacOSX so it does not need to be put on classpath anymore
    -- path=path||psep||'/System/Library/Frameworks/JavaVM.framework/Classes/classes.jar'
    --    -- add standard location for java6 on zLinux so it does not need to be put on classpath anymore
    -- path=path||psep||'/opt/ibm/java-s390x-60/lib/tools.jar:/opt/ibm/java-s390x-60/jre/lib/s390x/default/jclSC160/vm.jar'

    -- all jars in lib..
    /*-- 2015.06.03 -- KK -- fix for issue #125 = chg from jre/lib+jre/lib/ext scan to sun.boot.class.path+java.ext.dirs scan
       libpath=lib
       dir=File(libpath)                         -- check the path
       if dir.isDirectory() then do label libdir   -- directory exists
       entries=dir.list()                        -- could be null <sigh>
       if entries\=null then loop i=0 for entries.length
       name=entries[i]
       if \name.endsWith('.jar') then iterate i  -- not a jar file
       path=path||psep||libpath||name
       if rxt.superflag.diag then say '# lib:' name
       end i
       end libdir
     */-- 2015.06.03 -- KK -- fix for issue #125 = chg from jre/lib+jre/lib/ext scan to sun.boot.class.path+java.ext.dirs scan
    path=path||psep||System.getProperty("sun.boot.class.path", "")              -- 2015.06.03 -- KK -- fix for issue #125 = chg from jre/lib+jre/lib/ext scan to sun.boot.class.path+java.ext.dirs scan
    path=Rexx(path).strip('t',psep).toString()                                                                                  -- 2015.06.03 -- KK -- fix for issue #125 = chg from jre/lib+jre/lib/ext scan to sun.boot.class.path+java.ext.dirs scan

    -- 2015.06.03 -- KK -- fix for issue #125 = chg from jre/lib+jre/lib/ext scan to sun.boot.class.path+java.ext.dirs scan :
    extensions=System.getProperty("java.ext.dirs") -- RVJ check for the null that Java 9 delivers
    if extensions <> null then
      do
        -- 2015.06.03 -- KK -- fix for issue #125 = chg from jre/lib+jre/lib/ext scan to sun.boot.class.path+java.ext.dirs scan
        loop label extscan while extensions\==''                                -- 2015.06.03 -- KK -- fix for issue #125 = chg from jre/lib+jre/lib/ext scan to sun.boot.class.path+java.ext.dirs scan
          parse extensions extpath (psep) extensions            -- 2015.06.03 -- KK -- fix for issue #125 = chg from jre/lib+jre/lib/ext scan to sun.boot.class.path+java.ext.dirs scan
          extpath=extpath||fsep                                                                                 -- 2015.06.03 -- KK -- seems to need the trailing file separator below
                                                                                                                -- now add the extensions
                                                                                                                --   extpath=lib'ext'fsep                                       -- 2015.06.03 -- KK -- fix for issue #125 = chg from jre/lib+jre/lib/ext scan to sun.boot.class.path+java.ext.dirs scan
          dir=File(extpath)                         -- check the path
          if dir.isDirectory() then
            do label extdir   -- directory exists
              entries=dir.list()                        -- could be null <sigh>
              if entries\=null then loop i=0 for entries.length
              name=entries[i]
              if \name.endsWith('.jar') then iterate i  -- not a jar file
              path=path||psep||extpath||name
              if rxt.superflag.diag then say '# ext:' name
            end i
        end extdir
      end extscan               -- 2015.06.03 -- KK -- fix for issue #125 = chg from jre/lib+jre/lib/ext scan to sun.boot.class.path+java.ext.dirs scan
end

--MRE
-- fix for issue #4 JPMS modules are not loaded
-- we check the extra modules in directories given as --module-path and/or --upgrade-module-path
-- we simply add all jar files found in the directories to the classpath, and let normal processing handle them
-- to pass the module directories to NetRexx, set the JDK_JAVA_OPTIONS directory
-- as in 'export JDK_JAVA_OPTIONS=--upgrade-module-path=path1:path2'

mpath=''
module_path = System.getProperty("jdk.module.path")
if module_path \= null then do
  if rxt.superflag.diag then say '# module-path set as 'module_path
  mpath=module_path||psep
end  
upgrade_module_path = System.getProperty("jdk.module.upgrade.path")
if upgrade_module_path \= null then do
  if rxt.superflag.diag then say '# upgrade-module-path set as 'upgrade_module_path
  mpath=mpath||upgrade_module_path
end
loop forever
  parse mpath mp (psep) mpath
  if mp == '' then leave

  dir=File(mp)                                -- check the path
  if dir.isDirectory() then do
    entries=dir.list()                        -- could be null <sigh>
    if entries\=null then do 
      loop i=0 for entries.length
        name=entries[i]
        if \name.endsWith('.jar') then iterate i  -- not a jar file
        path=path||psep||mp||fsep||name
        if rxt.superflag.diag then say '# mod:' mp||fsep||name
      end 
    end
  end
end  


/* now split into segments and test for zipfiles */
classpaths=0
classpath=Rexx ''                              -- build shorter
exist=path
loop label segments while exist\==''
  parse exist seg (psep) exist                 -- get segment
  if seg.right(1)==fsep then                   -- clean trailing separator
    seg=seg.left(seg.length().toint()-1)           -- ..
    seg=seg.strip('b', '"')                      -- clean wrapping quotes
    /* Now simplify any upreaches [needed for current directory check] */
    up=fsep'..'
    loop forever
      parse seg pre (up) fup +3 post
      if fup=='' then leave                      -- no upreach left
      lp=pre.lastpos(fsep).toint()
      if lp=0 then leave                         -- bad format
      seg=pre.left(lp-1)||post                   -- delete up and preceding
    end
    -- if rxt.superflag.diag then say '# seg:' seg

    stream=File(seg)                             -- test it
    if \stream.exists() then iterate               -- ignore bad segments

    /*-- [bad segments used to be an error, but Unixen don't like that]
      -- In some implements we find duplicated segments (very
      -- expensive!) so we filter them out.  Note that we ignore case
      -- here, as real case distinctions won't work cross-platform */

      loop v=0 for classpathseg.size()
        if seg.OpEq(null, Rexx classpathseg.elementAt(v)) then iterate segments
      end v

      -- looks like a real segment
      if seg.right(1)==':' then seg=seg||fsep      -- fix for Win32 Java
      classpaths=classpaths+1
      classpathseg.addElement(seg)                 -- segment name
      classpathpax.addElement(Hashtable())         -- lookaside dictionary
      if classpaths>1 then classpath=classpath||psep
      classpath=classpath||seg                     -- save for compiler
      if rxt.superflag.diag then say '# Classpathseg' seg
      -- if not a directory, assume it's a Zip
      if stream.isDirectory()
        then classpathzip.addElement(null)
      else do label zipexpected
        zfile=java.util.zip.ZipFile(stream)      -- process the Zip file
        classpathzip.addElement(zfile)           -- and add to vector
      catch except=java.util.zip.ZipException
        signal RxQuit(rxt, null, 'bad.zip.file.format', seg, except.getMessage())
      catch ioexcept=IOException
        signal RxQuit(rxt, null, 'cannot.read.zip.file', seg, ioexcept.getMessage())
      end zipexpected
end segments
if classpaths=0 then
  signal RxQuit(rxt, null, 'no.valid.classpath.segments', path)
rxt.classpath=classpath                        -- copy back
/* say classpaths 'classpath segments' */
return

/* this fixes a compile problem with the 2.05 compiler used for bootstrapping,
   the default value for importer is rxt.program, which cannot be resolved
   depending on the position of the RxClasser.nrx file in the compile call.
   Very weird. As the value 'null' is used for this parameter, too, there's
   no other way than to write the default invocation methods manually. */
  method importclasses(import=Rexx) returns Rexx
    return importclasses(import, 1, rxt.program)

  /** IMPORTCLASSES -- Register the classes for an IMPORT statement argument
     Arg1 is a NetRexx-like import name,
     or null string for current directory,
     or '*' for "import all standard packages".
     Arg2 is 1 if the class(es) being imported may be accessed by short name
     Arg3 is the program from which short name access is allowed (null if
     'all', i.e., the default imports, or is an explicit reference)
     Arg4 is 1 if subpackages should be included

     If a name is given, all segments of the classpath are checked for
     matching classes (note: to quit after first would be wrong).

     Registers each class found.
     Returns number of classes found (may be 0, and includes duplicates),
     or -1 if Arg1 names a standard package (in which case no classes
     will have been imported, as the search has already been
     done).
     or -2 for error if explicit class duplicates another explicit
     import (nickable only)

     Note this is called in order to auto-import qualified names, as well
     as by IMPORT itself.
   */
  method importclasses(import=Rexx, nickable=boolean, importer=RxProgram, subpacks=boolean 0) returns Rexx
    if rxt.superflag.diag then do
      say '# Import:' import '['nickable subpacks (importer==null)']'
      start=System.currentTimeMillis()
    end

    known=RxClassInfo null                          -- if a local class, perhaps

    -- unless name is '*' then packages are known
    simport=import.toString()
    simlen=simport.length()
    select
      when import=='*' then do                    -- initial call
        package=String ''
        find=simport
        startup=boolean 1
      end
      when import.right(1)=='.' then do           -- search form
                                                  -- package name given
        package=simport.substring(0, simlen-1)    -- drop dot
                                                  -- if a standard package, return -1 to indicate no re-import done
        loop i=0 for standpacks.length
          if standpacksscope[i] then                    --              if a matching standard import included sub packages this import is redundant (for issue #61) - KK - 20120916
            if standpacks[i]==package then return -1
        end i
        find=String null
        startup=boolean 0
      end
    otherwise                                   -- explicit or '.' import
                                                -- package (and perhaps class) specified, split to package and class
        package=getpackage(simport, 0)
        if package=null then do
          package=''                              -- indicate no package
          if import=='' then find=null            -- 'import default package'
          else find=simport         -- class name
        end
        else do
         if package.length()=simlen then do
            find=null -- just a package
                      -- if a standard package, return -1 to indicate no re-import
                      -- done (unless explicit class, in which case we want the
                      -- explicit bit set)
            loop i=0 for standpacks.length        -- standards please
              if standpacks[i]==package then return -1
             end i
          end
          else do                                -- have name
            find=simport.substring(package.length()+1, simlen)  -- class name
          end
        end

    -- if class given ensure we don't already have an explicit import
    -- for the short name, if we're nickable
      if find\==null then if nickable then do
        known=classpool.find(importer, null, find, 1) -- find it anywhere, exact case
                                                      -- [avoid findanyclass, as that is recursive and will load class]
        if known\=null then if known.explicit then return -2
      end
      startup=boolean 0
    end

    if rxt.superflag.diag then do
      ff=find; if ff=null then ff='[null]'
      say '# ImportFind:' package ':' ff
    end

    -- Note we must do the lookup, etc., even if the class was found
    -- above, so it will be properly re-registered as an explicit reference
    -- 2000.10.16: look in all classpath segments, even for the 'null' package
    found=0
    loop cp=0 for classpaths
      packlook=Hashtable classpathpax.elementAt(cp) -- needed all paths

      if package\=='' then                   -- if a package specified
        if \packlook.containsKey(package)     -- .. and if unknown package
          then iterate cp                      -- .. then don't search segment

      zfile=java.util.zip.ZipFile classpathzip.elementAt(cp)
      if zfile\=null
          then found=found+zipfind(zfile, package, find, nickable,-
                                     importer, subpacks, packlook)
      else /* directory */ do
        seg=Rexx classpathseg.elementAt(cp)
        if \startup then 
          found=found+dirfind(seg, package, find, nickable, importer, subpacks)
        else do label standards             -- is '*', startup call
          packdirfind(seg, packlook)         -- locate packages
          loop i=0 for standpacks.length     -- standards please
            found=found+dirfind(seg, standpacks[i], null, nickable,-
                                importer, standpacksscope[i])               --      mod per issue #61 -KK-20120916
                                                                            --                              importer, subpacks)
          end i      
        end standards
      end 
    end cp
    -- MRE Handle importing from java.lang.module
    if isJrt & ((package \== '' & package.length() \== 1) | import == '*') then do   -- don't look in mod when no package unless startup
      if \startup then do
        -- normalize package and find
        if find \== null then do
          find = find.replace('.', '$')                                             -- find minor nested classes
        end     
        mod=String modpacktable.get(package)
        if mod \== null then do                                   
          found=found+modfind(mod, package, find, nickable, importer, subpacks)
        end  
      end
      else do
        loop i=0 for standpacks.length     -- standards please
          mod=String modpacktable.get(standpacks[i])
 --         say mod
          if mod \== null then do
             found=found+modfind(mod, standpacks[i], null, nickable,-
                                importer, standpacksscope[i])               --      mod per issue #61 -KK-20120916
          end 
        end 
      end 
    end  

  
/* Now, if it's an explicit class and not in a package, then
   add it to the imports list to generate matching Java code.
   This is required, to disambiguate a local class from (say) a
   java.lang class, and to allow access to a local class from a
   package (undocumented 'feature' of javac).

   We also similarly add explicit classes that are in a package, for
   cosmetic reasons only (this means the generated code can use
   short names safely).

   Internal imports are not added to the imports list, as they might
   clash with each other or a local class name.
 */
    if found=1 then
      if nickable then
        if find\=null then do
          -- [don't really need next test here, as find==simport; code
          -- separated for clarity/maintenance only]
        if package=='' then rxt.program.javaimports.put(find, find)
          else rxt.program.javaimports.put(simport, simport)
        end

    if rxt.superflag.diag then say '# Imported' found 'after' System.currentTimeMillis()-start'ms'
    return found

 /** PACKMODFIND -- find packages in a directory
     Arg1 is directory path into jrt: so far

     Walks the jrt: fs tree
     Builds the modpacktable, so packages can be identified in the module tree
     Adds packages found in all modules
     Calls itself recursively to explore the complete directory tree
   */
  method packmodfind(dirpath=String) private
    dpath=dirpath
    
    e=Exception
  do
 --   say 'jrt 'jrtprefix||dpath
    p = Paths.get(URI.create(jrtprefix||dpath))

    if \Files.isDirectory(p, [LinkOption null]) then return

/* Here for a directory search */
    registered=0

    stream = Files.list(p)
    ap = Object[]
    ap = stream.toArray()

    loop i=0 to ap.length-1
      pp=Path ap[i]
      if Files.isDirectory(pp, [LinkOption null]) then do
        s=pp.toString()
        subdir=s.substring(9)                        -- strip /modules/
        packmodfind(subdir)
      end
      else do
        if registered == 0 then do
          regpack=p.toString()
          mod = regpack.substring(9)                  -- strip /modules/
          pos=mod.indexOf(zsep)                       -- first /
          if pos > 0 then do                          
            mod=mod.substring(0, pos)
            regpack=regpack.substring(9+mod.length()+1)
            regpack=regpack.replace(zsep, '.')

            modpacktable.put(regpack, mod)
            addpackage(regpack, null)
            if rxt.superflag.diag then say '# PACKMODFIND registered 'regpack' in 'mod
            registered = 1
          end
        end   
      end
    end
    
  catch e=Exception
    signal RxQuit(rxt, null, 'cannot.read.class',dirpath, e.getMessage())
    end
  return


  /** MODFIND -- find classes in the jrt: file system
     Arg1 is module name
     Arg2 is package path (may be null string, has dots)
     Arg3 is search string: either a classname, or null for 'all classes'
     Arg4 is 1 if the class(es) being imported may be accessed by short name
     Arg5 is the program from which short name access is allowed
     Arg6 is 1 if subpackages (subdirectories) should be included
     returns the number of files found

     Neither path should end in a file separator.
     Registers each class found (of form xxx.xxx.yyy)
   */

method modfind(module=String, package=String, find=String,-
                 nickable=boolean, importer=RxProgram,-
                 subpacks=boolean 0) returns int

  if \isJrt then return 0                    -- shouldn't occur

  fpack=package.replace('.',zsep)            -- package name with fileseps
  dirpath=module                             
  
  if fpack.length()>0 then dirpath=dirpath||zsep||fpack

  if find \==null then do
     ffind = find.replace('.', zsep) 
     dirpath=dirpath||zsep||ffind
  end


  e=Exception
  do
    p = Paths.get(URI.create(jrtprefix||dirpath))

    if Files.isDirectory(p, [LinkOption null]) then do
  /* We have a directory to check */
      if rxt.superflag.diag then do
        if find=null then sfind='[all]'; else sfind=find
        say '# MODFIND loop start ' dirpath """"module"""" ''''fpack'''' ''''sfind''''
        start=System.currentTimeMillis()
      end
/* Here for a directory search */

      count=0
      stream = Files.list(p)
      ap = Object[]
      ap = stream.toArray()
      loop i=0 to ap.length-1
        pp=Path ap[i]
        if Files.isDirectory(pp, [LinkOption null]) & subpacks then do

          s=pp.toString()

          npack=s.substring(8)                     -- strip /modules
          npack=npack.substring(module.length() + 1)
          count = count+modfind(module, npack, null, nickable, importer, subpacks)
          if rxt.superflag.diag then
            say '# MODFIND loop end with ['count'] after' System.currentTimeMillis()-start'ms'
        end
        else do
          name = pp.toString()
          if name.endsWith('.class') then do
            /* here for a .class file [don't worry about erase .. load will detect] */
            item=pp
            class=name.substring(0, name.length()-6)   -- drop .class
            class=class.substring(name.lastIndexOf(zsep)+1)
            package=name.substring(0, name.lastIndexOf(zsep))
            package=package.substring(9)          -- drop /modules/
            package=package.substring(module.length()+1)
            package=package.replaceAll(zsep, ".")
            info=classpool.register(package, class, item, null, nickable, importer, 0)
            if importer\=null then importclasses.addElement(info) -- discardable
            count=count+1
            end
--        else do
--          ## say "NOT CLASS " name
--        end
        end
      end
    end
    else if find \==null then do
/* Here for a class search */

      fullfind=find.replace('.','$')'.class'   -- expected file name

      jrt = jrtprefix||module||zsep||fpack||zsep||fullfind

      if rxt.superflag.diag then do
        say '# MODFIND checking 'jrt
        start=System.currentTimeMillis()
      end 

      p = Paths.get(URI.create(jrt))
      if Files.isReadable(p) then do           
                                                 -- This is an explicit class import
        item= p
      
        info=classpool.register(package, find, item, null, nickable, importer, 1)
        if importer\=null then importclasses.addElement(info) -- discardable
       
        found=1
      end
      else found=0
      if rxt.superflag.diag then
        say '# MODFIND checked ['found'] after' System.currentTimeMillis()-start'ms'
      return found
    end
    
  catch e=IllegalArgumentException          ----catch exception when looking for for arrays of classes,  String[][].class etc
    found=0
  catch e=IOException
    signal RxQuit(rxt, null, 'cannot.read.class', module, e.getMessage())
  end
  return count


  /** DIRFIND -- find classes in a directory
     Arg1 is directory path so far, or null string for current directory
     (system-dependent)
     Arg2 is package path (may be null string, has dots)
     Arg3 is search string: either a classname, or null for 'all classes'
     Arg4 is 1 if the class(es) being imported may be accessed by short name
     Arg5 is the program from which short name access is allowed
     Arg6 is 1 if subpackages (subdirectories) should be included
     returns the number of files found

     Neither path should end in a file separator.
     Registers each class found (of form xxx.xxx.yyy)
     Current directory cannot have subpackages
   */
  method dirfind(classseg=String, package=String, find=String,-
                 nickable=boolean, importer=RxProgram,-
                 subpacks=boolean 0) returns int
    fpack=package.replace('.',fsep)            -- package name with fileseps
    if classseg=='' then do                    -- no segment specified
      dirpath=System.getProperty('user.dir')   -- .. so use current directory
      subpacks=0                               -- .. and disable recursion
    end
  else dirpath=classseg                     -- [else use specified]
  if fpack.length()>0 then dirpath=dirpath||fsep||fpack
  dir=File(dirpath)                          -- check the path
  if \dir.isDirectory() then return 0          -- directory does not exist

  /* We have a directory to check */
  if rxt.superflag.diag then do
    if find=null then sfind='[all]'; else sfind=find
    say '# DIRFIND:' dirpath """"classseg"""" ''''fpack'''' ''''sfind''''
    start=System.currentTimeMillis()
  end

  if find\=null then do                      -- single file
    fullfind=find.replace('.','$')'.class'   -- expected file name
    item=File(dir, fullfind)                 -- will be caseless if FS is
    if item.exists() then do                   -- .. not found
                                               -- we should determine exact name spelling here (like RxStreamer),
                                               -- but maybe 1.1 fixes File().  tbd
                                               -- This is an explicit class import
      info=classpool.register(package, find, item, null, nickable, importer, 1)
      if importer\=null then importclasses.addElement(info) -- discardable
      found=1
    end
  else found=0
  if rxt.superflag.diag then
    say '# DIRFIND checked ['found'] after' System.currentTimeMillis()-start'ms'
  return found
  end

  /* Here for a directory search */
  count=0
  entries=dir.list()                           -- could be null <sigh>
  if entries\=null then loop i=0 for entries.length
  name=entries[i]
  if \name.endsWith('.class') then do      -- not a class file
                                           -- isDirectory is expensive, so we test for . first, as Java
                                           -- package names cannot have dots in them.
    if \subpacks then iterate i            -- don't recurse unless asked
    if name.indexOf(int(dot), 0)>=0 then iterate i -- has dot, cannot be directory
    item=File(dir, name)
    if \item.isDirectory() then iterate i    -- some arbitrary file with no .
    if \item.exists() then iterate i         -- asynchronous erase
    if package.length()=0 then newpack=name
    else newpack=package'.'name
    count=count+dirfind(classseg, newpack, null, nickable, importer)
    iterate i
  end
  /* here for a .class file [don't worry about erase .. load will detect] */
  item=File(dir, name)
  class=name.substring(0, name.length()-6)   -- drop .class
  info=classpool.register(package, class, item, null, nickable, importer, 0)
  if importer\=null then importclasses.addElement(info) -- discardable
  count=count+1
end i
if rxt.superflag.diag then
  say '# DIRFIND loop end with ['count'] after' System.currentTimeMillis()-start'ms'
return count

  /** ZIPFIND -- find classes in a Zip file
     Arg1 is a ZipFile object that distils the Zip file
     Arg2 is package name (may be null string; otherwise with dots)
     Arg3 is search string: class name [.class omitted], null for 'all',
     or '*' for standard imports (both Arg2/3 usurped)
     Arg4 is 1 if the class(es) being imported may be accessed by short name
     Arg5 is the program from which short name access is allowed
     Arg6 is 1 if subpackages should be included
     Arg7 is the package lookaside dictionary
     returns the number of files found

     Registers each class found (of form xxx.xxx.yyy)
   */
  method zipfind(zfile=java.util.zip.ZipFile, package=String, find=String,-
                 nickable=boolean, importer=RxProgram,-
                 subpacks=boolean, packlook=Hashtable) private returns int
    findname=String null
    if find=null then
      do
        standard=boolean 0                       -- not standard imports
      end
    else
      do
        standard=(find=='*')                     -- 1 for multi-search
        if \standard then
          findname=find.replace('.','$')         -- expected file name
      end
    -- findname is now non-null for an explicit class match
    explicit=(findname\=null)

    e=zfile.entries()                          -- enumerate
    count=0                                    -- files found
    packnamelen=package.length()               -- save length

    if rxt.superflag.diag then do
      say '# ZIPFIND '''zfile.getName()''' loop start:' package standard
      start=System.currentTimeMillis()
    end

    /* [this loop is time-critical, many hundreds of entries, so minimizes
       conversions] */
    lastpackage=''                                  -- lookaside
    loop label elements while e.hasMoreElements()
      entry=java.util.zip.ZipEntry e.nextElement()
      -- directories in packages cannot have dots, hence cannot be .class
      dname=entry.getName()                         -- get name
      dlen=dname.length()
      if \dname.startsWith('.class', dlen-6) then iterate -- not a class file
                                                          -- Split into package and class
                                                          lsep=dname.lastIndexOf(int(zsep), dlen-1)



 fclass=dname.substring(lsep+1, dlen-6)

-- now if doing 1-class search, then check the class name now
if explicit then do label classmatch
  if fclass==findname then leave classmatch        -- an exact match
  if rxt.program.flag.strictcase then iterate      -- no good ..
  if \fclass.equalsIgnoreCase(findname) then iterate  -- .. even caseless
end classmatch

if lsep<1 then do
  fpackage=''
  fplen=0
end
else do
  -- get package name, with dots instead of '/'
  fpackage=dname.substring(0, lsep).replace(zsep, '.')
  fplen=lsep
end

-- if rxt.superflag.diag then say '#  see:' fpackage package standard fclass
if standard then do                           -- special initial call
                                              -- only need to register packages on initial call
                                              -- we save a bit by testing for obvious repeat package
  if fpackage\==lastpackage then
    if fplen\=0 then do
      addpackage(fpackage, packlook)            -- register if new
      lastpackage=fpackage                      -- save for next test
    end
  loop i=0 for standpacks.length              -- check specials please
                                              -- next line makes assumption that standard packages are
                                              -- reasonably named; could check lengths equal or '.' in right place
                                              -- effectively this implies 'all subpackages'
    if standpacksscope[i] then                          --      standard packages may or may not include subpackages now --(issue #61) --KK-20120916
      if fpackage.startsWith(standpacks[i], 0) then leave
      else nop          --(issue #61) --KK-20120916
      else if fpackage.equals(standpacks[i]) then leave         --(issue #61) --KK-20120916
  end i
  if i=standpacks.length then iterate elements -- not found
                                               -- element is 'one of ours'
end
else /* not '*' */ do
-- [class name already checked if relevant]
if fpackage\==package then do               -- maybe not our package
  if \subpacks then iterate elements        -- definitely not
  if \fpackage.startsWith(package,0) then iterate elements -- ditto
  if fpackage.charAt(packnamelen)\=='.' then iterate elements -- ditto
                                                              -- package is a subpackage and so OK
end
    end

    /* Match is made */
    info=classpool.register(fpackage, fclass, zfile, entry, nickable,-
                            importer, explicit)
    if importer\=null then importclasses.addElement(info) -- discardable
    count=count+1
    if explicit then leave                   -- we found what we wanted
end elements

if rxt.superflag.diag then
  say '# ZIPFIND loop end with ['count'] after' System.currentTimeMillis()-start'ms'
return count

  /** PACKDIRFIND -- find packages in a directory
     Arg1 is directory path so far, or null string for current directory
     (system-dependent)
     Arg2 is lookaside dictionary to record packages for this segment

     Arg1 should not end in a separator.
     Registers each package found (of form xxx.xxx.yyy)
     Calls packdirsearch to explore directory tree
   */
  method packdirfind(classseg=String, packlook=Hashtable) private
    if classseg=='' then                       -- no segment specified
      dirpath=System.getProperty('user.dir')   -- .. so use current directory
    else dirpath=classseg                     -- [else use specified]

    dir=File(dirpath)                     -- check the path
    if dir.getName() == '.' then return --<==== Marc, this is the line 
    
    if \dir.isDirectory() then return       -- directory does not exist
    if rxt.superflag.diag then do
      -- only time the outer level
      say '# PACKDIRFIND '''dir.getPath()''' loop start'
      start=System.currentTimeMillis()
    end
    -- don't recurse if explicit "current directory please"
    packdirsearch(dir, '', packlook, classseg.length()>0)
    if rxt.superflag.diag then say '# PACKDIRFIND loop end after' System.currentTimeMillis()-start'ms'

  /** packdirsearch -- private method to search a directory
     Arg1 is directory object to search
     Arg2 is package name so far [initially null string]
     Arg3 is package lookaside directory
     Arg4 is 1 if recursion allowed

     We test for .class files before testing .isDirectory -- this made
     this search 3x faster.
     A package must have at least one file in it (.class or other
     resource).

     We make the assumption that package directory names cannot end in
     .class, as the File() + isDirectory call is much slower.
     [In fact we now assume no embedded '.']
   */
  method packdirsearch(dir=File, package=String,-
                       packlook=Hashtable, recurse=boolean) private
    /* search the directory */
    entries=dir.list()                         -- get list of names
    if entries=null then return                -- [avoids Linux problem]
    hasclasses=boolean 0
    loop i=0 for entries.length
      name=entries[i]
      if name.indexOf(int(dot), 0)>=0 then do  -- has dot, cannot be directory
        if hasclasses then iterate i           -- had a .class file already
        if name.endsWith('.class') then hasclasses=1  -- not a directory
        iterate i
      end
      /* plain name -- could be a directory */
      if \recurse then iterate i                    -- .. if interesting ...
      if name.indexOf(int(dot), 0)>=0 then iterate i-- has dot, cannot be directory
      item=File(dir, name)
      if \item.isDirectory() then iterate i
      if package.length()=0 then newpack=name
      else newpack=package'.'name
      packdirsearch(item, newpack, packlook, recurse)
    end i
    if hasclasses then if package.length()\=0 then addpackage(package, packlook)
    return

  /** ADDPACKAGE -- add package to known list, if new
     Arg1 is package name to add; exact case
     Arg2 is lookaside dictionary for segment [null if not from a segment]

     For new packages we also must register 'upper' packages, as these
     may exist in a zip file without a corresponding 'directory' entry.
     This is efficiently achieved by recursion.
   */
  method addpackage(pack=String, packlook=Hashtable null) shared
    if packlook\=null then do
      if packlook.containsKey(pack) then return     -- already known in segment
                                                    -- is new in segment, so add entry
                                                    packlook.put(pack, pack)
    end
    if packagetable.containsKey(pack) then return   -- already known somewhere
    packagetable.put(pack, pack)                    -- a newie
    if rxt.superflag.diag then
      if rxt.program.flag.verbose>4 then say '# AddPackage:' pack
      -- It's new; if an upper package then register it, too
      lsep=pack.lastIndexOf(int(dot), pack.length()-1)  -- find any package separator
      if lsep<0 then return                           -- no more dots
      pack=pack.substring(0, lsep)                    -- drop last segment
      addpackage(pack, packlook)                      -- register (if new)
      return

  /** GETPACKAGE -- return package part of a class name
     Arg1 is a (possibly qualified) class name or package name
     Arg2 is 1 if the name cannot be all a package name

     returns the package part of the class name (which will be followed
     by at least a dot and one character if the argument is a class
     name), or null if no package name was found.

     The longest package in the name is returned; the whole name may be a
     package name iff arg2 is 0

     -- used by RxBabel, and in this class
   */
  method getpackage(name=String, haveclass=boolean 1) shared returns String
    lsep=name.length()

    if haveclass then                          -- step back one segment
      lsep=name.lastIndexOf(int(dot), lsep-1)  -- find any package separator

      loop
        if lsep<0 then leave                     -- no more dots
        pack=name.substring(0, lsep)             -- package name?
        if ispackage(pack) then return pack      -- yes .. done
        start=lsep-1
        lsep=name.lastIndexOf(int(dot), start)   -- find any package separator
      end
      return null

  /** ISPACKAGE -- test if a name is a package name
     Arg1 is package name to test; exact case
     returns 1 if the name is a known package
   */
  method ispackage(pack=String) returns boolean
    return packagetable.get(pack)\=null

  /** CURRPACKAGE -- return package name of current directory
     rurns '' if current directory is not on classpath
   */
  method currpackage returns Rexx
    dirpath=Rexx System.getProperty('user.dir')     -- current directory
    loop cp=0 for classpaths
      zfile=java.util.zip.ZipFile classpathzip.elementAt(cp)
      if zfile\=null then iterate cp
      -- classpath segment is a directory root
      seg=Rexx classpathseg.elementAt(cp)
      if dirpath.left(seg.length()).OpEq(null, seg) then
        return dirpath.substr(seg.length().toint()+2).translate('.', fsep)
    end cp
    return ''    -- none matched

  /** LOADCLASS -- load a class and save information for later lookup
     Arg1 is the context cursor
     Arg2 is RxClassInfo object for class to load
     Arg3 is token in case of error
     Arg4 is 1 if visibility is to be tested
     Returns if loaded OK, else signals RxQuit

     This should only be called from findclass.

     Note that STRICTCASE no longer affects registration of fields
     [1997.11.23], so it could now be called to preload classes.

     Interfaces look like classes, with a modifier of 'interface'.
     If the class is the current class, the [old] binary is not loaded.

     The RxClassInfo information could be set directly by RxClassImage,
     but the current approach will make it easier to move to use the
     reflection methods in Java 1.1, later (if and when they provide
     access to Attributes).
   */
  method loadclass(cursor=RxCursor, info=RxClassInfo, tok=RxToken,-
                   testvis=boolean) private
    if info.loaded then return                      -- already loaded
    info.loaded=1                                   -- never again
    if info.type.isPrimitive() then return            -- no 'real' class
    if info.type=RxType.NULL_TYPE then return           -- special case

    -- don't need a current class to load a class [e.g., explicit import check]

    if rxt.program.flag.verbose>4
      then rxt.say('  Loading class '''info.type.classname'''...')
    else if rxt.superflag.diag then say '# Loadclass' info.type.classname

    item=info.fileitem
    if item=null then signal RxQuit(rxt, tok, 'internal.error',-
       'RxClasser: null fileitem for' info.type.classname)
    is=InputStream null       -- inputstream
    size=long 0               -- .. and its length
    e=Exception
    if item<=java.util.zip.ZipFile then do
      -- Class is in a ZipEntry
      zfile=java.util.zip.ZipFile item
      if rxt.superflag.diag then say '# ... from zipfile' zfile.getName()
      if info.entry=null then signal RxQuit(rxt, tok, 'internal.error',-
         'RxClasser: null entry for' info.type.classname)
      zentry=java.util.zip.ZipEntry info.entry
      is=zfile.getInputStream(zentry)
      size=zentry.getSize()
    catch e=IOException
      if e<=java.util.zip.ZipException then -- [this is now disguised in 1.1]
        signal RxQuit(rxt, tok, 'classes.zip.format.error', e.getMessage())
        signal RxQuit(rxt, tok, 'classes.zip.read.error', e.getMessage())
    end
--MRE Read class from module
    else if item<=java.nio.file.Path then do
      -- Class is in Module
      pentry=Path item

      if rxt.superflag.diag then say '# ... from module' pentry.toString()

      oo = OpenOption[1]
      oo[0] = StandardOpenOption.valueOf('READ')
      is=Files.newInputStream(pentry,oo)
      size=is.available()
    catch e=IOException
      signal RxQuit(rxt, tok, 'cannot.read.class', pentry.toString(), e.getMessage())
    end
    else do
      -- Class is in File
      fentry=File item
      if rxt.superflag.diag then say '# ... from file' fentry.toString()
      is=FileInputStream(fentry)
      size=is.available()
    catch e=FileNotFoundException
      signal RxQuit(rxt, tok, 'class.file.not.found', e.getMessage()) -- it vanished
    catch e=IOException
      signal RxQuit(rxt, tok, 'cannot.read.class', fentry.getName(), e.getMessage())
    end

    /* Loading the RxClassImage was [once] about 2/3 of the total for
       loading a class [needs remeasure] */
    if rxt.superflag.diag then start=System.currentTimeMillis()
    ci=RxClassImage(rxt, info, is, size, tok)  -- load and parse the binary image

    -- [RxClassImage will signal any error directly]

    /* Check for imposters */
    if info.type.classname\==ci.thisname then
      signal RxQuit(rxt, tok, 'class.imposter', info.type.classname, ci.thisname)

    /* Now, if requested, see if the class really is visible */
    if testvis then do
      tp=rxt.program.packagename
      if tp=null then tp=''               -- package is 'current'
      if \ci.isvisible(tp) then
        signal RxQuit(rxt, tok, 'class.not.public', info.type.classname)
    end

    /* Save the Class information that we're interested in */
    info.fullname    =ci.thisfullname     -- [dotted]
    info.parents     =ci.thisparents      -- count of parents
    info.minors      =ci.thisminors       -- count of minors
    info.ispublic    =ci.ispublic
    info.isinterface =ci.isinterface
    info.isabstract  =ci.isabstract
    info.isfinal     =ci.isfinal
    info.isdeprecated=ci.isdeprecated
    info.isdependent =ci.isdependent
    info.isallpublic =ci.isallpublic
    info.impnames    =ci.interfaces       -- these stay as strings, for now

    -- unless won't interpret then save image data for later loadclass use
    if \rxt.wontexec then info.imagedata=ci.data
    --   until needed
    -- Load the super and parent classes, if any
    if ci.supername\=null then
      info.superinfo=findclass(cursor, ci.supername, null, 0)   -- [perhaps recursive]
    if ci.parentname\=null then
      info.parentinfo=findclass(cursor, ci.parentname, null, 0) -- [perhaps recursive]

    -- Load any children classes
  /** This code is correct, but disabled for now as it doesn't actually
   *** achieve anything (we cannot use the information for IMPORT, for
   *** example).
     if info.minors>0 then do
     info.children=Vector(info.minors)
     loop m=0 for info.minors
    -- Find and load the children [may be recursive]
     mininfo=findclass(cursor, String ci.minors.elementAt(m), null, 0)
     info.children.addElement(mininfo)  -- add reference to us
     end m
     end
   ***/

    /* now process the fields */
    -- private fields are always invisible and are ignored
    -- shared (Java default) fields can be ignored unless:
    --   * They are in same package
    -- inheritable (Java protected) fields can be ignored unless:
    --   * They are in same package
    --   * They are in a class that is a super- or sub-class of the
    --     current class.
    --   [note Java specification says inheritable constructors are
    --    treated as shared: i.e., only visible in same package. nyi]
    -- Unfortunately we cannot discard inheritable or package fields at
    -- this point, as we may have many classes in the current program.
    methods=0; props=0               -- counts of fields
    loop arrays=0 to 1
      if arrays=0 then fa=ci.propfields
      else fa=ci.methfields
      loop f=0 for fa.length
        field=fa[f]
        if field.fieldvisib=RxField.VIS_PRIV then iterate f
        registerfield(field)                             -- index it
        if rxt.program.flag.verbose<5 then iterate f     -- no counting needed
        if arrays=1 then methods=methods+1
        else props=props+1
      end f
    end arrays

    if rxt.program.flag.verbose>3 then do
      if rxt.superflag.diag then stop=System.currentTimeMillis()
      add=''
      preadd='    '
      if rxt.pass<1 then preadd=''
      if rxt.program.flag.verbose>4 then do
        preadd=''; add=' (Visible:'
        if methods=0 then add=add 'no methods'
        else if methods=1 then add=add 'one method'
        else add=add methods 'methods'
        if props=0 then add=add', no properties)'
        else if props=1 then add=add', one property)'
        else add=add',' props 'properties)'
      end
      if rxt.superflag.diag then add=add '['(stop-start)'ms]'
      rxt.say(preadd'  Loaded' ci.modifiers 'class '''info.type.classname''''add)
    end

    ci=null -- done with the image
    return  /* loadclass OK */

  /** FINDANYCLASS -- Find a class and return its ClassInfo object
     Arg1 is context cursor, used for parent/child lookup and importer program
     Arg2 is potential class name, either:
    -- fully qualified (package & full name)
    -- the short(est) name of a parent class or immediate child
    -- a fullname (in any package)
     Arg3 is token, in case of error

     Returns RxClassInfo if the given name names a visible class (or
     primitive type) unambiguously, or null otherwise.
     If the class is found, it is loaded (if needed) and checked for
     deprecation (always).
   */
  method findanyclass(cursor=RxCursor, cclass=Rexx, tok=RxToken)-
                      returns RxClassInfo
    /* If a short name (no dots) then we must first search for a parent
       or child class.  If found, we'll have the RxClassInfo object, so
       we can return it directly.
       We include ourself in the search, as fastpath.
     */
    if cclass.pos('.')=='0' then do label checkminor
      thisclass=cursor.curclass
      -- order of checking doesn't matter, here.  Let's go bottom up.
      if thisclass=null then leave checkminor      -- no class yet
      thisinfo=thisclass.classinfo                 -- current classinfo
      if thisinfo=null then leave checkminor       -- no classinfo yet
      if thisinfo.children\=null then
        loop i=0 for thisinfo.children.size()
          info=RxClassInfo thisinfo.children.elementAt(i)
          if rxt.program.flag.strictcase
            then ischild=(cclass==info.shortname)
          else ischild=(cclass.OpEq(null, info.shortname))
          if ischild then leave checkminor -- matched
        end
      -- now self and parents
      info=thisinfo
      loop until info=null
        if rxt.program.flag.strictcase
          then isknown=(cclass==info.shortname)
        else isknown=(cclass.OpEq(null, info.shortname))
        if isknown then leave checkminor -- found
        info=info.parentinfo             -- up to parent
      end
    end checkminor
    if info=null then info=findpackclass(cursor, 1, cclass, tok, 1)
    if info\=null then if info.isdeprecated then warndep(tok, info)
    return info

  /** FINDCLASSBYID -- Find a class and return its ClassInfo object
     Arg1 is the unique class ID
     returns RxClassInfo for the class, or null if not a known local class

     Note that all local classes can be retrieved by incrementing the ID
     from 1 until this method returns null.
   */
 method findclassbyid(id=int) returns RxClassInfo
  id=id-1
  if id<0, id>=localclasses.size() then return null
  return RxClassInfo localclasses.elementAt(id)

 /** FINDKNOWNCLASS -- Find a class that we needed during parsing
    Arg1 is class name (exact case, dollared, if a minor class)
    returns RxClassInfo for the class, or null if not found or no image
      available (meaning that we didn't have to load it) and we're not a
      local class.
    Currently only used by RxProxyLoader.
    */
 method findknownclass(name=Rexx) returns RxClassInfo
  -- split to package and dotted classname
  lsep=name.lastpos('.').toint()     -- find package separator
  if lsep=0 then do
    classname=name
    packagename=Rexx ''            -- [not null]
    end
   else do
    classname=name.substr(lsep+1)
    packagename=name.left(lsep-1)
    end
  classname=classname.changestr('$', '.')
  info=classpool.find(rxt.program, packagename, classname, 1) -- find it, exactly
  if info=null then return null
  if info.local then return info                  -- we'll make proxy
  if info.imagedata\=null then return info        -- we can load it
  -- it's an incidental reference (e.g., imported but not used)
  return null

 /** FINDCLASS -- Find a class and return its ClassInfo object
    Arg1 is the cursor context [null is OK for a 'known name' lookup]
    Arg2 is potential class name (fully qualified, correct case, with no
            dimensions, as from RxType.classname)
         or RxType object
    Arg3 is token, in case of error
    Arg4 is 1 if visibility is to be tested

    returns RxClassInfo if the given name names a class (or primitive
      type) unambiguously, or null otherwise.
    If the class is found, it is loaded (if needed) and checked for
      visibility (if Arg3=1).
    Note that this must not be used before the first CLASS instruction
      is found (or implied), as STRICTCASE could change.
    */
 method findclass(cursor=RxCursor, cclass=Rexx, tok=RxToken, testvis=boolean)-
                  returns RxClassInfo
  return findpackclass(cursor, 0, cclass, tok, testvis)

 method findclass(cursor=RxCursor, ctype=RxType, tok=RxToken, testvis=boolean)-
                  returns RxClassInfo
  if cursor=null then program=RxProgram null
                 else program=cursor.curprogram
  -- fastpast handles common cases where no importation needed
  pack=ctype.getPackageName()
  name=ctype.getClassName()
  if pack=null then pack=''                   -- generic package
  info=classpool.find(program, pack, name, 1) -- find it, exactly
  if info\=null then do                       -- no ambiguous test; we had Type
    loadclass(cursor, info, tok, testvis)     -- load the class, if needed
    return info
    end
  return findpackclass(cursor, 0, ctype.classname, tok, testvis)

 /** FINDPACKCLASS -- Find a class and return its ClassInfo object
    Arg1 is the context, needed for a short-name lookup or otherwise null
    Arg2 is 1 for an any-case, possibly short (nickname) lookup
            0 for strict lookup
    Arg3 is the class name (short or qualified if Arg2=1, qualified
            and exact case otherwise)
    Arg4 is token, in case of error
    Arg5 is 1 if visibility is to be tested

    Returns RxClassInfo if the given name names a class (or primitive
      type) unambiguously, or null otherwise.
    If the class is found, it is loaded (if needed) and checked for
      visibility (if Arg5=1).

    Findpackclass checks for an exact match first, then (unless options
      strictcase is in effect) an inexact match.
    Primitives are in the class pool now [1996.11.09] so could raise an
      ambiguous class error if in conflict with a .class file/entry.
    */
 method findpackclass(cursor=RxCursor, any=boolean, cclass=Rexx, tok=RxToken,-
                      testvis=boolean) private returns RxClassInfo
  -- if cclass.pos('ZipFile')\=='0' then trace r

  if cursor=null then program=RxProgram null
                 else program=cursor.curprogram

  foundpack=String null                 -- non-null if package found in name
  key=cclass.toString()
  if any then usepack=String null
         else usepack=''

  /* Try exactly as given first [e.g., a minor class] */
  info=classpool.find(program, usepack, key, 1) -- find it, exactly

  if info=null then do                  -- not found, try split
    -- fastpath some regulars
    if key.length()=4 then do
      if key=='null' then return null
      if key=='void' then return null
      end

    /* Split into package and class */
    foundpack=getpackage(key, 1)
    if foundpack=null then do           -- no package found
      pack=usepack                      -- use default package
      name=key                          -- class name
      end
     else do
      pack=foundpack
      name=key.substring(pack.length()+1, key.length()) -- class name
      end

    info=classpool.find(program, pack, name, 1)   -- find it, exactly

    /* If unknown and it was a qualified name with a known package then
       try and import it under its exact name [must be exact name in
       this case].
       Note: this explicit reference does not allow others to use short
       name. */
    if info=null then
     if pack\=null then
     if pack.length()>0 then
     if importclasses(cclass, 0, null)\=='0' then -- found it?
      info=classpool.find(program, pack, name, 1) -- now it is there

    /* If still unknown, maybe caseless will work */
    if info=null then do
      /* So far, so bad.  Try for inexact (by case) match, if allowed... */
      if any then
       if \rxt.program.flag.strictcase then do
        info=classpool.find(program, usepack, key, 0) -- original shape
        if info=null then info=classpool.find(program, pack, name, 0) -- last try
        end
      end
    end

  if info\=null then /* we know it, now */ do
    if info.ambiguous then                   -- if could be ambiguous
     if foundpack=null then                  -- .. and no explicit package
      signal RxQuit(rxt, tok, 'ambiguous.class.reference', cclass)
    loadclass(cursor, info, tok, testvis)    -- load the class, if needed
    return info
    end

  /* not a known class */
  if rxt.superflag.diag then say '# unfound class: '''cclass'''' any
  return null

 /** ISAMBIGUOUS -- Check if a class name is ambiguous
    Arg1 is program context
    Arg2 is class full name (no package, but may include dots)
    Result is 1 if Arg2 found and is ambiguous, 0 otherwise
    Case must match exactly.

    If there is a current class (not in a package), and the name
    matches, then it won't be deemed ambiguous.  [Consider a test class
    called String.]

    This is now [97.03.29] used for deriving a concise babelized type
    name, only.
    */
 method isambiguous(program=RxProgram, lookname=Rexx) returns boolean
  key=lookname.toString()
  info=classpool.find(program, null, key, 1)      -- find it, exactly
  if info=null then return 0                      -- not found
  if \info.ambiguous then return 0                -- non-ambiguous
  if rxt.exec then return 1                       -- better to use long name
  -- looking bad
  if program.parser\=null then
   if program.packagename=null then
   if program.parser.cursor.curclass\=null then
   if program.parser.cursor.curclass.classname==lookname then return 0
  return 1          -- it's ambiguous

 /** ISSUBCLASS -- Check class if is a subclass of another (self allowed)
    Arg1 is context cursor
    Arg2 is class: (type object describes)
                   (or RxClassInfo object)
    Arg3 is class to search upwards until (ditto)
                   (may be RxClassInfo object iff Arg1 is)
    Arg4 is token, in case of error
    Result is 1 if Arg2 is a subclass of Arg2, 0 otherwise
    [This also is the only cycle-checker -- so is intended to be used as
     a cycle-checker, too]
 */
 method issubclass(cursor=RxCursor, look=RxType, targ=RxType, tok=RxToken)-
                   returns boolean
   if look.classname=='null' then /* special case */
     do
       if targ.isPrimitive() then return 0
       return 1 /* 'null' is a subclass of everything else */
     end
   lookinfo=findclass(cursor, look, tok, 0)   -- qualify
   if lookinfo=null then return 0             -- unknown class
   return issubclass(cursor, lookinfo, targ, tok)

  method issubclass(cursor=RxCursor, lookinfo=RxClassInfo, targ=RxType,-
                    tok=RxToken) returns boolean
    targinfo=findclass(cursor, targ, tok, 0)   -- qualify
    if targinfo=null then return 0             -- unknown class
    return testsubclass(cursor, lookinfo, targinfo, tok, null)

  method issubclass(cursor=RxCursor, lookinfo=RxClassInfo, targinfo=RxClassInfo,-
                    tok=RxToken) returns boolean
    return testsubclass(cursor, lookinfo, targinfo, tok, null)

  /** Shared recursive routine */
  method testsubclass(cursor=RxCursor, lookinfo=RxClassInfo, targinfo=RxClassInfo,-
                      tok=RxToken, starttype=RxType) private returns boolean
    startinfo = lookinfo                                   -- in case of cycle
    looktype  = lookinfo.type
    targtype  = targinfo.type
    if starttype=null then starttype=looktype
    startname=starttype.classname
    loop label spinup
      if looktype=targtype then return 1                 -- we found it above us
                                                         -- [or we are it]
                                                         /* Try for the Implements hierarchy, at every level */
    -- Resolve the interface names, if needed
    if lookinfo.impinfos=null then findimps(cursor, lookinfo, tok)
    loop i=0 for lookinfo.impinfos.length
      impinfo=lookinfo.impinfos[i]
      if impinfo.type.classname==startname then do     -- seen this before!
        signal RxQuit(rxt, tok, 'class.implements.cycle')
        end
      if testsubclass(cursor, impinfo, targinfo, tok, starttype) then
        return 1 -- found
      end
    if looktype=RxType.OBJECT_TYPE then leave spinup       -- no more above
    lookinfo=lookinfo.superinfo                        -- up a level
    if lookinfo=null then leave spinup                 -- at the top
    looktype=lookinfo.type
    if lookinfo.type.classname==startname then do      -- seen this before!
      -- break the loop; hang off Object instead
      startinfo.superinfo=findclass(cursor, RxType.OBJECT_CLASS, null, 0)
      signal RxQuit(rxt, tok, 'class.superclass.cycle')
      end
    end spinup
  return 0

 /** FINDFIELDBYID -- Find a field by ID number
    Arg1 is the unique field ID
    returns RxField for the field, or null if not a known local field
    */
 method findfieldbyid(id=int) returns RxField
  id=id-1
  if id<0, id>=localfields.size() then return null
  return RxField localfields.elementAt(id)

 /** FINDFIELD -- Check method or property is known in given class.
   Arg1  is the context [may be null for unchecked lookup]
   Arg2  is 1 for a local lookup only, 0 otherwise (spin up)
   Arg3  is 1 for a method lookup, 0 otherwise
   Arg4  is 1 for a property lookup, 0 otherwise
   Arg5  is 1 for statics-only lookup, 0 otherwise
   Arg6  is classinfo of class to search from [may be null]
   Arg7  is field name to look for
   Arg8  is method arguments types array (if arg2=1) [may be null]
            each may have dimensions:  foo[,]
   Arg9  is token, in case of errors or warnings (e.g., during findclass,
            or accessibility or deprecation).  This should be set to null
            if not processing a true field reference (as in a term, for
            example) to avoid inappropriate deprecation warnings.
   Arg10 is 1 if accessibility is to be checked [0 used for error messages only]

   If a method lookup, and name and signature match then we are in fact
     looking for a constructor, and special rules apply -- the name of
     the method changes to match the class as we go up the hierarchy.
   If both Arg1 and Arg2 are set, then either method or property
     allowed (but not a constructor), if arg5 is null.

   Result is a RxField object if a matching field found, null otherwise.

   FIELDAMBIG in the returned object is set if more than one matched;
   the choice of field in this case is undefined, and so the flag should
   normally always be tested after an apparently successful call to
   FINDFIELD.

   This searches both methods and properties, in the given class and all
   superclasses.  The Implements tree is also searched (assumes
   downcasting must work); note it must be searched after the superclass
   at each level.

   [1997.06.19] Add 'package only' access -- field is only visible if in
   same package as searcher.

   If we are doing a search without 'check access' then this means we
   are only doing it in order to see if an inaccessible field can be
   found, for a better error message.  In this case (and in this case
   only) the class from which access was denied for the field will be
   saved in FIELDHIDDEN.  The access is therefore still checked.

   [1998.05.18] If the call to findfield includes a source position
   token, then it's assumed that the field is being referenced
   explicitly.  In this case, deprecation is checked -- both class and
   field warnings.  If both field and class are marked deprecated, only
   the more specific (field) warning is given.
   */
 method findfield(cursor=RxCursor,-
                  local=boolean, lookmeth=boolean, lookprop=boolean,-
                  statics=boolean, infostart=RxClassInfo,-
                  exactname=Rexx, argtypearray=RxType[],-
                  tok=RxToken, checkacc=boolean 1) returns RxField

  if cursor=null then flag=rxt.superflag
  else flag=cursor.curprogram.flag
  if flag.diag then do
    sigargs=argtlist(argtypearray)
    if sigargs\=='' then sigargs='('sigargs')'
    say '# FF:' local||lookmeth||lookprop||statics-
      'looking for '''exactname||sigargs''''-
      'in '''infostart.type.toSig()'''...' checkacc
    -- if exactname=='say' then
    -- RxError(rxt, null, 'trace.back')
  end
  if infostart=null then return null              -- top of the heap
  if infostart.type.isarray() then return null      -- it can't have fields
  if infostart.type.isPrimitive() then return null  -- it can't have fields
  isconstructor=boolean 0          -- 1 if a constructor search
  if lookmeth then do
    /* constructor will have special search */
    if flag.strictcase
      then isconstructor=(exactname==infostart.shortname)
    else isconstructor=(exactname.OpEq(null,infostart.shortname))
  end

  searchinginterfaces=0         --              KK

  retfield=searchfield(cursor, local, lookmeth, lookprop, statics,-
                       infostart, infostart, exactname, argtypearray,-
                       tok, checkacc, isconstructor)
  if retfield=null then return null     -- not found

  if tok=null then return retfield      -- no message possible
  -- check for deprecation
  if retfield.isDeprecated() then warndep(tok, retfield)
   else if retfield.fieldinfo.isdeprecated then warndep(tok, retfield.fieldinfo)
  return retfield

  /**  sub-method called recursively, with initial starting class */
  /*  preserved, and isconstructor pre-determined */
  /*  cursor is used for accessibility test [from current class], and also */
  /*  later can be used to skip compile-time checks */
  method searchfield(cursor=RxCursor,-
                     local=boolean, lookmeth=boolean, lookprop=boolean,-
                     statics=boolean,-
                     infofrom=RxClassInfo, infostart=RxClassInfo,-
                     exactname=Rexx, argtypearray=RxType[],-
                     tok=RxToken, checkacc=boolean,-
                     isconstructor=boolean) private returns RxField
    --  say "searchfield infofrom="infofrom.shortname "infostart="infostart.shortname "exactname="exactname "KK"
    gotfield=RxField null

  if cursor=null then flag=rxt.superflag               -- external lookup
                 else flag=cursor.curprogram.flag

  if argtypearray=null then argcount=0                 -- count of arguments
                       else argcount=argtypearray.length -- ..

  keyname=exactname.lower()
  fieldarray=infostart.getfieldarray(keyname) -- get fields to search

  if fieldarray\=null then
   loop exact=1 to flag.strictcase by -1
    -- This first checks exact match, then inexact (if allowed)

    if lookprop then /* look for a property */ do label proplook
      /**
      if flag.diag then
        say '#'lookprop'# looking for' name 'in' infostart.type.classname
      **/
      found=0                      -- count of matching fields
      loop f=0 for fieldarray.length
        field=fieldarray[f]
        if field.isMethod() then iterate f                      -- is a method
        if exact & exactname\==field.fieldname then iterate f
        if \exact & exactname==field.fieldname then iterate f -- already checked
        if statics then if \field.isStatic()     then iterate f -- no thanks
        if \accessible(cursor, infofrom, field, tok) then do
          -- it cannot be accessed
          if checkacc then iterate f
          field.fieldhidden=infofrom         -- remember who couldn't access
          end
         else if cursor\=null then do
          ourinfo=cursor.curclass.classinfo  -- current class local reference
          if infofrom\==ourinfo then         -- need to check 'from us' too
           if \accessible(cursor, ourinfo, field, tok) then do
            -- it cannot be accessed
            if checkacc then iterate f
            field.fieldhidden=ourinfo        -- remember who couldn't access
            end
          end
        found=found+1
        if found>1 then leave f         -- no point in processing any more
        firstfield=field                -- remember which we found
        end f
      if found>0 then do
        field=firstfield                -- this was the one
        field.fieldambig=(found>1)      -- 0 if only found one
        if flag.diag then do
          say '# prop:' field.fieldname '[type' field.fieldtype.toSig()'] found'-
              'in' field.fieldinfo.type.classname '['field.isMethod()-
              field.fieldvisib field.fieldatts']'
          if field.fieldambig then say '# Ambiguous'
          end
        return field
        end
      /* If not found, drop through to try methods and/or superclass */
      end proplook

    if lookmeth then /* we're doing a method lookup */ do label methodlook
--      gotfield=RxField null
      /**
      if flag.diag then do
        sigargs=argtlist(argtypearray)
        say '#'lookmeth'# looking for' name 'in'-
            infostart.type.classname 'sigargs:' sigargs
        end
      **/
      fieldconvert=RxConvert[] null-- field conversions
      fieldcost   =999999999       -- minimum cost so far
      countcost   =0               -- number of matches at this cost
      loop f=0 for fieldarray.length
        field=fieldarray[f]
        if \field.isMethod() then iterate f         -- not a method
--        say "fieldname="field.fieldname       "field.fieldinfo.shortname="field.fieldinfo.shortname "field.fieldtype.classname="field.fieldtype.classname      "field.fieldargtypes.length="field.fieldargtypes.length        --              KK
        if lookprop then
         if field.isConstructor() then iterate f    -- paren-less constructor

        if exact & exactname\==field.fieldname then iterate f
        if \exact & exactname==field.fieldname then iterate f -- already checked
        if statics then if \field.isStatic()     then iterate f -- no thanks

        if field.fieldargtypes.length\=argcount then iterate f -- wrong argument count
        if \accessible(cursor, infofrom, field, tok) then do
          -- it cannot be accessed
          if checkacc then iterate f
          field.fieldhidden=infofrom         -- remember who couldn't access
          end
         else if cursor\=null then do
          ourinfo=cursor.curclass.classinfo  -- current class local reference
          if infofrom\==ourinfo then         -- need to check 'from us' too
           if \accessible(cursor, ourinfo, field, tok) then do
            -- it cannot be accessed
            if checkacc then iterate f
            field.fieldhidden=ourinfo        -- remember who couldn't access
            end
          end

        /* calculate cost of assigning the arguments, and build conversion list */
        cost=0; convertlist=RxConvert[argcount]
        loop a=0 for argcount
          ftype=field.fieldargtypes[a]                 -- arrays should be Types
          atype=argtypearray[a]
          aconv=rxt.converter.assigncost(cursor, ftype, atype)
          /* say '# costing' field.fieldargtypes[a].toSig() argtypearray[a].toSig() '=> cost' aconv.cost */
          if aconv.cost>flag.maxassign then iterate f  -- no hope
          cost=cost+aconv.cost
          if cost>fieldcost then iterate f             -- we have a better
          convertlist[a]=aconv                         -- save conversions
          end a
        if searchinginterfaces then do; if cost \=0 then cost=cost+2;end                --              bias against interface methods because of "ambiguous" message with conversions  -  KK
        else
          do
            if field.fieldtype \= null then
              tc=findclass(cursor,field.fieldtype.classname,tok,0)
            else tc=null
            if tc \= null then
              if tc.isinterface then if cost \= 0 then cost=cost+1
          end
        --        say "cost="cost               --              KK
        if cost>fieldcost then iterate f             -- we have a better
        if cost<fieldcost then do                      -- best so far
          countcost   =1                               -- count is 1
          bestfield   =field                           -- remember which we are
          fieldcost   =cost                            -- best so far
          fieldconvert=convertlist                     -- clean
                                                       -- if cost is 0 and name is an exact match then we have a winner
          if cost=0 then if exact then leave f
        end
        else /* same cost as another */
        do
          countcost=countcost+1
          -- update which we are, as fieldhidden set for last (for example)
          bestfield=field
          -- we have to check all, as there may be a lower cost to come,
          -- unless we are at minimum (spelling ambiguousity)
          if cost=0 then leave f        -- definitely ambiguous [and \exact]
        end
      end f
      if countcost>0 then
        do
          field=bestfield                 -- this was the one
          field.fieldcost=fieldcost
          if countcost=1 then do
            field.fieldambig=0            -- note it is not ambiguous
            field.fieldconvert=fieldconvert
          end
      else /* >1 */
      do               -- it was ambiguous
        field.fieldambig=1            -- note it is ambiguous, and ..
        field.fieldconvert=null       -- .. invalidate conversions
      end
      if flag.diag then
        do
          sigargs=argtlist(field.fieldargtypes)
          say '# method:' field.fieldname'('sigargs') returns'-
            field.fieldtype.toSig() 'found in'-
            field.fieldinfo.type.classname '['fieldcost']'
          if field.fieldexcep\=null then say '# +excep:' field.fieldexcep
          if field.fieldambig then say '# Ambiguous'
        end
      gotfield = field
      if gotfield=null then leave exact
      if rxt.program.flag.strictmethods then return field;
      if field.fieldcost=0 then return field;
      leave exact
        end
end methodlook
end exact

/* Didn't find in the requested class -- try superclass and implements
     lists, unless we were asked for just a local search */
  if local then return gotfield              -- no spin up

  -- [2000.02.07] If we are a constructor then the actual constructor
  -- must exist in the class of the same name; we're not allowed to use
  -- a superclass or superinterface  constructor as the resulting type
  -- would be wrong.
  if isconstructor then return gotfield

  -- we can skip the superclass search if we are an interface class, as
  -- the superclass of an interface is always Object (which is not an interface)
/* let's NOT skip the superclass search for interfaces as it causes compile failures when using toString calls for interfaces --  KK 2011-12-26
  if infostart.isinterface then superinfo=RxClassInfo null
   else superinfo=infostart.superinfo             -- get superclass
*/
  superinfo=infostart.superinfo             -- get superclass
  if superinfo\=null then /* have superclass */ do
    lookname=exactname     -- same name
--    say "search superclass KK"
    newfield=searchfield(cursor, 0, lookmeth, lookprop, statics,-
                         infofrom, superinfo, lookname,-
                         argtypearray, tok, checkacc, isconstructor)
    if newfield\=null then
        if newfield.fieldcost=0 then return newfield        -- found in superclass
    end

  -- Now try the implements list
  -- Resolve the interface names, if needed
  if infostart.impinfos=null then findimps(cursor, infostart, tok)
  searchinginterfaces=1
  newfield2=RxField null
  loop i=0 for infostart.impinfos.length
    impinfo=infostart.impinfos[i]
--    say "search interfaces KK"
    newfieldi=searchfield(cursor, 0, lookmeth, lookprop, statics,-
                          infofrom, impinfo, exactname,-
                          argtypearray, tok, checkacc, isconstructor)
    if newfield2=null then newfield2=newfieldi
    else if newfieldi \= null then
      if newfieldi.fieldcost<newfield2.fieldcost then newfield2=newfieldi
      --    if newfield2\=null then return newfield2        -- found in interface class
  end i
  searchinginterfaces=0

  if gotfield = null then gotfield=newfield
          else if newfield \= null then
                  if newfield.fieldcost<gotfield.fieldcost then gotfield=newfield

  if gotfield = null then gotfield=newfield2
          else if newfield2 \= null then
                  if newfield2.fieldcost<gotfield.fieldcost then gotfield=newfield2

  return gotfield                                     -- not found or found
--  return null                                     -- not found

 /** ARGTLIST -- return RxType array as a list string */
 -- for diag only
 method argtlist(argtypearray=RxType[]) private returns Rexx
  list=''
  if argtypearray\=null then loop a=0 for argtypearray.length
    if a>0 then list=list','
    list=list||argtypearray[a].toSig()
    end a
  return list

 /** ACCESSIBLE -- determine if a field is accessible from given class
    Arg1 is the context cursor
    Arg2 is the class from where we are looking
    Arg3 is the field to check
    Arg4 is token in case of [unexpected] error
    returns 1 if the field is accessible (visible), 0 otherwise */
 method accessible(cursor=RxCursor, cinfo=RxClassInfo, field=RxField,-
                   tok=RxToken) private returns boolean
  vis=field.fieldvisib
  if vis=RxField.VIS_PUB then return 1                      -- public [always visible]
  if vis=RxField.VIS_INHER then do                          -- inheritable
    -- same package or is in superclass is OK
    if cinfo.packname==field.fieldinfo.packname then return 1
    if issubclass(cursor, cinfo, field.fieldinfo, tok) then return 1
    return 0   -- not visible
    end
  if vis=RxField.VIS_SHAR then do                           -- shared
    -- only same package is OK
    if cinfo.packname==field.fieldinfo.packname then return 1
    return 0   -- not visible
    end
  if vis=RxField.VIS_PRIV then do                           -- private
    -- this should be rare, as imported classes have private
    -- fields omitted
    -- only same package and class is OK
    if cinfo.type=field.fieldinfo.type then return 1
    return 0   -- not visible
    end
  signal RxQuit(rxt, tok, 'internal.error', 'RxClasser: access' vis)

 /** REGISTERFIELD -- Construct and register new field descriptor
    Arg1 is token for any error message (may be null)
    Arg2 is class RxClassInfo object
    Arg3 is field name (exact case)
    Arg4 is field type (signature)
    Arg5 is visibility value [VIS_]
    Arg6 is attributes flags [ATT_]
    Arg7 is argument types array if a method, null otherwise
    Arg8 is exceptions list [may be null]
    Arg9 is RxMethod object for a local method, or RxClass object for a
            local property
    returns the field added
    This entry point checks for Java and Venta reserved identifiers.
    Should only be called during parsing
    */
 method registerfield(tok=RxToken, classinfo=RxClassInfo,-
                      fieldname=Rexx, fieldtype=RxType,-
                      fieldvisib=int, fieldatts=int,-
                      argtypes=RxType[], exceps=Rexx,-
                      local=RxClauseParser null) returns RxField

  /* If the field is one we're making, check for Bad Words or leading $0 */
  if rxt.program.parser\=null then if rxt.program.parser.level>0 then do
    if classinfo.shortname==rxt.program.parser.cursor.curclass.classinfo.shortname then
     if classinfo.packname==rxt.program.parser.cursor.curclass.classinfo.packname then
      do
      if javakey(fieldname) then        -- maybe just a warning, later
        signal RxQuit(rxt, tok, 'name.is.reserved', fieldname)
      -- leading $0 is OK for methods
      if fieldname.left(2)=='$0' then if argtypes=null then
        signal RxQuit(rxt, tok, 'name.is.dollar0', fieldname)
      end
    end

  /* Construct generic RxField */
  field=RxField(rxt.program, classinfo, fieldname, fieldtype,-
                fieldvisib, fieldatts, argtypes, exceps)
  field.fieldlocal=local                -- copy in local clause parser
  if local\=null then do
    localfields.addElement(field)
    field.fieldid=localfields.size()      -- ID is offset+1
    end

  /* And register it with the class */
  return registerfield(field)

 /** REGISTERFIELD -- Register field descriptor during parsing
    Arg1 is field to register
    returns the field, now registered
    This entry point assumes the field name is valid (e.g., loaded from
    an existing class).
    */
 method registerfield(field=RxField) returns RxField
  keyname=field.fieldname.lower()                   -- name for lookup
  count=field.fieldinfo.registerfield(keyname, field)
  field.fieldcount=count

  if rxt.program.flag.verbose>4-
   |(rxt.program.flag.verbose>3 & rxt.superflag.diag) then do
    fcla=field.fieldinfo.type.classname      -- qualified class name
    args=rxt.program.toConciseString(field.fieldargtypes)
    exceps=field.fieldexcep
    if exceps\=null then args=args exceps
    rxt.say('    RegisterField('fcla','field.fieldname') ['keyname':'count']:'-
        (field.fieldtype.toSig() rxt.program.babel.fieldModifiers(field)-
        args).space())
    end

  return field

 /** FINDIMPS -- resolve the classes listed as interfaces
    Arg1 is context cursor
    Arg2 is the class which needs interfaces found
    Arg3 is token where to report error
    If not found, entries in the impinfos array may be null.
    */
 method findimps(cursor=RxCursor, info=RxClassInfo, tok=RxToken)
  if info.impnames=null then count=0
                        else count=info.impnames.length
  implist=RxClassInfo[count]
  loop i=0 for count
    implist[i]=findclass(cursor, info.impnames[i], tok, 0)
    if implist[i]=null then
      signal RxQuit(rxt, tok, 'class.not.found', info.impnames[i])
    end i
  info.impinfos=implist       -- now use this list
  info.impnames=null          -- finished with the old one

 /** UNIMPLEMENTED -- return a Vector of unimplemented fields
    Arg1 is the context
    Arg2 is the class we're processing
    Arg3 is an interface or abstract class whose methods we are to
            ensure implemented
    returns a Vector of any RxFields in the target class that are not
      implemented in the class being processed.
    Note that, unusually, the return type must match to count.
    */
 method unimplemented(cursor=RxCursor, frominfo=RxClassInfo,-
                      scaninfo=RxClassInfo) returns Vector
  result=Vector(10)
  -- for each method in the interface class...
  if scaninfo.fields=null then return result      -- empty (e.g., Serializable)
  loop obj over scaninfo.fields
    keyname=String obj
    fieldarray=scaninfo.getfieldarray(keyname)    -- get fields to search
    loop f=0 for fieldarray.length
      field=fieldarray[f]
      if \field.isMethod() then iterate f           -- not a method
      if \field.isAbstract() then iterate f         -- not abstract (!)
      newfield=findfield(cursor, 0, 1, 0, 0, frominfo,-
                         field.fieldname,-
                         field.fieldargtypes, null) -- [possibly ...,0]
      select
        when newfield=null                       then bad=boolean 1
        when newfield.isAbstract()                 then bad=1
        when newfield.fieldtype\=field.fieldtype then
          do
            bad=1               -- KK  this is wrong! must also check against super types!
            returnclass=findclass(cursor,newfield.fieldtype,null,0)
            if returnclass\=null then                                   -- missing check here causing null ptr errors   --  20121016 -- KK
              loop while returnclass.superinfo\=null
                if returnclass.type=field.fieldtype then do;bad=0;leave;end
                  if returnclass.impinfos=null then findimps(cursor, returnclass, null)         --20150524 -- KK -- fix for issue #115 = can't subclass ConcurrentHashMap in Java 8
                  ii=returnclass.impinfos
                  if ii\=null then -                                                                                    -- missing check here causing null ptr errors   --  20121017 -- KK
                     loop n=0 for ii.length
                       if ii[n]=null then iterate
                       if ii[n].type=field.fieldtype then do;bad=0;leave;end
                     end
                  if bad=0 then leave
                  returnclass=returnclass.superinfo
              end
          end
        -- if it was generated for us then it's not really there
        -- [1998.04.25 check removed .. indirect property is just fine]
        -- when newfield.isSynthetic-
        --   & newfield.fieldinfo.type=frominfo.type then bad=1
        -- [if ambiguous, this would have been reported earlier]
        otherwise bad=0
        end
      if bad then result.addElement(field)
      end f
    end obj
  return result

 /** ADDSHORTREF -- remember short reference to class
    Arg1 is class information
    */
 method addshortref(info=RxClassInfo)
  short=info.shortname.toString()
  if rxt.program.flag.strictcase then key=short
                                 else key=short.toLowerCase()
  if rxt.program.shortref.containsKey(key) then return -- already known
  rxt.program.shortref.put(key, short)                 -- it's new; make an entry

 /** GETSHORTREF -- get short reference exact spelling
    Arg1 is (short) Type name (any case, unless strictcase)
    returns String, or null if not found
    */
 method getshortref(short=String) returns String
  if rxt.program.flag.strictcase then key=short
                                 else key=short.toLowerCase()
  return String rxt.program.shortref.get(key)          -- return any entry

 /** ISSHORTREF -- test if class has short reference name
    Arg1 is (short) possible Type name (any case, unless strictcase)
    */
 method isshortref(short=String) returns boolean
  if rxt.program.flag.strictcase then key=short
                                 else key=short.toLowerCase()
  return rxt.program.shortref.containsKey(key)         -- test

 /** DISCARDLOCALS -- clear out all local and imported classes */
 -- used to revert classpool to 'permanent' classes only
 method discardlocals
  classpool.unhide()                 -- restore hidden classes
  loop i=0 for localclasses.size()
    info=RxClassInfo localclasses.elementAt(i)
    classpool.discard(info)
    end i
  loop i=0 for importclasses.size()
    info=RxClassInfo importclasses.elementAt(i)
    classpool.discard(info)
    end i
  -- clear lists
  localclasses=Vector(10)          -- list of local classes
  localfields=Vector(30)           -- list of local fields
  importclasses=Vector(50)         -- list of imported classes
  return

 /** ADDLOOKASIDE -- add class to list of classes with lookaside
    Arg1 is the class to add
    */
 method addlookaside(info=RxClassInfo)
  classdefines.addElement(info)

 /** CLEANLOOKASIDE -- clean up classes with lookaside */
 method cleanlookaside
  loop i=0 for classdefines.size()
    info=RxClassInfo classdefines.elementAt(i)
    info.classobject=null          -- no longer defined
    info.initialized=0             -- .. or initialized
    end i
  classdefines=Vector(5)           -- clear lookaside list

  if rxt.superflag.diag then do
    classpool.stats()                          -- statistics please
    say '#' packagetable.size() 'packages'     -- ..
    end
  return

 /** REGISTERLOCALCLASS -- add a new class (from CLASS instruction)
    Arg1 is package name (null string if none)
    Arg2 is class short name
    Arg3 is class fullname (with parents and dots)
    Arg4 is token of CLASS instruction (in case of error); null if
         implicit class
    returns the RxClassInfo object for the class

    This is used during parsing only.

    1998.09.17: a local class is considered explicitly imported
    2000.05.24: a local class is no longer considered explicitly imported
    */
 method registerlocalclass(pack=String, shortname=String,-
                           fullname=String, tok=RxToken)-
                           returns RxClassInfo

  if rxt.superflag.diag then say '# registerlocalclass '''pack''' '''fullname''''
  -- invalidate old matching .class file images loaded from imports, etc.
  classpool.invalidatenonlocal(pack, fullname)

  -- check we don't have an explicit import for the short name
  dupinfo=findanyclass(rxt.program.parser.cursor, shortname, tok)
  -- [defer test until after reserved/duplicate tests]

  -- register name, short name lookup from anywhere is OK
  info=classpool.register(pack, fullname, null, null, 1, null, 0)
  info.loaded=1                                   -- no load required
  localclasses.addElement(info)
  info.classid=localclasses.size()                  -- ID is offset+1

  if rxt.pass0 then do
    if javakey(info.shortname) then               -- maybe a warning, later
      signal RxQuit(rxt, tok, 'name.is.reserved', info.shortname)
    if info.local then do                         -- already registered
      if pack=='' then classname=fullname
                  else classname=pack'.'fullname
      if info.implied then signal RxQuit(rxt, tok, 'class.is.implied', classname)
      signal RxQuit(rxt, tok, 'class.name.duplicate', classname)
      end
    if dupinfo\=null then if dupinfo.explicit then
      signal RxQuit(rxt, tok, 'class.name.explicit', dupinfo.type.classname)
    if tok=null then info.implied=1
    info.local=1
    end
  return info

 /** WARNDEP -- warn of a deprecated field or class during parsing
    Arg1 is token at which to warn
    Arg2 is the deprecated field or classinfo
    */
 method warndep(tok=RxToken, field=RxField) shared
  if rxt.deprecateds.containsKey(field) then return -- already warned
  if field.isMethod() then do
    if field.isConstructor() then
      RxWarn(rxt, tok, 'deprecated.constructor',-
             field.toConciseString(rxt.program))
     else
      RxWarn(rxt, tok, 'deprecated.method',-
             field.toConciseString(rxt.program))
    end
   else RxWarn(rxt, tok, 'deprecated.property',-
               field.toConciseString(rxt.program))
  rxt.deprecateds.put(field, field) -- just the once, please

 method warndep(tok=RxToken, info=RxClassInfo) shared
  if rxt.deprecateds.containsKey(info) then return -- already warned
  RxWarn(rxt, tok, 'deprecated.class', info.type.classname)
  rxt.deprecateds.put(info, info) -- just the once, please

 /** JAVAKEY -- test for a Java keyword <sigh>
    Arg1 is the word to test [exact case]
    returns 1 if thw word is a Java keyword, 0 otherwise */
 method javakey(word=String) returns boolean
  if word.length()=0 then return 0
  c=word.charAt(0)
  if c<'a' then return 0
  if c>'w' then return 0
  /* Need to look it up */
  if javakeytable=null then do               -- initialize
    javakeytable=Hashtable(101)
    item=Object()                            -- dummy item to store
    javakeytable.put('abstract'    , item)
    javakeytable.put('assert'    , item)
    javakeytable.put('boolean'     , item)
    javakeytable.put('break'       , item)
    javakeytable.put('byte'        , item)
    javakeytable.put('case'        , item)
    javakeytable.put('catch'       , item)
    javakeytable.put('char'        , item)
    javakeytable.put('class'       , item)
    javakeytable.put('const'       , item)
    javakeytable.put('continue'    , item)
    javakeytable.put('default'     , item)
    javakeytable.put('do'          , item)
    javakeytable.put('double'      , item)
    javakeytable.put('else'        , item)
    javakeytable.put('enum'        , item) -- since 1.5
    javakeytable.put('extends'     , item)
    javakeytable.put('false'       , item)
    javakeytable.put('final'       , item)
    javakeytable.put('finally'     , item)
    javakeytable.put('float'       , item)
    javakeytable.put('for'         , item)
    javakeytable.put('goto'        , item)
    javakeytable.put('if'          , item)
    javakeytable.put('implements'  , item)
    javakeytable.put('import'      , item)
    javakeytable.put('instanceof'  , item)
    javakeytable.put('int'         , item)
    javakeytable.put('interface'   , item)
    javakeytable.put('long'        , item)
    javakeytable.put('native'      , item)
    javakeytable.put('new'         , item)
    javakeytable.put('null'        , item)
    javakeytable.put('package'     , item)
    javakeytable.put('private'     , item)
    javakeytable.put('protected'   , item)
    javakeytable.put('public'      , item)
    javakeytable.put('return'      , item)
    javakeytable.put('short'       , item)
    javakeytable.put('static'      , item)
    javakeytable.put('strictfp'    , item)
    javakeytable.put('super'       , item)
    javakeytable.put('switch'      , item)
    javakeytable.put('synchronized', item)
    javakeytable.put('this'        , item)
    javakeytable.put('throw'       , item)
    javakeytable.put('throws'      , item)
    javakeytable.put('transient'   , item)
    javakeytable.put('true'        , item)
    javakeytable.put('try'         , item)
    javakeytable.put('void'        , item)
    javakeytable.put('volatile'    , item)
    javakeytable.put('while'       , item)
    end
  return javakeytable.get(word)\=null

  method add2ImportedClasses(loadedClass=java.lang.Class)
    lastdot = loadedClass.getName().lastIndexOf('.')
    if lastdot <> -1 then do
      unkName = loadedClass.getName().substring(lastdot+1)
    end
    -- here we import the found class into the classpool
    info = classpool.register(loadedClass.getPackage().getName(),unkName,null,null,1,null,0 )
    info.loaded = 1 -- this is for
    mods = loadedClass.getModifiers()

    info.fullname    = unkName
    info.parents     = 0
    info.minors      = 0
    info.ispublic    = 0
    info.isinterface = 0
    info.isabstract  = 0
    info.isfinal     = java.lang.reflect.Modifier.isFinal(mods)
    info.isdeprecated= 0
    info.isdependent = 0
    info.isallpublic = 0
    info.impnames    = ['']       -- these stay as strings, for now

    importclasses.addElement(info)

