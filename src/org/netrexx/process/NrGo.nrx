/* IBM Materials Licensed under International Components for Unicode  */
/* Licence version 1.8.1 (ICU Licence) - Property of IBM              */
/* IBM NetRexx                                                        */
/* Copyright (c) 1995-2009 IBM Corp.                                  */
/* Copyright (c) 2011- RexxLA                                         */
/* ------------------------------------------------------------------ */
/* NetRexx language processor                                     mfc */
/* Copyright (c) IBM Corporation 1996, 2000.  All Rights Reserved.    */
/* ------------------------------------------------------------------ */
/* NrGo                                                               */
/*                                                                    */
/*   An object that represents a parsed go clause                     */
/*                                                                    */
/* ------------------------------------------------------------------ */
/* Change list                                                        */
/* 2025.10.04 MRE Initial                                             */
/* ------------------------------------------------------------------ */


package org.netrexx.process
options binary nodecimal strictcase strictargs

class NrGo implements RxClauseParser, Runnable
 properties private
  rxt     =RxTranslator   -- root
  parser  =RxParser       -- local reference
  tokens  =RxToken[]      -- local reference
  code    =RxCode
  cursor  =RxCursor
  tparser =RxTermParser

 /** Construct an object from the current clause */
 method NrGo(newrxt=RxTranslator)
  rxt    =newrxt                                  -- the boss
  parser =rxt.program.parser
  tokens =parser.cursor.curclause.tokens

/** Construct an instance from a cursor and a termparser to go */
 method NrGo(newcursor=RxCursor, newtparser=RxTermParser)
   cursor = newcursor
   tparser = newtparser

 /** Pass processing */
 method scan(pass=int)
  if pass<2 then signal RxQuit(rxt, tokens[0], 'internal.error', 'NrGo', pass)
  if tokens[1].type=RxToken.END then do
    signal RxError(rxt, tokens[1],  'method.expected')
  end

--  if tokens[1].type=RxToken.SP then begin=2; else begin=1  -- should be two

  code=rxt.tparser.parseterm(parser.cursor, 2, 0)
  if code.group \== RxCode.S_METHOD then do                  -- not a method
    signal RxError(rxt, tokens[2],  'method.expected')
  end
  if tokens[code.endoff+1].type \== RxToken.END then do      -- can be followed by methodcall only
    signal RxError(rxt, tokens[code.endoff+1], 'bad.expression.syntax')
  end
  return

 /** Trace names list */
 method getAssigns returns String[]
  return null


 /** code generation [only] */
 method generate
  -- generate java code to run the given method as a thread
  prefix = '{new Thread(() -> '
  postfix = ').start();}'

  if code=null then jcode='""'
  else do
    jcode=prefix''code.javacode''postfix
  end
  rxt.program.streamer.out(jcode)

 --  say '.. 'jcode

 /** Interpretation */
 method interpret(tcursor=RxCursor null)
  if code = null then return

  -- create a new cursor, and assign our needed properties
  newcursor = RxCursor(rxt.program, tcursor.curclass, tcursor.curmethod, tcursor.curclause)
  newcursor.curexec = tcursor.curexec     -- yes, we're exec-ing..
  newcursor.curlpool = tcursor.curlpool

  r = NrGo(newcursor, rxt.tparser)        -- create our go instance, and start the thread
  t = Thread(r)
  t.start()
  return

  method run()
   --  here the interpreter is runnning in a new thread (started by interpret above)
   --  parse and exec our cursor
   do
--     say '....'cursor.curclause.showtokens()
       code=tparser.parseterm(cursor, 2, 0)
   catch s = RxSignal
     say s.toString()' at 'cursor.curprogram.programname' line 's.signaltoken.line' pos 's.signaltoken.pos
   catch e = RxError
     say e.toString()' at 'cursor.curprogram.programname
   end
