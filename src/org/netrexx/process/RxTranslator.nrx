/* IBM Materials Licensed under International Components for Unicode  */
/* Licence version 1.8.1 (ICU Licence) - Property of IBM              */
/* IBM NetRexx                                                        */
/* Copyright (c) 1995-2009 IBM Corp.                                  */
/* Copyright (c) 2011- RexxLA                                         */
/* ------------------------------------------------------------------ */
/* Venta language processor                                       mfc */
/* Copyright (c) IBM Corporation 1996, 2004.  All Rights Reserved.    */
/* ------------------------------------------------------------------ */
/* RxTranslator                                                       */
/*                                                                    */
/*  An instance of a Venta translator.                                */
/*  The properties of this class are the 'outer' level handles, and   */
/*    the like.                                                       */
/* ------------------------------------------------------------------ */
/* 1996.05.04 Initial                                                 */
/* 1996.07.03 Add completion message                                  */
/* 1996.09.02 Add exitlevel number                                    */
/* 1996.11.24 Warning count, compact                                  */
/* 1997.04.20 Multiple file translation [shared classer]; RxFlag      */
/* 1997.04.21 RxProgram object introduced                             */
/* 1997.06.29 Manage messages properties file from here               */
/* 1998.01.10 Handle SOURCEDIR option                                 */
/* 1998.04.18 Introduce RxBabel and dynamically loaded languages      */
/* 1998.05.18 Common redirectable path for compiler displays          */
/* 1998.10.12 Remove java.math from automatic imports                 */
/* 1999.08.13 Pass flags to translate() as an array                   */
/* 1999.10.19 Add experimental exec() method                          */
/* 2000.02.27 Add traceback after RxSignal                            */
/* 2000.03.14 Add hook for proxies                                    */
/* 2000.04.12 Add code to wait for single-user-thread                 */
/* 2000.04.12 More efficient makemessage                              */
/* 2000.04.19 Small reorganization for API; exec() now called above   */
/* 2011.08.22 pass keepasjava option to skip rename of java files to  */
/*            .keep  - Kermit Kiser                                   */
/* 2012.07.31 System property nrx.compiler = ecj option for           */
/*            alternative compiler - rvj                              */
/* 2012.09.09 switch to thread context classloader if NetRexx running */
/*            from java lib\ext directory and use reflection to call  */
/*            java compiler - Kermit                                  */
/* 2012.09.16 change auto import interface to allow import of a       */
/*            single package as well as package hierarchy branches    */
/*             --issue #61 --Kermit                                   */
/* 2012.09.16 add base javax.swing package to auto imports            */
/*            --issue #61 --Kermit                                    */
/* 2012.10.11 fix for missing package info if this class is loaded by */
/*            some classloaders  -- no issue # --Kermit               */
/* 2013.01.15 switch the javac call to the documented entry point to  */
/*            fix issues #74, #95 and possible other problems  -- KK -*/
/* 2013.09.18  eliminate prob where getImplementationVersion returns  */
/*             null so compiler will run unjared (also fixes bad      */
/*             playing with strings msg in build - issue #105)  -- KK */
/* 2015.05.02 switch javac use to jsr199 java compiler api issue #90  */
/* 2015.05.05 add cmd line options "-javac" and "ecj" - overrides     */
/*            nrx.compiler but nrx.compiler can now include java      */
/*            options after compiler pref - KK                        */
/* 2015.05.15 reformat build info  -- KK -- Kermit                    */
/* 2015.06.11 fix for #134 time output needs correct compiler name    */
/* 2015.06.11 if using jsr199 to pass java code and no java output,   */
/*            don't touch disk files                                  */
/* 2019.05.09 display failed summaries last - Jason Martin            */
/* 2021.01.15 store (setaddress) NetRexxC -address flag  -- MRE       */
/* 2021.12.31 add RxModel - Jason Martin                              */
/* ------------------------------------------------------------------ */
/* The translator originally was slightly more general, in that it    */
/* permitted an output .java to be specified.  We now [1997.04.20]    */
/* allow an array of files to be processed 'concurrently', so we      */
/* have dropped the output file possibility.  (In theory, we could    */
/* re-add this, as an array of output files, later.)                  */
/*                                                                    */
-- Still some NetRexxy things

package org.netrexx.process
options binary decimal strictcase strictargs
--import com.sun.tools.javac.Main   -- the javac compiler
import javax.tools.             --      2015.05.02 switch javac use to jsr199 java compiler api -- KK

class RxTranslator

 properties public constant   -- constants, visible everywhere
  -- return codes
  EXIT_OK     =int 0          -- Exit values
  EXIT_WARN   =int 1          -- Exit values
  EXIT_ERROR  =int 2          -- Exit values

 properties public static     -- accessible from anywhere
  -- this property holds the current RxInterpreter instance for
  -- interpretation proxies.  Currently we assume only one; later this
  -- could easily be extended to allow an indexed or named collection of
  -- instances.  This is the only changeable static in the entire package.
  proxyInterpreter=RxInterpreter

 properties shared            -- visible within the package

  /* Globals (shared by all programs in the package) */
  keep    =boolean 0          -- keep the java file
  keepasjava = boolean 0      -- keep java output and do not rename it to .keep
  classlist=java.util.List    -- allow return of class files to caller in memory
  javac = boolean 0           -- prefer javac compiler if available
  ecj = boolean 0             -- prefer ecj compiler if available
  compilerChoice = String           
  address = boolean 0         -- prefer no ADDRESS instruction

  babels      =RxBabel[]      -- language-specific key classes
  classer     =RxClasser      -- class handler
  interpreter =RxInterpreter  -- evaluator
  loader      =RxProxyLoader  -- our loader (null unless executing)
  localpackages=Hashtable     -- lookup for local packages (ditto)
  -- the next three will one day move to RxProgram [language-specific]
  converter   =RxConverter    -- spin doctor
  tparser     =RxTermParser   -- general parser for terms
  eparser     =RxExprParser   -- general parser for expressions
  /* Passes:
    Pass 0 is prepass: only prolog and CLASS instructions
    Pass 1 is resolution of properties and methods
    Pass 2 is remainder and code generation
    Pass 3 is execution (interpretation)
    Pass 4 is compilation
    [these are mutually exclusive] */
  pass0       =boolean 0
  pass1       =boolean 0
  pass2       =boolean 0
  exec        =boolean 0
  comp        =boolean 0
  pass        =int 0          -- the pass, as a number (0-4)
  classpath   =String         -- for compiler; constructed by RxClasser
  superflag   =RxFlag()       -- shared flag object (initially defaults)
  hadexit     =boolean        -- set to 1 if we saw an exit during pass1
  wontexec    =boolean 0      -- set to 1 if we can assume we won't
                              -- interpret [allows optimizations]
  deprecateds =Hashtable      -- deprecated fields for which we have warned

  -- The next one holds current program during parsing; it should not be
  -- used during execution.
  program     =RxProgram      -- the current program

  -- Next is currently here as we only allow a single interpretation
  -- thread at present.  Will move somewhere more clever later.
  exiting     =boolean 0      -- leaving interpretation


  /* Standard import packages */
  -- [entry[0] is language-specific, no longer set by RxBabel]
  imports     =String[]       -- array of package names, e.g., 'java.lang'
                              -- [these will have hierarchies imported]

  
  properties constant shared   -- constants, visible within the package
  convertible     =50          -- conversion possible (e.g., to String)
  
  properties private
  programlist     =RxProgram[]     -- array of corresponding programs
  savecon         =PrintStream     -- con file
  savelog         =PrintWriter     -- log file
  starttime       =Rexx ''         -- translation start timestamp
  badjavac        =boolean 0       -- 1 if javac compile failed
  
 /** RXTRANSLATOR -- constructor, makes a new Translator instance
    */
 method RxTranslator()
  do protect this.getClass()
    if interpreter\=null then do
      say '+++ Sorry, only a single translator instance is permitted at present'
      signal IllegalStateException("Multiple translators not allowed")
      end
    end

  parse Date().toString() . mon day time . year .   -- get date and decompose it
  starttime=day.toint()+0 mon year time             -- timestamp for output

  /*
   * Set up an initial temporary (dummy) program object and flags, to
   * provide a context for errors. */
  programlist=RxProgram[1]
  program=RxProgram(this, superflag, '')
  programlist[0]=program

  /*
   * Set up the default imports list
   * Temporary: later we will have per-language imports
   *            [or shared + per-language]
   */
  
  /*
   * this interface did not allow import of a single package -
   * importing a package branch will now require a "." at the end like in the import statement
   * this way the base swing package can now be added    --issue #61--Kermit
   */
  
  imports=[String 'netrexx.lang.',-
          'java.lang.', 'java.io.',   'java.net.',-
          'java.util.', 'java.awt.',  'java.applet.', 'javax.swing']
  
  return
  
  -- 2015.05.02 switch javac use to jsr199 java compiler api per issue #90 -- KK -- Kermit
  
  method setkeeps(k1,k2,cl=java.util.List,javac1,ecj1)
    keep=k1
    keepasjava=k2
    classlist=cl
    javac=javac1
    ecj=ecj1

  method setaddress(address1)
    address=address1
 


  /** -------------------------------------------------------------- */
    /* SETLANGUAGES -- set language-specific constants                */
    /* Arg1 is an array of prefixes of known ZzBabel classes          */
    /*      e.g., ['Nr', 'Bx'].                                       */
    /* returns 1 if successful (all languages found), 0 otherwise     */
    /* This must be called before TRANSLATE                           */
    /* -------------------------------------------------------------- */
    /* The prefixes array (which must contain at least one element)   */
    /* lists the supported languages for this run.                    */
    /* If more that one language is provided, then the language for   */
    /* a program is determined by its file extension; if there is no  */
    /* file extension then the default extensions are tried in the    */
    /* order defined in the prefixes array.                           */
    /*                                                                */
    /* Each prefix loads an RxBabel class, the key to hauling in      */
    /* all the other language-specific classes, eventually.  This is  */
    /* the only dynamic load; it prevents all translators being       */
    /* loaded and also allows subsets of languages to be distributed. */
    
  method setlanguages(prefixes=Rexx[]) returns boolean
    packagename =Rexx           -- where to look for Babels
    ourname=Rexx RxTranslator.class.getName()
    packagename=ourname.left(ourname.length().toint()-13)
    babels=RxBabel[prefixes.length]
    loop b=0 for prefixes.length
      /* Construct an object of the ZzBabel class [where Zz is the
	 prefix for a given language] */
      bclass=Class.forName(packagename'.'prefixes[b]'Babel')
      -- find the constructor that takes one of us as an argument
      bcons=bclass.getConstructor([RxTranslator.class])
      -- and invoke it, with us as parent
      babels[b]=RxBabel bcons.newInstance([Object this])
    catch Exception
      return 0
    end
    return 1
    
  /**
   * TRANSLATE -- translate one or more program files or sources 
   * Arg1 is an array of flagwords (-xxx)
   * Arg2 is either an array of at least one filename or an array
   *         of at least one RxSource
   * Arg3 is the console file to use [null if not required]
   * Arg4 is the log file to use [null if not required]
   * Arg5 is 1 if we can assume no interpretation will happen
   * returns 1 if translation was OK (no errors)
   *
   * Arg3 and Arg4 are assumed checked.  If an error occurs while
   * writing either, we assume the environment handles (as they are
   * both Print streams).  Similarly, it is the responsibility of
   * the caller to create and close the files.  Errors in the log
   * file may be checked by calling checkError.
   * This is a multi-pass pseudo-parallel process; we do each phase
   * on all files before proceeding to the next phase, so cross-
   * references can be resolved.
   */
    
    -- The next line is the historical 'filenames only' method
  method translate(flags=Rexx[], files=Rexx[],-
                   con=PrintStream System.out, log=PrintWriter null,-
                   noexec=boolean 0) returns boolean
    savecon=con                      -- save
    savelog=log                      -- ..
    wontexec=noexec                  -- ..
    ok=checkflags(flags)             -- sets superflag from flags, shows logo
    if files.length=0 then
      do
	-- next message is really an internal error now
	RxQuit(this, null, 'no.file.specifications')
	ok=0
      end
    else sources=RxSource[files.length]
    
    --  make a source for each file
    if ok then loop f=0 for files.length
    reader=RxFileReader(this)
    reader.openfile(files[f])      -- locate and open the file
    sources[f]=reader              -- save to pass on
    
    name=reader.getName()
    path=reader.getPath()
    if f>0 then loop ff=0 for f
    if sources[ff].getName()==name then
      if sources[ff].getPath()==path then
	do
	  if path\=null then name=path||name
	  RxQuit(this, null, 'duplicate.program', name)
	  ok=0
	end
   end ff
  catch RxQuit                     -- abandon if failed
    ok=0
    end f

  if \ok then do
    showpendings()
    programlist=RxProgram[0]       -- inhibit any compiles
    return 0
    end
  return dotranslate(sources)

 method translate(flags=Rexx[], sources=RxSource[],-
                  con=PrintStream System.out, log=PrintWriter null,-
                  noexec=boolean 0) returns boolean
  savecon=con                      -- save
  savelog=log                      -- ..
  wontexec=noexec                  -- ..
  ok=checkflags(flags)             -- sets superflag from flags, shows logo
  if sources.length=0 then do
    -- next message is really an internal error now
    RxQuit(this, null, 'no.sources')
    ok=0
    end
  if \ok then do
    showpendings()
    programlist=RxProgram[0]       -- inhibit any compiles
    return 0
    end
  return dotranslate(sources)

 /* ----- Common routine to actually translate ----- */
 method dotranslate(sources=RxSource[]) returns boolean private

  programs=sources.length     -- number of programs we'll need

  /* Ready for class process initialization (or reset) */
  -- we delayed this until now so messages have context; on second and
  -- subsequent times we can re-use; skip if already hopeless
  if classer=null then do          -- reusable on second time
    -- this can fail if (say) a corrupted zip/jar file
    classer=RxClasser(this, imports) -- make a class manager
   catch RxQuit
    showpendings()                 -- display pending messages
    programlist=RxProgram[0]       -- inhibit any compiles
    return 0
    end
   else do                         -- second or subsequent translate
    -- classer may be reusable, but local classes, etc., are not
    classer.discardlocals()
    classer.cleanlookaside()
    end

  /* Set up the shared factories */
  -- These may become per-program later, for multiple languages
  -- We allow for RxQuits from the factories [currently none]
  do
    interpreter=RxInterpreter(this)-- needed for stringValue of constants
    converter  =RxConverter(this)  -- make a converter [used by following]
    tparser    =RxTermParser(this) -- make a term parser
    eparser    =RxExprParser(this) -- make an expression parser
  catch RxQuit                     -- abandon if these failed
    showpendings()                 -- display pending messages
    programlist=RxProgram[0]       -- inhibit any compiles
    return 0
  end
  proxyInterpreter=interpreter     -- make publicly accessible

  /* Set up a program object for each source, with a copy of the flags,
     the designated source, and other factories it needs */
  programlist=RxProgram[programs]
  loop f=0 for programs
    newflag=RxFlag(superflag)      -- clone the master copy
    program=RxProgram(this, newflag, sources[f].getName())
    programlist[f]=program
    program.source=sources[f]
    setlanguage(program)           -- determine the language

    -- make the output manager for the program
    program.streamer=RxStreamer(this, program)
    -- open output files, with names based on the source name
    program.streamer.openfiles(null,null,null)
    if program.flag.model>0 then do
      program.model=RxModel(program)    -- make a model
    end

    program.programname=program.source.getName() -- save cleaned-up name
    program.clauser=RxClauser(this)-- make a tokenizer [primes the pump]
    program.tracer=RxTracer(this)  -- make a tracer
    program.parser=RxParser(this)  -- make a parser
    program.pooler=RxVarpool(this) -- make a variable pool manager
  catch RxQuit                     -- abandon if any failed
    showpendings()                 -- display pending messages
    programlist=RxProgram[0]       -- inhibit any compiles
    return 0
    end f

  /* new/reset history of warnings */
  deprecateds=Hashtable(5)

  /* -------------------------------------------------------------- */
  /* Pass 0                                                         */
  /* -------------------------------------------------------------- */
  pass=0; pass0=1
  loop f=0 for programs
    program=programlist[f]              -- set current program
    do
      if program.flag.diag then say '# --- pass 0 ---' program.programname
      if program.flag.verbose>3 then
        say('Translating '''program.programname''' [Pass 0]')
      program.parser.parseprogram()       -- process pass 0
    catch RxQuit
      program.abandon=1
      end
    end f

  -- now the 'pass 0.5' for each program.  This completes the CLASS
  -- instructions for each, which may make forward references to classes
  -- later in the same program .. or in a later program
  loop f=0 for programs
    program=programlist[f]              -- set current program
    if \program.abandon then do
      if program.flag.diag then say '# --- pass 0+ ---' program.programname
      program.parser.crossclass()         -- process cross-class
    catch RxQuit
      program.abandon=1
      end
    end f

  pass0=0      -- done

  /* -------------------------------------------------------------- */
  /* Pass 1                                                         */
  /* -------------------------------------------------------------- */
  pass=1; pass1=1
  hadexit=0                                  -- no exit yet
  loop f=0 for programs
    program=programlist[f]                   -- set current program
    if \program.abandon then do
      if program.flag.diag then say '# --- pass 1 ---' program.programname
      if program.flag.verbose>3 then
        say ('Translating '''program.programname''' [Pass 1]')
      program.parser.parseprogram()            -- process pass 1
    catch RxQuit
      program.abandon=1
      end
    end f

  -- now the 'pass 1.5' for each program.
  loop f=0 for programs
    program=programlist[f]                   -- set current program
    if \program.abandon then do
      if program.flag.diag then say '# --- pass 1+ ---' program.programname
      program.parser.crossclass()              -- process cross-class
    catch RxQuit
      program.abandon=1
      end
    end f

  pass1=0      -- done

  /* -------------------------------------------------------------- */
  /* Pass 2                                                         */
  /* -------------------------------------------------------------- */
  pass=2; pass2=1
  loop f=0 for programs
    program=programlist[f]                   -- set current program
    if program.flag.verbose>0 then do label noise
      suffix=''
      if program.flag.verbose>3 then do
        if program.parser=null then clauses=0
         else clauses=program.parser.clauses() -- for interest only
        if clauses=0 then add=''
         else if clauses=1 then add=', over one clause'
         else add=', over' clauses 'clauses'
        if program.flag.test then suffix='test, '
        suffix=' ['suffix'pass 2'add']'
        end
       else if program.flag.test then suffix=' [test]'
      if babels.length>1 then suffix=suffix program.babel.getName()
      say('Program' program.programname||suffix)
      end noise

    showpendings()                      -- display pending messages

    if \program.abandon then do
      if program.flag.model>0 then program.model.process()
      if program.flag.diag then say '# --- pass 2 ---' program.programname
      program.parser.parseprogram()       -- process pass 2
      if program.flag.java then         -- if generating Java ..
        program.streamer.outwrite()       -- .. write output file, with insertions
    catch RxQuit
      program.abandon=1
      end

    -- unless we will interpret (and so may have tracing, error messages,
    -- etc.) we no longer need the source cache, so let it go now
    if wontexec then if program.source\=null then
     if program.source<=RxFileReader then
      (RxFileReader program.source).recover()
    -- certainly done with output files [if any]
    if program.streamer\=null then program.streamer.closefiles()
    end f

  pass2=0      -- done

  /* No longer need some makers [allow GC]; also count errors */
  ok=boolean 1
  loop f=0 for programs
    program=programlist[f]              -- set current program
    if program.abandon then ok=0        -- hopeless
    program.parser=null                 -- [should be OK now]
    program.tracer=null
    -- streamers are needed in Compile
    end f
  return ok

 /* -------------------------------------------------------------- */
 /* STARTEXEC -- prepare for interpretation                        */
 /* -------------------------------------------------------------- */
 method startexec
  pass=3; exec=1

  -- we need 1.2 or better for exec
  do label testlevel
    jversion=Rexx(System.getProperty('java.version'))
    parse jversion maj '.' myn
    if maj.OpGt(null, Rexx('1')) then leave testlevel -- 2.x OK
    if maj.OpLt(null, Rexx('1')), myn.OpLt(null, Rexx('2')) then do
      RxQuit(this, null, 'exec.needs.java.1.2')
      return
      end
    end testlevel

  if program.flag.diag then say '# ===== define proxies ====='

  /* Load the proxies, and remember their packages */
  -- start with a clean proxy loader (if we don't use our own
  -- proxyloader then we won't be able to clean out classes)
  loader=RxProxyLoader(this)            -- chain in proxy loader
  localpackages=Hashtable(5)            -- clean collection
  loop c=1 by 1
    info=classer.findclassbyid(c)
    if info=null then leave
    loader.loadClass(info, 1)           -- load the class
    localpackages.put(info.packname, info.packname) -- record package
    end

  return

 /* -------------------------------------------------------------- */
 /* ENDEXEC -- interpretation done                                 */
 /* -------------------------------------------------------------- */
 method endexec
  exec=0

 /* -------------------------------------------------------------- */
 /* EXEC -- execute the first class in the first program           */
 /* -------------------------------------------------------------- */
 method exec(args=String[] null)
  startexec()

  program=programlist[0]
  if program.abandon then return
  if program.errorcount>0 then return

  -- set up the arguments string array
  if args=null then args=String[0]
  argcodes=RxCode[1]
  argcodes[0]=RxCode(RxCode.S_LIT, RxType.STRINGARRAY_TYPE, null)
  argcodes[0].value=args

  thisclass=RxClass program.classes.elementAt(0)
  if program.flag.verbose>0 then
    say '===== Exec:' thisclass.classinfo.fullname '====='

  /* Now check for the static main method in the current class */
  argtypes=RxType[1]
  argtypes[0]=RxType.STRINGARRAY_TYPE
  field=classer.findfield(null, 1, 1, 0, 1, thisclass.classinfo,-
                          'main', argtypes, null)
  select label finals
    when field=null then RxQuit(this, null, 'no.main.method',-
                                thisclass.classinfo.fullname)
    when field.fieldtype\=RxType.VOID_TYPE then RxQuit(this, null, 'no.main.method')
    otherwise do
      -- say ': found main'
      interpreter.callMethod(null, field, argcodes, null)
      -- say ': done  main'
    catch s=RxSignal
      signalobj=s.signalobj
      if signalobj=null then leave finals  -- signal was Exit request
      realexcep=Throwable signalobj
      say('===== Exception running class' thisclass.classinfo.fullname':'-
           realexcep.toString() '=====')
      if program.flag.test then realexcep.printStackTrace()
      s.showFrames(this)
      end
    catch RxError
      -- don't set program.abandon .. compile may still be wanted,
      -- and/or .java file need renaming
      -- Exception("# RxError traceback:").printStackTrace
    catch RxQuit
      -- don't set program.abandon .. compile may still be wanted,
      -- and/or .java file need renaming
      -- Exception("# RxQuit traceback:").printStackTrace
    finally do
      -- we called main; now wait to be single-user-threaded, or exit to
      -- be raised.  Polling is really our only option, as some threads
      -- will live forever until exit
      -- ourthread=Thread.currentThread
      loop forever
        active=Thread.activeCount()
        threads=Thread[active]
        exist=Thread.enumerate(threads)
        userthreads=0
        alive=0
        loop i=0 for exist
          t=threads[i]
          if \t.isDaemon() then do
            userthreads=userthreads+1
            if t.isAlive() then alive=alive+1
            end
          end
        if userthreads=1 then leave          -- simple enough
        if \hadexit then leave               -- no exit to wait for
        -- say '# user, alive:' userthreads alive
        Thread.sleep(100)                    -- pause 0.1s
        if exiting then leave
        end
      catch InterruptedException
        nop     -- just leave
      end -- finally
    end finals

  endexec()                                    -- done
  exec=0
  return

 /* -------------------------------------------------------------- */
 /* COMPILE -- compile any java files                              */
 /* Arg1 is 1 to keep the java file after successful compilation   */
 /*           (normally it is erased if the compile was successful)*/
 /* Arg1 is 1 to ask for optimization [no longer implemented]      */
 /* returns 1 if compilation was OK (no errors on input either)    */
 /* -------------------------------------------------------------- */
 /* [1997.07.30] revised to javac all in parallel                  */
  method compile(opt=boolean 0) returns boolean
    pass=4; comp=1
    programs  =programlist.length
    compileok =boolean (programs>0)       -- OK, so far, to run javac
    hadsymbols=boolean 0                  -- 'symbols' requested
    haddiag   =boolean 0                  -- 'diag' requested
    hadnojava =boolean 0                  -- 'nojava' requested
    maxverbose=int 0                      -- maximum verbosity

    -- take note if any failed .. if they did, don't run javac on any
    -- note SYMBOLS request, too.
    loop f=0 for programs
      program=programlist[f]                   -- current program
      if program.errorcount>0 then compileok=0 -- Not good
      if \program.flag.java   then hadnojava=1 -- no Java generated
      if program.flag.symbols then hadsymbols=1
      if program.flag.diag    then haddiag=1
      if program.flag.verbose>maxverbose then maxverbose=program.flag.verbose
    end f

    if compileok then if \hadnojava then do label havejava
      -- we have valid java for all
      compilerChoice = System.getProperty("nrx.compiler","javac")
      parse compilerChoice compilerChoice javaoptions
      if compilerChoice\=="javac" & compilerChoice\=="ecj" then do
	compilerChoice="javac"
	javaoptions=System.getProperty("nrx.compiler","javac")
      end
      if javac then compilerChoice="javac"
      if ecj then compilerChoice="ecj"
      -- build the ARGS array
      if hadsymbols then do
	args=String[programs+4]
	args[3]='-g'                      -- symbols table, please
      end
      else
	args=String[programs+3]
      args[0]='-nowarn'                   -- both paths
      args[1]='-classpath'                -- explicit classpath needed
      args[2]=classpath                   -- .. for Java 1.2 javac
					  -- add the filenames
      jfoarray=JavaFileObject[programs]	  -- Java compiler API	-- KK -- 2015.05.02

      optstring='-nowarn -classpath classpath' javaoptions
      optarray=optstring.toString().trim().split(" ")
      optarray[2]=classpath

      offset=args.length-programs
      loop f=0 for programs
	program=programlist[f]            -- current program
	args[f+offset]=program.streamer.outfilefull
	parse program.programname firstname '.' .	
	jfoarray[f]=RxInMemoryJavaFileObject(firstname.toString(), -
					     program.streamer.byteoutstream.toString())
      catch cle=Exception
	say cle
      end f
      if maxverbose>3 then say('Compiling: '''Rexx(args)'''')
      else if haddiag then say '# Compiling:' Rexx(args)

      if program.flag.diag then do    	
	thisloader=Thread.currentThread().getContextClassLoader()
	say "Thread context classloader="thisloader
	loop while thisloader.getParent()\=null
	  thisloader=thisloader.getParent()
	  say "   parent loader="thisloader
	end
	thisloader = this.getClass().getClassLoader()
	say "current loader="thisloader
	loop while thisloader.getParent()\=null
	  thisloader=thisloader.getParent()
	  say "   parent loader="thisloader
	end
      end

      javaloader=Thread.currentThread().getContextClassLoader()
      do
	javacompiler=javax.tools.ToolProvider.getSystemJavaCompiler()
        toolman= javaloader.loadClass('com.sun.tools.javac.api.JavacTool')
      catch e=Exception
      end   	
      do
	ecjclass=javaloader.loadClass('org.eclipse.jdt.internal.compiler.tool.EclipseCompiler')
      catch e=Exception
      end

      if compilerChoice == "javac" then
	if toolman==null & javacompiler=null then
      	  do
      	    compilerChoice="ecj"
      	    if program.flag.diag then say "no javac compiler - switching to ecj (Eclipse) compiler"
	  end
	
	if compilerChoice == "ecj" then
      	  if ecjclass==null then
      	    do
	      if program.flag.diag then say "no ecj compiler"
	      if toolman\==null | javacompiler\==null then if program.flag.diag then say "switching to javac compiler"
	      compilerChoice="javac"
	    end
	
	  if compilerChoice == "javac" then if toolman==null & javacompiler=null then
	    RxQuit(this, null, 'compiler.specification.error')
	  if toolman\==null, ecjclass\==null, javacompiler\==null then
	    select
	
	      when compilerChoice == "javac" then do
		if program.flag.diag then say '# compiling' program.programname 'using javac'
		do
		  if javacompiler==null then
		    javacompiler=JavaCompiler toolman.newInstance()
		  if javacompiler==null then javacok=boolean 0 -- compile failed
		  else do
		    -- make file manager to capture class files in memory
		    fileManager = RxForwardingJavaFileManager( -
							      JavaFileManager javacompiler.getStandardFileManager(null, null, null))
		    -- run the Java compiler on the memory strings
		    javacok=javacompiler.getTask(null,-
						 fileManager,null,Arrays.asList(optarray),-
						 null,-
						 Arrays.asList(jfoarray)).call().booleanValue()
		  end
		  /*
		     For the record, here are the javac exit codes:
		     static final int
		     EXIT_OK = 0,        // Compilation completed with no errors.
		     EXIT_ERROR = 1,     // Completed but reported errors.
		     EXIT_CMDERR = 2,    // Bad command-line arguments
		     EXIT_SYSERR = 3,    // System error or resource exhaustion.
		     EXIT_ABNORMAL = 4;  // Compiler terminated abnormally
		   */
		catch cle=Exception
		  say cle
		end
	      end
	
	      when compilerChoice == "ecj" then do
		if program.flag.diag then say '# compiling' program.programname 'using eclipse batch compiler'
		do
		  ecjclass=javaloader.loadClass('org.eclipse.jdt.internal.compiler.tool.EclipseCompiler')
		  javacompiler=JavaCompiler ecjclass.newInstance()
		  -- make file manager to capture class files in memory
		  fileManager = RxForwardingJavaFileManager(JavaFileManager javacompiler.getStandardFileManager(null, null, null))
		  -- run the Java compiler on the memory strings
		  
		  javacok=javacompiler.getTask(null,-
					       fileManager,-
					       this.diagListener(),-
					       Arrays.asList(optarray),-
					       null,-
					       Arrays.asList(jfoarray)).call().booleanValue()
		catch cle=Exception
		  say cle
		end
	      end
	
	      otherwise
		RxQuit(this, null, 'compiler.specification.error')
	    end
	
	  if haddiag then say '# Compiled: ok='javacok
	  badjavac=\javacok
	
	  /* persist any .class files that javac made for each file */
	  /* [If javac failed we assume no new .class files were generated.] */
	  if javacok then -
	     loop f=0 for programs
	       program=programlist[f]                 -- current program
	
	       persister=RxPersistClass(program.source.getName(),'.',this)  -- make a persister
	       loop c=0 for program.classes.size()
		 -- build the filename
		 theclass=RxClass program.classes.elementAt(c)
		 -- name is the full name of the class, with dollars for dots
		 localclass=Rexx(theclass.classinfo.fullname).translate('$', '.')'.class'
		 -- it will be in the current directory
		 dir=program.source.getPath()
		 if dir=null then actualclass=localclass
		 else actualclass=dir||localclass
		 -- if SOURCEDIR specified, then we want it in the source
		 -- directory, otherwise it goes in the current directory
		 if program.flag.sourcedir then targetclass=actualclass
		 else targetclass=localclass
		 --          if program.flag.diag then say '# Fixing' actualclass-
		 --           'to' targetclass '['program.flag.sourcedir']'
		
		 /* here the compileroutput, in the form of class images in memory, is persisted to files */
		 fmi=fileManager.classFileObjects.iterator()
		 loop while fmi.hasNext()
		   tba=RxByteArrayJavaClass fmi.next()
		   persistClass=''
		
		   if compilerChoice = 'ecj' then
		     do
		       tempcls = (Rexx tba.getName().substring(1)".class")
		       lastslash = tempcls.lastpos('/')+1
		       targetclass = tempcls.substr(lastslash)
		       if dir<>null then actualclass = dir||targetclass
		       else actualclass = targetclass
		       if program.flag.sourcedir then targetclass=dir||targetclass
		       lastslash=(Rexx tba.getName()).lastpos('/')
		       persistClass=Rexx(tba.getName().substring(lastslash)".class")
		     end -- if do
		   if compilerChoice = 'javac' then
		     do
		       tempcls = (Rexx tba.getName().substring(1))
		       lastdot= tempcls.lastpos('.')+1
		       persistClass=Rexx(tba.getName().substring(lastdot)".class")
		     end -- if do
		   if persistClass = localclass  then do
		     persister.persist(actualclass, targetclass, tba.getBytes())

		     if classlist\==null then do
		       tba.stream=ByteArrayOutputStream(1024)
		       tba.stream.write(byte[] classlist.remove(classlist.size()-1))
		       -- 	pass the fileobject back to the caller as requested		
        	       classlist.add(tba)
		     catch cle=Exception
		       say cle
		     end
		   end
		 end
               end c
	     end f
	
	  if javacok then -
	     if classlist\==null then do
	       /* now build a special class loader for the class files in memory */
	       byteCodeMap = HashMap()
	       fmi=fileManager.classFileObjects.iterator()
	       loop while fmi.hasNext()
		 tba=RxByteArrayJavaClass fmi.next()			
		 byteCodeMap.put(tba.getName().substring(1), tba.getBytes())
		 --	why does first char of name have to be discarded? - URI trick
	       end
	       classlist.add(0,RxMapClassLoader(byteCodeMap))
	     end
	
    end havejava

    comp=0
    return compileok & \badjavac

    /* --------------------------------------------------------------- */
    /* DISPOSE -- dispose of .java files and close source              */
    /*            This must always be called to clean up.              */
    /* --------------------------------------------------------------- */
    /* Arg1 is 1 to keep the java file after successful compilation    */
    /*           (normally it is erased if the compile was successful) */
  method dispose(keep1=boolean, keepasjava1=boolean 0)

    loop f=0 for programlist.length
      program=programlist[f]                        -- current program
						    -- we done with the source, now (if not already)
      if program.source\=null then program.source.close()

      -- rename or erase the (.java) source file
      select
	when keep1 & program.errorcount=0 then erase=boolean 0
	when badjavac then erase=boolean 0
	otherwise erase=1
      end
      if keep1 then				-- 2015.06.11 -- if using jsr199 to pass java code and no java output, don't touch disk files
	program.streamer.disposeoutputfile(erase, keepasjava1)
    end f

    /* --------------------------------------------------------------- */
    /* SUMMARY -- display summaries as needed                          */
    /* --------------------------------------------------------------- */
    /* Arg1 is 1 if we had interpretation */
  method summary(hadexec=boolean)
     bucket=Rexx""
    /* Summaries, one per program */
    loop f=0 for programlist.length
      program=programlist[f]                        -- current program
      if program.flag.verbose>0 then do label summary
	add=''; ok=1
	if program.classes.size()>1 then add=program.classes.size() 'classes'
	if badjavac then do
          if add\=='' then add=add', '
          add=add||NrAnsi.ANSI_RED'javac failed'NrAnsi.ANSI_RESET
          ok=0   -- failed
        end
	if program.errorcount>0 then do
          if add\=='' then add=add', '
          if program.errorcount=1 then add=NrAnsi.ANSI_RED||add'one error'NrAnsi.ANSI_RESET
          else add=add||NrAnsi.ANSI_YELLOW' 'program.errorcount' 'NrAnsi.ANSI_RED'errors'NrAnsi.ANSI_RESET
          ok=0   -- failed
        end
	if program.warncount>0 then do
          if add\=='' then add=add', '
          if program.warncount=1 then add=add||NrAnsi.ANSI_BLUE'one warning'NrAnsi.ANSI_RESET
          else add=add||NrAnsi.ANSI_YELLOW' 'program.warncount' 'NrAnsi.ANSI_BLUE'warnings'NrAnsi.ANSI_RESET
        end
	if add\=='' then add=' ['add']'
	inname=NrAnsi.ANSI_YELLOW||program.programname||NrAnsi.ANSI_RESET
	
	if hadexec then do
          action='Processing'
          okresult='complete'
        end
	else do
          action='Compilation'
          okresult='successful'
        end

	if ok then bucket[f]=action||" of \'"inname"\' "okresult||add
        else bucket[f]=action||" of \'"inname"\' failed"||add
      end summary

    end f
    faulty=Rexx ""
    x=0
    loop skim=0 for programlist.length
      if bucket[skim].lastpos("successful")\=0 then do
        say bucket[skim]
      end
  else do
    x=x+1
    faulty[x]=bucket[skim]
    faulty[0]=x
  end
    end
    if faulty.exists("1") then do
      loop review=1 to faulty[0]
	if faulty[review] <> "" then say faulty[review]
      end
    end
    return


    /* showpendings -- show any pending messages */
  method showpendings private
    loop m=0 for program.pendings.size()
      say(Rexx program.pendings.elementAt(m))
    end m
    program.pendings.removeAllElements()         -- clear shown messages
						 -- [.clear is JDK 1.2]

    /* getstarttime -- return the 'start translate' time */
  method getstarttime returns Rexx
    return starttime

    /* getexitvalue -- return 'worstcase' exitvalue */
  method getexitvalue returns int
    if programlist=null then return EXIT_ERROR -- failed before Translate
    programs=programlist.length
    if programs=0 then return EXIT_ERROR       -- failed before programs
    if badjavac   then return EXIT_ERROR       -- hopeless
    warns=0
    loop f=0 for programs
      program=programlist[f]                   -- current program
      if program.abandon-
	 | program.errorcount>0 then return EXIT_ERROR
      warns=warns+program.warncount
    end
    if warns>0 then return EXIT_WARN
    return EXIT_OK

    /* setlanguage -- determine and setup program's language
       Arg1 is the program
     */
  method setlanguage(prog=RxProgram) private
    /* Find the name stub and extension for the program */
    infile=Rexx prog.source.getName()
    lastdot=infile.lastpos('.').toint()
    if lastdot\=0 then do -- determine the language for the program
      inext=infile.substr(lastdot+1)
      loop b=0 for babels.length
	babel=babels[b]
	ext=babel.getExtension()
	if ext.OpEq(null, inext) then /* extension match */ do
          program.babel=babel
          leave b
      end
    end b
end
-- If no extension, or no match found, assume the primary language
if program.babel=null then program.babel=babels[0]
-- say '#' infile '--is--' program.babel.getName
return

/* checkflags -- check flags given, and display banner accordingly
   Arg1 is the array of flag words
 */
  method checkflags(flags=Rexx[]) returns boolean private
    -- Process any flags, building the prototype flag object
    ok=boolean 1
    loop f=0 for flags.length
      flagword=flags[f]
      if flagword.left(1)=='-' then flagword=flagword.substr(2)
      if \superflag.setFlag(flagword) then do
	RxQuit(this, null, 'unknown.command.option', flagword)
	ok=0
      end
    end

    /* Banner-time [had to wait for flags to be processed] */
    if superflag.verbose>0 then if superflag.logo then do
      if this.getClass().getPackage()\=null then vv=this.getClass().getPackage().getImplementationVersion()
      else vv=''
      if vv=null then vv=''
      parse vv . . . vv
      banner=NrAnsi.ANSI_YELLOW||babels[0].getName() 'portable processor'NrAnsi.ANSI_RESET NrAnsi.ANSI_BLUE||babels[0].getFullVersion()||NrAnsi.ANSI_RESET vv
      if superflag.verbose<=3 then say(banner)
      else say(banner ' ['RxProcessor.procdate']')
      say(RxProcessor.copyright)
    end

    if superflag.diag then superflag.format=1  -- diag wants to look pretty
    return ok

    /* say -- all (non-diag) compiler displays must come through here */
  method say(what=Rexx '')
    if savecon\=null then savecon.println(what)
    if savelog\=null then do
      savelog.println(what)
      if savelog.checkError() then savelog=null       -- give up if error
    end
    return

    /* return the first program, for out-of-context babelization */
  method getProgram returns RxProgram
    return programlist[0]

  method main(s=String[]) static
    say '??'

class RxTranslator.diagListener implements javax.tools.DiagnosticListener dependent
  method report(s=Diagnostic)
    s.getMessage(null)
