/* IBM Materials Licensed under International Components for Unicode  */
/* Licence version 1.8.1 (ICU Licence) - Property of IBM              */
/* IBM NetRexx                                                        */
/* Copyright (c) 1995-2009 IBM Corp.                                  */
/* Copyright (c) 2011- RexxLA                                         */
/* ------------------------------------------------------------------ */
/* Venta language processor                                       mfc */
/* Copyright (c) IBM Corporation 1999, 2000.  All Rights Reserved.    */
/* ------------------------------------------------------------------ */
/* RxInterpreter                                                      */
/*                                                                    */
/*   The interpreter object.                                          */
/*                                                                    */
/*   This takes requests (equivalent to execution requests in         */
/*   java.lang.reflect) and executes them, either using the           */
/*   reflection API or using direct interpretation for local          */
/*   classes.                                                         */
/*                                                                    */
/*   All calls to java.lang.reflect will eventually come through      */
/*   here.                                                            */
/*                                                                    */
/*   Values of argument lists, etc., are Venta-style (RxCode          */
/*   objects) rather than java.lang.reflect style.                    */
/*                                                                    */
/* ------------------------------------------------------------------ */
/* Change list (see RxLanguage for master change list)                */
/* 1999.10.20 Initial                                                 */
/* 2000.02.19 Revise for multi-level variable pools                   */
/* 2000.02.21 Merge callConstructor into callMethod, and implement;   */
/*            complete getProperty; propagate binary                  */
/* 2000.02.24 Level stack management                                  */
/* 2000.02.28 Invoke synthetic local methods                          */
/* 2000.02.29 Add PROTECTion                                          */
/* 2000.03.14 Begin proxy work                                        */
/* 2000.04.02 Integrated proxy                                        */
/* 2012.09.19 allow initialization of constant fields in Java 5+      */
/*                                               per issue #80 -KK-   */
/* 2020.12.20 MRE -- catch exception when class modifier fields       */
/*                                              are accessed in JDK9+ */
/* 2022.06.16 Interactive trace assign and say implementation --MRE   */
/* ------------------------------------------------------------------ */
-- Most of this is language-independent.  See RUNFREE for the NetRexx-
-- specific code; this could be moved out.
package org.netrexx.process
--options binary nodecimal strictcase strictargs
options binary decimal strictcase strictargs

/* ------------------------------------------------------------------ */
/* Proxies:  [2000.03.14]                                             */
/*                                                                    */
/* Each local class (synthetic class) has a real proxy class loaded   */
/* for it.  The proxy class forms instances and holds properties      */
/* during interpretation.                                             */
/*                                                                    */
/* Calls to methods in proxy classes (including static and            */
/* instance initializers) are routed through to the Interpreter       */
/* object to one of two methods:                                      */
/*                                                                    */
/*  callMethod  -- for invoking constructor bodies and methods        */
/*              -- for gathering arguments to super() and this()      */
/*                 calls ('precall')                                  */
/*  proxyInit   -- for static initialization                          */
/*                                                                    */
/* Proxies are currently only set up during interpretation.  Later    */
/* we could use them in normal pass2 processing.                      */
/* ------------------------------------------------------------------ */
/* Exiting:  [2000.04.12]                                             */
/*                                                                    */
/* Java event dispatching gets upset if an exception is seen while    */
/* it is busy.  Therefore we cannot use RxSignal to pass our exit     */
/* event transparently up the call chain through proxies.  Instead,   */
/* we simply set the 'exiting' bit which means that any attempt to    */
/* interpret local code is immediately ended; within local code we    */
/* use the signal mechanism to cleanly terminate nesting.             */
/*                                                                    */
/* In general, a signal during event dispatching is unpleasant.       */
/* ------------------------------------------------------------------ */
--trace methods
class RxInterpreter uses NrLevel, RxCursor, RxVariable

 properties shared
  rxt=RxTranslator            -- the usual

 -- no private properties; this is a factory, and callMethod is called
 -- recursively

 properties constant private
  int0=Integer(0)             -- default initial values
  long0=Long(0)               -- ..
  dub0=Double(0)              -- ..
  char0=Rexx('\0')            -- ..
  nojump=RxClause()           -- used to indicate 'no jump needed'

 /** General Constructor */
 method RxInterpreter(translator=RxTranslator)
  rxt=translator

 /** INITIALIZEPROPERTIES -- initialize static or instance variables
    Arg1 is the local class
    Arg2 is null for class (static) initialize, this for instance initialize

    This runs the class clauses either statically or not; assignments
    are only run if they of the correct staticality (as determined by
    the current property attributes).

    Note that we cannot use the current (method) cursor here, for
    instance initialize, because it indicates we're in a method.
    */
 method  initializeProperties(localclass=RxClass, curthis=Object) private
  -- quick exit if nothing to do ...
  if localclass.classclauses=null then            -- no clauses to run
   if localclass.classprogram.pendtrace.size()=0 then -- .. and no pending TRACEs
   if localclass.classprogram.pendnumeric.size()=0 then return -- .. and no pending NUMERICs

  isstatic=(curthis=null)
  -- make initialization cursor
  cursor=RxCursor(localclass.classprogram, localclass, null, null)
  cursor.curexec=1                           -- active execution please
  cursor.curbinary=localclass.classbinary    -- this applies to properties
  cursor.curstatic=isstatic                  -- assign statics only please
  cursor.curthis=curthis                     -- context object

  program=cursor.curprogram
  if program.flag.diag then do
    if isstatic then what='static'; else what='instance'
    say '#' what 'Initialize class:' localclass.classname
    end

  -- interpret any pending numerics
  loop n=0 for program.pendnumeric.size()
    cursor.curclause=RxClause program.pendnumeric.elementAt(n)
    numer=NrNumeric cursor.curclause.lookaside
    numer.interpret(cursor)
    end n
  -- if static, then interpret any pending traces, too
  if cursor.curstatic then loop n=0 for program.pendtrace.size()
    cursor.curclause=RxClause program.pendtrace.elementAt(n)
    trace=NrTrace cursor.curclause.lookaside
    trace.interpret(cursor)
    end n

  -- In this loop we interpret all NUMERICs and PROPERTIES, but
  -- TRACE only if static, and Assignments depending on their attributes
  clause=localclass.classclauses
  cursor.curpropatts=localclass.classpropatts -- initial PROPERTIES state
  loop label execute while clause\=null
    cursor.curclause=clause
    if clause.lookaside\=null then do label realclause
      clauseobj=clause.lookaside
      select
        when clauseobj<=NrAssign then do
          -- determine the current properties staticality
          propstatic=(cursor.curpropatts & (VAR_STATIC+VAR_CONSTANT))\=0
          -- if it doesn't match what we're doing, don't do the assignment
          if propstatic\=isstatic then leave realclause
          end
        when clauseobj<=NrTrace then do
          if \isstatic then leave realclause
          end
        otherwise
          nop            -- execute always
        end
      clauseobj.interpret(cursor)
      end realclause
    clause=clause.next
    end execute

 /** INITVALUE -- return initialization for a value in RxCode style
    Arg1 is the type to be initialized

    Also used for synthetic returns (in RxMethod), and S_TYPE
    expressions (in NrAssign).
    */
 method initvalue(type=RxType) returns Object
  if type.isPrimitive() then select
    when type=RxType.INT_TYPE    then return int0
    when type=RxType.BOOL_TYPE   then return int0
    when type=RxType.LONG_TYPE   then return long0
    when type=RxType.DOUBLE_TYPE then return dub0
    when type=RxType.BYTE_TYPE   then return int0
    when type=RxType.SHORT_TYPE  then return int0
    when type=RxType.FLOAT_TYPE  then return dub0
    when type=RxType.CHAR_TYPE   then return char0
    end
  return null

 /** STRINGVALUE -- return toString for a code's value in RxCode style
    Arg1 is the code whose value is to be converted to String
    */
 method stringvalue(code=RxCode) returns String
  if code.value=null then return null   -- [must do this for correct twoOpDo]
  if code.type.isPrimitive() then select
    when code.type=RxType.INT_TYPE    then return code.value.toString()
    when code.type=RxType.BOOL_TYPE   then return code.value.toString()
    when code.type=RxType.LONG_TYPE   then return code.value.toString()
    when code.type=RxType.DOUBLE_TYPE then return code.value.toString()
    when code.type=RxType.BYTE_TYPE   then return String.valueOf((Integer code.value).byteValue())
    when code.type=RxType.SHORT_TYPE  then return String.valueOf((Integer code.value).shortValue())
    when code.type=RxType.FLOAT_TYPE  then return String.valueOf((Double code.value).floatValue())
    when code.type=RxType.CHAR_TYPE   then return code.value.toString()
    end
  if code.value<=char[] then return String(char[] code.value)
  return code.value.toString()

 /** SIGNVALUE -- return the sign of a code's value
    Arg1 is the code to test.  It must be numerical or Rexx
    returns a negative int if the value is less than 0, 0 if equal to
    zero, or a positive integer if greater than zero
    */
 method signvalue(code=RxCode) returns int
  if code.value=null then signal NullPointerException('numeric value null')
  select
    when code.type=RxType.INT_TYPE    then return (Integer code.value).intValue()
    when code.type=RxType.BYTE_TYPE   then return (Integer code.value).intValue()
    when code.type=RxType.SHORT_TYPE  then return (Integer code.value).intValue()
    when code.type=RxType.BOOL_TYPE   then return (Integer code.value).intValue()
    when code.type=RxType.LONG_TYPE   then return (Long code.value).compareTo(long0)
    when code.type=RxType.DOUBLE_TYPE then return (Double code.value).compareTo(dub0)
    when code.type=RxType.FLOAT_TYPE  then return (Double code.value).compareTo(dub0)
    when code.type=RxType.CHAR_TYPE   then do
      cc=(Rexx code.value).tochar()
      if cc='0' then return 0
      if cc>'0' then if cc<='9' then return 1
      signal NumberFormatException(cc)
      end
    when code.type=RxType.REXX_TYPE then return (Rexx code.value).sign().toint()
    otherwise nop
    end
  signal NumberFormatException(code.value.toString())


 /** SETUPARGS -- set up argument arrays for field location
    Arg1 is the types array for the argument list
    Arg2 is the values array for the argument list (RxCode style)
    Arg3 is the classes array to be set for each argument
    Arg4 is the values array to be set for each argument
    Arg5 is the type of a parent object, or null if none
    Arg6 is the parent object
    This constructs the classes array and the object (values) array
      for the arguments, rewrapping primitives where necessary
      [The argcodes values will have been converted to the
      desired types by convertargs]
    */
 method setupArgs(types=RxType[], args=Object[],-
                  classes=Class[], oargs=Object[],-
                  ptype=RxType, pobj=Object) private
  if ptype=null then outadd=0      -- no shift of arguments
   else do
    outadd=1
    classes[0]=ptype.getClassObject(rxt.loader) -- get the Class for parent
    -- nect line doesn't really need to cal code2ref .. but clean
    oargs[0]=code2ref(pobj, ptype) -- rewrap value if necessary
    end

  loop i=0 for args.length
    type=types[i]
    classes[i+outadd]=type.getClassObject(rxt.loader) -- get the Class for type
    oargs[i+outadd]=code2ref(args[i], type)       -- rewrap value if necessary
    -- if program.flag.diag then
    -- say 'SUA:' i oargs[i+outadd].getclass type args[i].getclass ':'-
    --   classes[i+outadd]
    end i
  return

 /** CODE2REF -- modify value wrapper from RxCode to reflection style
    Arg1 is the object that may need rewrapping
    Arg2 is the underlying type of the object
    returns either the object unchanged, or rewrapped to match RxCode
    rules if necessary. */
 method code2ref(value=Object, rettype=RxType) returns Object
  if rettype.isPrimitive() then select
    when rettype=RxType.INT_TYPE    then nop
    when rettype=RxType.LONG_TYPE   then nop
    when rettype=RxType.DOUBLE_TYPE then nop
    when rettype=RxType.BYTE_TYPE then
      value=Byte((Integer value).byteValue())
    when rettype=RxType.SHORT_TYPE then
      value=Short((Integer value).shortValue())
    when rettype=RxType.FLOAT_TYPE then
      value=Float((Number value).floatValue())
    when rettype=RxType.BOOL_TYPE then
      value=Boolean((Integer value).intValue()=1)
    when rettype=RxType.CHAR_TYPE then
      value=Character((Rexx value).tochar())
    end
  return value

 /** REF2CODE  -- modify value wrapper from reflection to RxCode style
    Arg1 is the object that may need rewrapping
    Arg2 is the underlying type of the object
    returns either the object unchanged, or rewrapped to match RxCode
      rules if necessary. */
 method ref2code(value=Object, rettype=RxType) returns Object
  -- modify the wrapper of returned result, if necessary
  if rettype.isPrimitive() then select
    when rettype=RxType.INT_TYPE    then nop
    when rettype=RxType.LONG_TYPE   then nop
    when rettype=RxType.DOUBLE_TYPE then nop
    when rettype=RxType.BYTE_TYPE then
      value=Integer((Byte value).byteValue())
    when rettype=RxType.SHORT_TYPE then
      value=Integer((Short value).shortValue())
    when rettype=RxType.FLOAT_TYPE then
      value=Double((Float value).floatValue())
    when rettype=RxType.BOOL_TYPE then do
      if (Boolean value).booleanValue() then value=Integer(1)
                                        else value=Integer(0)
      end
    when rettype=RxType.CHAR_TYPE then
      value=Rexx((Character value).charValue())
    end
  return value


 /** GETARRAYELEMENTVALUE: Look up an element in an array
    Arg1 is the context
    Arg2 is the array
    Arg3 is the type of the array
    Arg4 is the reference (array of valid indices)
    Arg5 is the token in case of error
    returns an object (or null) suitable for use as a Value
    */
 method getArrayElementValue(cursor=RxCursor,-
                             avalue=Object, atype=RxType, aref=RxArray,-
                             tok=RxToken) returns Object
  if avalue=null then signal NullPointerException('null array reference')

  dim=aref.arraydim-1         -- dimension we're unpeeling
  loop i=0 for aref.arraydim
    index=(Integer aref.arraycode[i].value).intValue()
    -- get the value, which will be wrapped if a primitive
    avalue=java.lang.reflect.Array.get(avalue, index)
    if dim=0 then do          -- rewrap may be needed
      basetype=atype.basetype(atype.dimension-aref.arraydim)
      avalue=ref2code(avalue, basetype)
      end
    dim=dim-1
   catch ab=ArrayIndexOutOfBoundsException
    signal RxSignal(cursor, ab, tok)
    end i
  return avalue

 /** SETARRAYELEMENTVALUE: Set an element in an array
    Arg1 is the context
    Arg2 is the array
    Arg3 is the type of the array
            --  .. no, it's currently the type of the assignment (rhs)
    Arg4 is the reference (array of valid indices)
    Arg5 is the token in case of error
    Arg6 is the value to set (a code.value)
    */
 method setArrayElementValue(cursor=RxCursor,-
                             avalue=Object, atype=RxType, aref=RxArray,-
                             tok=RxToken, setvalue=Object)
  if avalue=null then signal NullPointerException('null array reference')

  dim=aref.arraydim-1         -- dimension we're unpeeling
  loop i=0 for aref.arraydim
    index=(Integer aref.arraycode[i].value).intValue()
    -- if unpeeling, get the value (an array)
    if dim>0 then avalue=java.lang.reflect.Array.get(avalue, index)
     else /* dim=0 */ do                -- down to the bottom array
      setvalue=code2ref(setvalue, atype)-- rewrap, if needed
      java.lang.reflect.Array.set(avalue, index, setvalue)
      end
    dim=dim-1
   catch ab=ArrayIndexOutOfBoundsException
    signal RxSignal(cursor, ab, tok)
    end i
  return

 /** GETSTEMELEMENTVALUE: Look up an element in an indexed string
    Arg1 is the context
    Arg2 is the Rexx object (may not be null)
    Arg3 is the reference (array of valid indices of type Rexx)
    Arg4 is the token in case of error
    returns the Rexx object found
    */
 method getStemElementValue(cursor=RxCursor,-
                            val=Rexx, ref=RxArray, tok=RxToken) returns Rexx
  if val=null then signal RxSignal(cursor, NullPointerException(), tok)
  loop i=0 for ref.arraydim
    rindex=Rexx ref.arraycode[i].value
    val=val.getnode(rindex).leaf
    end
  return val

 /** SETSTEMELEMENTVALUE: Look up an element in an indexed string
    Arg1 is the context
    Arg2 is the Rexx object (may not be null)
    Arg3 is the reference (array of valid indices of type Rexx)
    Arg4 is the token in case of error
    Arg5 is the value to set
    */
 method setStemElementValue(cursor=RxCursor,-
                            val=Rexx, ref=RxArray, tok=RxToken, setvalue=Rexx)
  if val=null then signal RxSignal(cursor, NullPointerException(), tok)
  lasti=ref.arraydim-1
  loop i=0 to lasti
    rindex=Rexx ref.arraycode[i].value
    if i<lasti then val=val.getnode(rindex).leaf
               else val.getnode(rindex).leaf=setvalue
    end
  return

 /** GETVAR -- get the value of a (local) variable while executing
    Arg1 is the cursor
    Arg2 is the variable
    Arg3 is token in case of error
    For a method variable the value is the value property of the
    variable (for now).
    For a property, the value needs to be extracted from the proxy class
    or instance. */
 method getVar(cursor=RxCursor, var=RxVariable, tok=RxToken) returns Object
   if (var.varatts & RxVariable.VAR_PROP)=0 then return var.varvalue
   -- is a property
   return getProperty(cursor.curthis, var.varfield, tok)

 /** SETVAR -- set the value of a (local) variable while executing
    Arg1 is the cursor
    Arg2 is the variable
    Arg3 is token in case of error
    Arg4 is the new value object
    For a method variable the value to be set is the value property of
    the variable (for now).
    For a property, the value needs to be set in the proxy class
    or instance. */
 method setVar(cursor=RxCursor, var=RxVariable, tok=RxToken, setvalue=Object)
   if (var.varatts & RxVariable.VAR_PROP)=0 then do
     var.varvalue=setvalue
     return
     end
   -- is a property
   setProperty(cursor.curthis, var.varfield, tok, setvalue)

 /** GETPROPERTY -- get the value of a property
    Arg1 is the context object (null for a static property)
    Arg2 is the field, for class, name, return type, and errors
    Arg3 is token, for errors
    returns the property value, suitably wrapped for an RxCode.value
    */
 method getProperty(obj=Object, field=RxField, tok=RxToken)-
                    returns Object
  return doProperty(obj, field, tok, 0, null)

 /** SETPROPERTY -- set the value of a property
    Arg1 is the context object (null for a static property)
    Arg2 is the field, for class, name, return type, and errors
    Arg3 is token, for errors
    Arg4 is the value to set (may be null)
    */
 method setProperty(obj=Object, field=RxField, tok=RxToken, setvalue=Object)
  doProperty(obj, field, tok, 1, setvalue)
  return

 /** DOPROPERTY -- get or set the value of a property
    Arg1 is the instance object (null for a static property)
    Arg2 is the field, for class, name, return type, and errors
    Arg3 is token, for errors
    Arg4 is 1 to set, 0 for get
    Arg5 is value to set (iff Arg4 is 1)
    returns the property value, suitably wrapped for an RxCode.value, or
      null iff Arg4 is 1

    2000.04.02: all properties now reside in a 'real' object, either a
                regular Java object, or an instance of the proxy class
                for a local class
    */
 method doProperty(obj=Object, field=RxField, tok=RxToken,-
                   set=boolean, setvalue=Object) private returns Object
  -- property in a real class

  -- say '# doProp:' set field.fieldinfo.type.toString() field.fieldname
    infoclass=field.fieldinfo.getClassObject(rxt.loader)
  do label try
    -- now find the Field object for the property
    -- this should always succeed
    prop=infoclass.getDeclaredField(field.fieldname)
    prop.setAccessible(1)     -- we have The Authority
    
    -- now set or get it
    if set then do
      setvalue=code2ref(setvalue, field.fieldtype) /* rewrap if needed */

-- MRE need to wrap this and catch JDK12+ inaccessible class modifiers       
      do
        -- temp remove FINAL property as Java 5+ does not allow changing finals --issue #80 -KK-
        modifiersField = prop.getClass().getDeclaredField("modifiers") --issue #80 -KK-
-- say '##MRE not reached on JDK12+'
        modifiersField.setAccessible(1) --issue #80 -KK-
      catch NoSuchFieldException
        nop                   -- nop, but avoided JDK12+ java.lang.NoSuchFieldException:modifiers
                              -- triggering 'Severe Error: Internal error: RxInterpreter: pnf'
      end 

      modifiers=prop.getModifiers() --issue #80 -KK-
      if Modifier.isFinal(modifiers) then modifiersField.setInt(prop, modifiers-Modifier.FINAL) --issue #80 -KK-
      prop.set(obj, setvalue)
      if Modifier.isFinal(modifiers) then modifiersField.setInt(prop, modifiers) --issue #80 -KK-
      value=Object null
    end
   else do -- get its value
     value=prop.get(obj)
     value=ref2code(value, field.fieldtype)       -- rewrap if needed
   end
   
  catch iae=IllegalAccessException
    -- rethrow in our runtime wrapping
    signal RxSignalPend(iae, tok)
  catch se=SecurityException
    -- rethrow in our runtime wrapping
    signal RxSignalPend(se, tok)
  catch ire=IllegalArgumentException
    signal RxQuit(rxt, tok, 'internal.error', 'RxInterpreter: pia' ire.getMessage())
  catch NoSuchFieldException
    -- say '#' field.fieldinfo.type field.fieldname field.fieldtype
    -- if obj\=null then say '#' obj.toString()
    -- signal RxSignalPend(nsfe, tok)
    signal RxQuit(rxt, tok, 'internal.error', 'RxInterpreter: pnf')
  end try
  return value
  
  /** PROXYINIT -- request to statically initialize a proxy class
     Arg1 is the class index (unique integer for each local class)
   */
  method proxyInit(classId=int)
    -- say '# proxy class init:' classid
    info=rxt.classer.findclassbyid(classId)    -- find the right class
    localclass=info.localclass
    initializeProperties(localclass, null)     -- static initialize
    return
    
  /** CALLMETHOD -- call a method or constructor from a proxy
     Arg1 is the context object (null for a function, null for an
     ordinary constructor, non-null instance for instance method,
     or non-null parent for a dependent constructor)
     Arg2 is the field index (unique integer for each local field)
     Arg3 is the values array for the arguments (arguments suitably
     wrapped for RxCode values)
     returns the method result, suitably wrapped for an RxCode.value
     (or null, for an empty return or null value)
     
     If Arg2 is negative, this is a precall for a constructor, in which
     case the call simply collects the arguments for the super(...) call.
     In this case an object array is returned with the evaluated
     arguments (wrapped RxCode-style for primitives).
     
     We could be handling an Event.  In this case if we get an Exit then
     we must not pass our event signal back up to the catcher; instead we
     simply return a null reference.  We only need to worry about this
     for methods with no (void) return type.
     
     Special handling of parent object in dependent constructors:
     During precall, the context object (curthis) is the parent object.
     During the body of the constructor, or in instance methods, the
     parent object is in the 'this$n' field of the instance (referred
     to by curthis).
   */
  method callMethod(obj=Object, fieldId=int, args=Object[]) returns Object
    if fieldId<0 then do
     precall=boolean 1
     fieldId=-fieldId
     end
   field=rxt.classer.findfieldbyid(fieldId)  -- find the right field
   -- say '# callMethod:' field.toConciseString(field.fieldprogram, 0)-
   --                     '[precall='precall']'
   /* Do real callmethod */
   if field.fieldtype=RxType.VOID_TYPE then do
     result=callMethod(obj, field, args, null, precall, 1)
     return result
    catch sig=RxSignal
     if sig.signalobj=null then return null  -- had Exit request
     signal sig                              -- rethrow
    end
   return callMethod(obj, field, args, null, precall, 1)

 /** CALLMETHOD -- general call of a method or constructor
    Arg1 is the context object (null for a function or simple
            constructor on primary call; non-null instance for instance
            method or constructor body call; parent for dependent
            constructor on primary call)
    Arg2 is field, for field class, name, return type, and concise name
    Arg3 is the codes array for the arguments (interpreter call)
            or an array of code values        (proxy call)
    Arg4 is token, for errors
    Arg5 is precall flag (iff proxy call)
    Arg6 is proxy flag (1 iff proxy call, 0 iff called to interpret)
    returns the method result, suitably wrapped for an RxCode.value
      (or null, for an empty return or null value)
    */
 method callMethod(obj=Object, field=RxField,-
                   argcodes=RxCode[], tok=RxToken) returns Object
  -- we only want the values from the codes
  args=Object[argcodes.length]
  loop i=0 for argcodes.length
    args[i]=argcodes[i].value
    end i
  return callMethod(obj, field, args, tok, 0, 0)

 method callMethod(obj=Object, field=RxField,-
                   args=Object[], tok=RxToken,-
                   precall=boolean, proxycall=boolean) returns Object

  constructor=field.isConstructor()       -- 1 for a constructor
  localmeth=RxMethod field.fieldlocal   -- [RxMethod object, if any]

  -- If method belongs to an external class then use reflection to
  -- execute it.  Also, construction must be handled by the 'real' proxy
  -- class always, so when called during interpretation, convert a
  -- constructor call to a non-local call
  if localmeth=null, constructor & \proxycall then do label nonlocalmethod
    -- method belongs to an external class, or is a constructor
    infoclass=field.fieldinfo.getClassObject(rxt.loader)
    do label try
      -- For both constructors and methods we need to construct the
      -- classes array and the object (values) array for the arguments,
      -- narrowing primitives where necessary and rewrapping for
      -- reflection conventions as needed [The args values will have
      -- been converted to the desired types by convertargs]
      -- For dependent constructors we need to add the 'hidden' parent
      -- object as a special first argument
      if constructor then do
        if field.fieldinfo.isdependent then do
          classes=Class[args.length+1]
          values=Object[args.length+1]
          setupArgs(field.fieldargtypes, args, classes, values,-
                    field.fieldinfo.parentinfo.type, obj)
          end
        else do     -- non-dependent is just like methods
          classes=Class[args.length]
          values=Object[args.length]
          setupArgs(field.fieldargtypes, args, classes, values, null, null)
          end
        -- find the constructor object for the constructor
        -- this should always succeed
        constr=infoclass.getDeclaredConstructor(classes)
        constr.setAccessible(1)    -- we're allowed
        -- make it.
        value=constr.newInstance(values)
        end
       else /* method */ do
        classes=Class[args.length]
        values=Object[args.length]
        setupArgs(field.fieldargtypes, args, classes, values, null, null)
        -- find the Method object for the method
        -- this should always succeed
        meth=infoclass.getDeclaredMethod(field.fieldname, classes)
        meth.setAccessible(1)      -- we're allowed
        -- call it.
        value=meth.invoke(obj, values)
        value=ref2code(value, field.fieldtype)    -- rewrap if needed
        end

     catch iii=IllegalArgumentException
      -- should not happen
      say '>> iarge:' field.fieldname (obj=null) iii.getMessage()
      loop i=0 for args.length
        say '  Type:' classes[i] 'VType:' values[i].getClass() 'Value:' values[i]
        end
      signal RxQuit(rxt, tok, 'internal.error', 'RxInterpreter: iarge')

     catch ite=InvocationTargetException
      -- say '# ITE:' field.toString(rxt.getProgram) ite.getTargetException
      -- re-throw in our runtime wrapping; it will later get rewrapped into
      -- an RxSignal within the context of a local method
      signal RxSignalPend(ite.getTargetException(), tok)
     catch iae=IllegalAccessException
      -- rethrow in our runtime wrapping
      signal RxSignalPend(iae, tok)
     catch se=SecurityException
      -- rethrow in our runtime wrapping
      signal RxSignalPend(se, tok)
     catch InstantiationException
      signal RxQuit(rxt, tok, 'internal.error', 'RxInterpreter: cie')
     catch NoSuchMethodException
      say 'Field:' field.toConciseString(field.fieldprogram)
      loop ic=0 for classes.length
        say '     :' classes[ic].getName()
        end ic
      signal RxQuit(rxt, tok, 'internal.error', 'RxInterpreter: mnf')
      end try
    return value
    end nonlocalmethod

  /* this is a method (or constructor called via proxy) in a local
     class; run it, unless exiting... */

  -- this next should go, later, when we don't reference rxt.program during exec
  rxt.program=localmeth.methodprogram   -- program for the method

  classinfo=field.fieldinfo             -- RxClassInfo for the class
  localclass=classinfo.localclass       -- [RxClass object, if any yet]

  -- Build the cursor.  Its lifetime is that of the method execution.
  -- Initial clause is the method instruction, for argument expressions
  cursor=RxCursor(localclass.classprogram, localclass,-
                  localmeth, localmeth.methodclause)
  cursor.curbinary=localmeth.methodbinary
  cursor.curprecall=precall
  cursor.curexec=1
  cursor.curthis=obj          -- the instance

  if rxt.exiting then         -- we're done, here
    signal RxSignal(cursor, null, null) -- null exception indicates Exit

  -- Static properties will be initialized by normal JVM process, but we
  -- must trigger that if it has not already been done.  Requesting the
  -- Class object will do the trick.
  -- [oddly enough the visible effect of this is on tracing, but in any
  -- case we should initialize the class before running any method.]
  if \classinfo.initialized then classinfo.getClassObject(rxt.loader)

  -- diagnostic processing indicator
  if rxt.superflag.diag then do
    if constructor then do
      methstr='constructor'
      if precall then methstr=methstr 'precall'
                 else methstr=methstr 'body'
      end
     else if localmeth.methodstatic then methstr='function'
     else methstr='method'
    say '# -> invoke' methstr':' localmeth.methodname (obj=null) localmeth.methodprotected
    end

  -- handle special conditions for constructors, including instance initialize
  if constructor then do
    -- if we're starting the body of a constructor (i.e., not the precall)
    -- then it's time to initialize the instance variables
    if \precall then do
      initializeProperties(localclass, obj)
      -- also, if we have a this() or super() call in the method then
      -- set flag so we skip it on this run (the proxy will have done
      -- the call, possibly after a precall)
      if localmeth.methodhadthissuper then do
        cursor.curskipone=1
        -- if we must have had a precall then inhibit tracing until skip
        -- done, as we will have traced thus far on the precall.
        -- The 'inhibit trace' is turned off when curskipone is cleared
        tsfield=field.fieldspecial -- this describes the this/super call
        tsargcount=tsfield.fieldargtypes.length
        if tsargcount>0 then cursor.curskiptrace=1
        end
      end
     else do   -- in precall
      -- must be a super(..)/this(..) a-coming
      -- the object is not in fact an instance but the parent
      cursor.curparent=obj    -- save where it's safe
      cursor.curthis=null     -- we don't really have an instance yet
      end
    end

  -- now reference or clone numeric and trace objects as needed
  if \localmeth.methodhadnumeric then
    cursor.curnumer=cursor.curclass.classrunnumer -- inherit
   else do label neednumer
    if cursor.curclass.classrunnumer=null then
      cursor.curnumer=RexxSet()
     else
      cursor.curnumer=RexxSet(cursor.curclass.classrunnumer) -- clone
    end neednumer

  if \localmeth.methodtracechange then
    cursor.curtrace=cursor.curclass.classruntrace -- inherit
   else do label needtracer        -- need a trace object we can mutate
    if cursor.curclass.classruntrace=null then do
      -- Note trace2 is probably the *wrong* default for interpretation
      if cursor.curprogram.flag.trace=1 then outstream=System.out
                                        else outstream=System.err
      cursor.curtrace=RexxTrace(cursor.curprogram.source.getLineCount(),-
                                outstream, cursor.curprogram.source.getName())
      end
     else
      cursor.curtrace=RexxTrace(cursor.curclass.classruntrace) -- clone
    end needtracer

  -- trace the method clause itself if necessary.  This depends only on
  -- the class-level trace setting
  if cursor.curtrace\=null then do label tracemeth
    if localmeth.methoddefault then leave tracemeth    -- defaulted
    if localmeth.methodsynthetic then leave tracemeth  -- generated
    if cursor.curskiptrace then leave tracemeth
    cursor.curtrace.traceclause(-
      localmeth.methodclause.tokens[0].line,-
      localmeth.methodclause.tracelines(rxt),-
      RexxTrace.METHODS,-
      null)  -- no variables assigned [probably will trace arguments]
    end tracemeth

  -- set up the local method variable pool; a copy of the prototype pool
  -- [later we might just set up a values slot array]
  hsize=localmeth.methodprotopool.size()*7%4 -- NB headroom
  cursor.curlpool=Hashtable(hsize)      -- make a pond
  enum=localmeth.methodprotopool.elements() -- enumerate the variables in the pool
  ekey=localmeth.methodprotopool.keys()   -- enumerate the keys in the pool
  loop while enum.hasMoreElements()       -- while some left
    var=RxVariable enum.nextElement()     -- get next
    var=var.copy()                        -- copy and initialize
    var.varvalue=initvalue(var.vartype) -- ..
    key=String ekey.nextElement()         -- get matching key
    cursor.curlpool.put(key, var)       -- *splash*
    end

  -- set argument local variables
  argvars=localmeth.methodargvars
  loop i=0 for argvars.length
    -- find the variable in the local pool (where we just cloned it)
    var=cursor.curprogram.pooler.refindvar(cursor, argvars[i].varname)
    if i<args.length then do            -- supplied argument
      var.varvalue=args[i]              -- copy the value over
      -- the 'arg' variable needs special-case treatment :-(
      if var.varmain then var.varvalue=Rexx(String[] var.varvalue)
      end
     else do                            -- initialization expression please
      code=localmeth.methodargcode[i]
      if \code.constant, cursor.curtrace\=null then -- re-evaluation needed
        code=rxt.eparser.evalexpr(cursor, 0, code.begoff,-
                                  RxMethod.methodargends, null,-
                                  '\0', null)     -- don't trace here
      var.varvalue=code.value
      end
    -- now trace if required
    if cursor.curtrace\=null then if \var.varmain then do label tracearg
      if cursor.curskiptrace then leave tracearg
      if localmeth.methodsynthetic then leave tracearg -- no associated clause
      -- in the non-expression case we didn't need/make a code object,
      -- so make a minimal one here now
      if i<args.length then do
        code=RxCode(RxCode.S_EXPR, var.vartype, null)
        code.value=var.varvalue
        -- cannot be var.varmain
        end
      val=stringvalue(code)             -- always to String
      tracetag='m'                      -- indicate special argument trace
      cursor.curtrace.traceString(localmeth.methodclause.tokens[0].line, val,-
                                  tracetag, RexxTrace.METHODS, var.varname)
      end tracearg
    end i

  retobject=Object null                 -- default if run off the end

  /* if we are synthetic then use RxMethod to evaluate it */
  if localmeth.methodsynthetic then do
    if cursor.curprogram.flag.diag then say '# synthetic method:' localmeth.methodname
    localmeth.interpret(cursor)
    if cursor.curreturn\=null then return cursor.curreturn
    return retobject                    -- [any constructed instance]
    end

  /* ---------------------------------------------------------------- */
  /* Start the main interpreter loop...                               */
  /* ---------------------------------------------------------------- */
  cursor.curstatic=localmeth.methodstatic    -- set staticisity
  cursor.curjump=nojump                      -- show no jump requested
  -- ensure always a level; its .prev will be null
  cursor.curclause=null                      -- no longer on RxMethod clause
  pushlevel(cursor)                          -- clause must be null, here
  cursor.curclause=localmeth.methodclauses   -- first clause of body, please

  if \localmeth.methodprotected then runfree(cursor)
   else do
    if \localmeth.methodstatic then lock=cursor.curthis
                               else lock=localclass.classinfo.getClassObject()
    runprotected(cursor, lock)
    end

  -- here iff run off end, or RETURN seen, or exception raised
  if cursor.curreturn\=null then do
    retobject=cursor.curreturn
    cursor.curreturn=null                    -- we used it
    end
  -- if it was null, then constructed object might be waiting there
  -- for a RETURN
  poplevel(cursor)                           -- done with the method level

  -- here we could have either an exception or a RETURN request.  The
  -- exception overrides.
  -- However, iff the exception is a precall return then this is not a
  -- true exception and we change it into a return
  if cursor.curacttype=CUR_EXCEP then do     -- ah, it's an exception
    -- say ':EOMsignal:' retobject.toString 'in' localmeth.methodname
    sig=RxSignal retobject
    -- handle exit
    if sig.signalobj=null then do
      rxt.exiting=1
      return null
      end
    -- handle precall return -- return the arguments array
    if sig.signalobj<=Object[] then return sig.signalobj
    -- true signal
    -- add frame in case of traceback, in old program context
    sig.Frame(cursor.curprogram, field, tok)
    signal sig
    end
  -- it really was a RETURN
  return retobject

 /** RUNPROTECTED -- run clauses locked by an object
    Arg1 is the cursor
    Arg2 is the code.value to protect
    */
 method runprotected(cursor=RxCursor, lock=Object)
   do protect lock
     if cursor.curprogram.flag.diag then say '# protecting:' lock.toString()
     runfree(cursor)
     if cursor.curprogram.flag.diag then say '# unprotecting:' lock.toString()
     end
   return

 /** RUNFREE -- run clauses without protection
    Arg1 is the cursor
    */
 method runfree(cursor=RxCursor)
  loop label execute while cursor.curclause\=null
    clause=cursor.curclause                   -- local reference


    -- trace the clause if required
    if cursor.curtrace\=null then do label traceit
      if cursor.curnewprot then leave traceit -- already just traced it
      if cursor.curskiptrace then leave traceit
      if clause.lookaside\=null then do
        varlist=clause.lookaside.getAssigns()
        reqlevel=RexxTrace.VAR
        end
       else do
        varlist=null
        reqlevel=RexxTrace.ALL
        end
      cursor.curtrace.traceclause(clause.tokens[0].line, -
                                  clause.tracelines(rxt),-
                                  reqlevel, varlist)   -- trace variables list
      end traceit

loop label interactive

    if clause.lookaside=null then nop
    else do label realclause -- we have a real clause
      -- interpret the clause, unless:
      --   * it newly starts a protected block, in which case we need
      --     to run it protectively
      select label doclause
        when clause.startprot & \cursor.curnewprot then do
          startblock=NrBlock clause.lookaside-- find the block
          lock=startblock.evalProtect(cursor)-- evaluate the PROTECT term
          cursor.curnewprot=1                -- indicate starting protected
          runprotected(cursor, lock)
          -- get back here after our END
          clause=cursor.curclause            -- update
        end
        otherwise do
          cursor.curnewprot=0                -- defuse
          /* === now interpret a clause [unless skipping one] === */
          if cursor.curskipone then do
            cursor.curskipone=0
            cursor.curskiptrace=0            -- turn this off now, too
          end
          else
            clause.lookaside.interpret(cursor)
            -- if it just ENDed a protected block, then return to caller and
            -- let the caller carry on (unprotected or differently protected)
          if cursor.curendprot then do
            cursor.curendprot=0
            return
          end
        catch s=RxSignal                      -- wrapped exception raised
        -- [This could also be an Exit or precall signal.]
          cursor.curreturn=s                   -- save the value
          cursor.curact=1                      -- alert
          cursor.curacttype=CUR_EXCEP          -- it's an Exception
        end
      end doclause

--MRE Interactive trace
if cursor.curtrace\=null then do 
  if cursor.curtrace.levelword() == 'int' then do 
    loop label handleinput
--      say cursor.curclause.showtokens() '+++' cursor.curclause.lookaside.toString()
      say '    *-> \-'; x=ask
      select 
        when x=='=' then do 
          clauseobj = cursor.curclause.lookaside
          if clauseobj <= NrDo        | - 
             clauseobj <= NrLoop      | -
             clauseobj <= NrSelect    | -
             clauseobj <= NrEnd       | -
             clauseobj <= NrCatch     | -
             clauseobj <= NrOtherwise | -
             clauseobj <= NrFinally   then 
            say '        Sorry, this clause cannot be re-interpreted' 
          else 
            iterate interactive    -- redo clause
        end    

        when x==''  then leave handleinput    -- continue
        when x.substr(1,1)=='+' then do 
          if x=='+' then do
            if cursor.curclause.next \= null then do 
              say cursor.curclause.next.toString()
            end
          end  
          else if x.datatype('N') then do    -- show next x lines
            clines = x.format()             
            nc = cursor.curclause.next
            loop i=1 to clines by 1
              if nc \= null then do
                say nc.toString()
                nc = nc.next
              end
              else leave  
            end
          end
          iterate handleinput
        end  
        when x.substr(1,1)=='-' then do 
          if x=='-' then do
            if cursor.curclause.clausenum > 1 then do
              clausen = cursor.curclause.clausenum 
              c = rxt.program.clauser.clause(clausen)
              say c.toString()
            end 
          end
          else if x.datatype('N') then do    -- show previous x lines 
            clines = short x.format().abs()

-- this loop needs decimal, how to loop with nodecimal ?
            loop i=clines-1 to 0 by -1
              clausen = cursor.curclause.clausenum - i
              if clausen > 0 then do
                c = rxt.program.clauser.clause(clausen)
                say c.toString()
              end
            end
          end
          iterate handleinput
        end  
        when x.upper().strip('B') == 'TRACE OFF' then do
          cursor.curtrace.newlevel(RexxTrace.OFF)   --trace off
          leave handleinput
        end
        when x=='?' then do                   -- show help
          say 'Experimental interactive trace :'
          say '  press [Enter] to trace interactively'
          say '  type ''='' to reinterpret current clause'
          say '  type ''-[n]'' to show previous n clause(s), shows current clause if n is absent'
          say '  type ''+[n]'' to show next n clause(s), shows next clause if n is absent'
          say '  type ''trace off'' to stop tracing'
          say '  any other clause entered must be either an assignment or a SAY instruction'
        end
        otherwise do
--trace results          
          src = RxFileReader(rxt)
          src.openfile('trace', String x)

          traceclauser=RxClauser(rxt, src)   -- create clauser from trace input
          rxt.program.parser=RxParser(rxt,traceclauser)            -- create our own
          rxt.program.tracer=RxTracer(rxt)                         -- create our own
          rxt.program.parser.level=3                               -- 'in a method'
          rxt.program.parser.cursor = cursor                       -- dummy

--          say '#### PASS' rxt.pass
          rxt.pass=0; rxt.pass0=1
          traceclausenum=0
          loop forever                       -- do pass 0 first, create array
            traceclausenum=traceclausenum+1
            do
              curclause=traceclauser.clause(traceclausenum)
            catch RxQuit
              do
                say '    --- Invalid trace instruction (Q0)'
                iterate handleinput
              end  
            catch RxError
              do
                say '    --- Invalid trace instruction (E0)'
                iterate handleinput
              end
            end  
            if curclause=null then leave
--            say '### PASS0 : "'curclause.toString()'"' curclause.showtokens()
          end  
      
          rxt.pass=3; rxt.pass0=0           -- now pass 3

          traceclausenum=0
          loop forever
            traceclausenum=traceclausenum+1
            curclause=traceclauser.clause(traceclausenum)
            if curclause=null then leave         -- EOS
--            say '### TRACE INPUT : 'curclause.showtokens()' : "'curclause.toString()'"' 

            curse = RxCursor(cursor.curprogram, cursor.curclass, cursor.curmethod, curclause)
            curse.curlpool=cursor.curlpool
            curse.curexec=1
            curse.curthis=cursor.curthis
            curse.curclass=cursor.curclass

            term=RxCode null
            tok=curse.curclause.tokens[0];
            t=tok.type
            if t=RxToken.END then signal RxQuit(rxt,null,"internal.error","null clause 3")
            tok2=curse.curclause.tokens[1];
            t2=tok2.type

            rxt.program.parser.cursor = curse                        -- our trace cursor
--trace results

                                                                     -- copied from RxParser 
            if t=RxToken.SYM then do 
              if t2=RxToken.SP then do 
                term=rxt.tparser.parsesymbol(curse,0)
              end  
              else if t2=RxToken.OP then do 
                if tok2.value\=null then do 
                  if tok2.value[0]="=" then do 
                    term=rxt.tparser.parsesymbol(curse,0)
                  end
                end    
              end  
            end

            if term==null then n=0
            else do
              if term.begclause=null then signal RxQuit(rxt,tok,"internal.error","RxParser: bcnull")
              n=term.endoff+1
            end  
            tokn=curse.curclause.tokens[n];
            tn=tokn.type

--trace results
            handled=0
            if tn=RxToken.OP then do 
              if tokn.value[0]="=" then do       -- this is an assigment
--                say '    : assigment'  
                do
                  handled=1
                  assign=NrAssign(rxt)              -- construct Assignment instruction 
                  curse.curclause.lookaside=assign
                  curse.curtrace = RexxTrace(1)     -- force re-evaluation

                  curse.curexec=0                   -- don't evaluate method calls twice
                  assign.process(term,n)            -- further token processing 
                  curse.curexec=1
                  assign.interpret(curse)           -- interpret trace input
                catch RxQuit
                  say '    --- Invalid trace instruction (QA)'
                catch RxError
                  say '    --- Invalid trace instruction (EA)'
                end 
              end   
            end
            else if t=RxToken.SYM then do 
              if rxt.program.parser.iskey(tok.value, 'SAY') then do -- this is SAY
--                say '    : saying something'
                do
                  handled=1
                  saying=NrSay(rxt)    
                  curse.curexec=0          -- don't evaluate method calls twice
                  saying.scan(2)
                  curse.curexec=1         
                  saying.interpret(curse)
                catch RxQuit
                  say '    --- Invalid trace instruction (QS)'
                catch RxError
                  say '    --- Invalid trace instruction (ES)'
                end  
              end
            end 
           
            if handled=0 then do 
--              say '    : parsing term'
              do 
                term=rxt.tparser.parseterm(curse,0,0)
                if term=null then signal RxError(rxt, null, 'expression.has.no.value')
                if term.group=RxCode.T_UNKNOWN then signal RxError(rxt, null, 'expression.has.no.value')
              catch RxQuit
                say '    --- Invalid trace instruction (QT)'
              catch RxError
                say '    --- Invalid trace instruction (ET)'
              end
            end    

            rxt.program.parser=null           -- clean up
            rxt.program.tracer=null
            iterate handleinput               -- ask more input 
          end
        end
      end  
    end handleinput
  end
end
--MRE

      /* Now special actions */
      loop label popones while cursor.curlevel.thisone -- we just executed the One
        topcp=cursor.curlevel.clause.lookaside
        if topcp<=NrIf then do
          -- next clause will be the one after the IF
          cursor.curjump=(NrIf topcp).nextclause
          poplevel(cursor)
          end
         else do -- must have been a THEN following WHEN in SELECT
          -- turn off the flag, then go and finish the block
          cursor.curlevel.thisone=0
          endblock(cursor)
          end
        end popones

      select label alerts
        when cursor.curlevel.nextone then do      -- just had THEN or ELSE
          cursor.curlevel.thisone=1               -- bump the trigger
          cursor.curlevel.nextone=0               -- be clean
          end
        when cursor.curacttype\=CUR_NOACT then do -- have a pending action
          -- we need to take action if we just had the event (that is,
          -- curact is set) or if curact is not set and we reach END
          -- in a block we're finalizing.
          if cursor.curact, cursor.curclause.lookaside<=NrEnd then do
            unwind(cursor)
            end
          -- If we're at the top we must be RETURN or EXCEP, and we're done
          if cursor.curlevel.prev=null then leave execute
          end
        otherwise nop
        end alerts
     end realclause
     leave
end interactive

    if cursor.curjump\==nojump then do       -- any jump request?
      cursor.curclause=cursor.curjump        -- [this could now be null]
      cursor.curjump=nojump                  -- clear
      end
     else /* normal bump */ do
      cursor.curclause=clause.next
      end

    -- Always do request immediately after action request
    if cursor.curact then cursor.curact=0    -- done with initial request
     else do
      -- if about to drop into CATCH/FINALLY/END, skip to finalize
      -- (unless we're in that state)
      if cursor.curclause\=null then
       if cursor.curclause.skipend then        -- would normally skip
       if cursor.curlevel.trystate\=TRY_FINAL then do    -- not already finalizing
        -- setup jump to FINALLY/END, or go back up to LOOP
        endBody(cursor)
        cursor.curclause=cursor.curjump
        cursor.curjump=nojump                -- clear
        end
      end

    end execute
  return

 /** ENDBODY -- non-END end of main body of a block (DO, LOOP, SELECT)
    Arg1 is the cursor
    Always sets curjump.
    */
 method endBody(cursor=RxCursor)
  topaside=cursor.curlevel.clause.lookaside  -- the owning parser
  if topaside<=NrLoop then                   -- straight back to top, please
    cursor.curjump=cursor.curlevel.clause
   else endblock(cursor)                     -- DO or SELECT OTHERWISE
  return

 /** ENDBLOCK -- skip to end of block (FINALLY or END)
    Arg1 is the cursor
    Always sets curjump.
    */
 method endblock(cursor=RxCursor) private
  topblock=NrBlock cursor.curlevel.clause.lookaside
  select
    when cursor.curlevel.trystate=TRY_FINAL then
      cursor.curjump=topblock.endclause      -- already in FINALLY
    when topblock.finclause\=null then
      cursor.curjump=topblock.finclause      -- have a FINALLY, use it
    otherwise
      cursor.curjump=topblock.endclause      -- just END
    end
  cursor.curlevel.trystate=TRY_FINAL         -- can now run FINALLY/END
  return

 /** UNWIND -- unwind levels after RETURN, LEAVE, ITERate or EXCEPtion
    Arg1 is the cursor
    Has no effect if nothing to unwind. */
 method unwind(cursor=RxCursor) private
  -- here, we throw away IF constructs and return to execute the FINALLY
  -- or END of and block (if we're in one)
  if cursor.curlevel.prev=null then return -- already at top
  topaside=cursor.curlevel.clause.lookaside
  loop while topaside<=NrIf
    poplevel(cursor)
    if cursor.curlevel.prev=null then return -- reached the top
    topaside=cursor.curlevel.clause.lookaside
    end
  -- here when we've cleared out any IFs and find we're still in a block

  -- now the action taken depends on its curacttype
  select label acttype
    -- check for a CATCH, if an exception is in progress and we are not
    -- already in a finally or catch for this block
    when cursor.curacttype=CUR_EXCEP then do
      if cursor.curlevel.trystate=TRY_INIT then do label trycatch
        catches=(NrBlock topaside).catches
        if catches\=null then do
          sig=RxSignal cursor.curreturn
          loop i=0 for catches.size()
            catchclause=RxClause catches.elementAt(i)
            if (NrCatch catchclause.lookaside).canCatch(cursor, sig) then do
              -- exception caught...
              cursor.curjump=catchclause
              -- say ':catch ->' catchclause.toString
              leave acttype
              end
            end i
          end
        end trycatch
      endblock(cursor)
      end
    when cursor.curacttype=CUR_LEAVE then do
      -- if we're a LEAVE and we're at the right level, cancel the action so
      -- we don't unwind any more
      if (NrBlock topaside)==cursor.curactblock then
        cursor.curacttype=CUR_NOACT
      endblock(cursor)
      end
    when cursor.curacttype=CUR_ITER then do
      -- if we're an INTERATE and we're at the right level, cancel the
      -- action and end body instead of end block
      -- we don't unwind any more
      if (NrBlock topaside)==cursor.curactblock then
        cursor.curacttype=CUR_NOACT
      endBody(cursor)    -- always LOOP, so will iterate
      end
    when cursor.curacttype=CUR_RETURN then do
      -- if we're a RETURN, end the block and continue unwinding
      endblock(cursor)
      end
    end acttype
  return

 /** PUSHLEVEL -- add a new level.
    Arg1 is the context cursor
    returns the new level for convenience
    */
 method pushlevel(cursor=RxCursor) returns NrLevel
  newlevel=NrLevel(cursor.curclause)         -- lightweight construction
  newlevel.prev=cursor.curlevel              -- chain it in to stack
  cursor.curlevel=newlevel                   -- and make it the new level
  return newlevel

 /** POPLEVEL -- drop a level.
    */
 method poplevel(cursor=RxCursor)
  cursor.curlevel=cursor.curlevel.prev


