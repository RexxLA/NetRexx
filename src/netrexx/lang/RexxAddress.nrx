/* IBM Materials Licensed under International Components for Unicode  */
/* Licence version 1.8.1 (ICU Licence) - Property of IBM              */
/* IBM NetRexx                                                        */
/* Copyright (c) 1995-2009 IBM Corp.                                  */
/* Copyright (c) 2011- RexxLA                                         */
/* ------------------------------------------------------------------ */
/* netrexx.lang.RexxAddress -- ADDRESS instruction for NetRexx        */
/* ------------------------------------------------------------------ */
/* Copyright IBM Corporation, 1996, 1997.  All Rights Reserved.       */
/* Author    Marc Remes                                               */
/*                                                                    */
/* ------------------------------------------------------------------ */
/* 2021.01.15 MRE Classic Rexx ADDRESS implementation                 */
/* ------------------------------------------------------------------ */
import java.util
package netrexx.lang
options binary strictargs nodecimal noformat

/**
   This defines the I/O utility class for NetRexx.
 */
    
class RexxAddress implements Serializable

  properties private static
--  StdIn	 = BufferedReader(InputStreamReader(System.in))
    StdOut = ConcurrentLinkedDeque()
  --StdOut = LinkedList()
  --fileIn = BufferedReader
    command    = String null
    returncode = int -1
  
  properties private constant unused
  serialVersionUID=long 2781762092115528702

--  method exec(command_=String, wait=1) static 
--    if command_ == '', command_ == null then return
--    command=command_
--    execAddress(command)

--  method exec(command_=Rexx, wait=1) static 
--    if command_ == '', command_ == null then return
--    command=command_
--    execAddress(command)

  method exec(addr=String, command_=String, wait=1) static 
    if command_ == '', command_ == null then return
    command=command_
    execAddress(addr, command)

  method exec(addr=String, command_=Rexx, wait=1) static
    if command_ == '', command_ == null then return
    command=command_
    execAddress(addr, command)

  /** Function to launch an executable and process a command.
     Arg1 is the executable to launch.
     Arg2 is the command to process, it is sent into STDIN of
     the started executable
     Arg3 is wait for executable to end -- always 1
     
     Output of the processed executable command is printed on
     STDOUT.
     Returncode is stored on lastrc 
   */
  method execAddress(addr=String, command_=String, wait=1) static
--   say '#MRE EXECADDR 'addr' 'command_
   addressee=[addr] 
    do
      pb = ProcessBuilder(addressee)
--      pb.redirectErrorStream(1)   -- don't think we need to do this
      pid = pb.start()
      if wait then do
   	    in = BufferedReader(InputStreamReader(pid.getInputStream()))
  	    out = BufferedWriter(OutputStreamWriter(pid.getOutputStream()))
        out.write(command_)
        out.flush()
        out.close()
	      line = in.readLine()
	      loop while line <> null
          Say(line)          
	        line = in.readLine()
        end  
	      pid.waitFor()
    	  returncode = pid.exitValue()
      end
    catch iox=IOException
      say iox.getMessage()
    catch InterruptedException
      say "interrupted"
    end -- do
/*
  method execAddress(command_=String, wait=1) static
   say '#EXECADDR 'command_
   addressee=['bash']
    do
      pb = ProcessBuilder(addressee)
      pb.redirectErrorStream(1)
      pid = pb.start()
      if wait then do
   	    in = BufferedReader(InputStreamReader(pid.getInputStream()))
  	    out = BufferedWriter(OutputStreamWriter(pid.getOutputStream()))
        out.write(command_)
        out.flush()
        out.close()
	      line = in.readLine()
	      loop while line <> null
          Say(line)          
	        line = in.readLine()
        end  
	      pid.waitFor()
    	  returncode = pid.exitValue()
      end
    catch iox=IOException
      say iox.getMessage()
    catch InterruptedException
      say "interrupted"
    end -- do
*/


/*
  /**
   * Method exec starts an OS process from a command line in an ArrayList
   * @param then fires off outputEvent events to every registered listener
   * @return void
   */
  method execkkkk(command_=String[],wait=1) static
   say command_
   
    do
      pb = ProcessBuilder(command_)
      pb.redirectErrorStream(1)
      pid = pb.start()
      if wait then do
	    in = BufferedReader(InputStreamReader(pid.getInputStream()))
	    line = in.readLine()
	    loop while line <> null
          Say(line)          
	      line = in.readLine()
        end  
	    pid.waitFor()
    	returncode = pid.exitValue()
      end
    catch iox=IOException
      say iox.getMessage()
    catch InterruptedException
      say "interrupted"
    end -- do


  /**
   * Method exec starts an OS process from a command line in an ArrayList
   * @param then fires off outputEvent events to every registered listener
   * @return void
   */
  method exec(command_=ArrayList,wait=1) static
   say command_
    do
      pb = ProcessBuilder(command_)
      pb.redirectErrorStream(1)
      pid = pb.start()
      if wait then do
	    in = BufferedReader(InputStreamReader(pid.getInputStream()))
	    line = in.readLine()
	    loop while line <> null
          Say(line)          
	      line = in.readLine()
        end  
	    pid.waitFor()
    	returncode = pid.exitValue()
      end
    catch iox=IOException
      say iox.getMessage()
    catch InterruptedException
      say "interrupted"
    end -- do
*/
    
  /** Function to write a line to the standard output stream.
     Arg1 is the Object or Rexx string to be written.
     If the line ends in the NUL character ('\-' or '\0') then no
     line termination is provided (and the NUL is deleted).
     If the write succeeds 0 is returned, otherwise 1 is returned.
     
     We handle all the well-known character forms directly to
     minimize code generation in caller; null is allowed for all
     objects.
     We also handle Object here, so null can be processed efficiently.
     We provide versions for all the other primitives, too.
   */
/*   
  method Say(obj=Object) static returns boolean
    if obj=null then return Say(char[] null)
    return Say(obj.toString().toCharArray())
    
  method Say(str=String) static returns boolean
    if str=null then return Say(char[] null)
    return Say(str.toCharArray())
    
  method Say(line=Rexx) static returns boolean
    --if line='' then Exception().printStackTrace()
    return Say(Rexx.tochararray(line))       -- null passes through
    
  method Say(c=char) static returns boolean
    ca=char[1]; ca[0]=c
    return Say(ca)
    
    -- numeric primitives
  method Say(n=long) static returns boolean  -- handles byte, short, int
    return Say(Long.toString(n).toCharArray())
  method Say(f=float)   static returns boolean; return Say(Rexx(f))
  method Say(d=double)  static returns boolean; return Say(Rexx(d))
  method Say(b=boolean) static returns boolean; return Say(Rexx(b))
*/
-- Borrowed from RexxIO    
  method Say(aline=char[]) static returns boolean
    if StdOut.size() == 0 then StdOut.push(PrintWriter(System.out))
    i = StdOut.iterator()
    loop while i.hasNext()
      out=PrintWriter i.next()
      if aline=null then out.println()      -- just new line
      else do                                 -- have some data
	select
          when aline.length=0 then out.println()
          when aline[aline.length-1]\=='\-' then out.println(aline)
          otherwise                            -- rarer continuation case
            bline=char[aline.length-1]
            System.arraycopy(aline, 0, bline, 0, bline.length)
            out.print(bline)
        end
      end
      out.flush()  -- could be a real user out there
    end -- loop while i
    return 0


  /** Function to write a line to the standard output stream, to be used from
     multiple thread, where we don't want to push an output stream to the StdOut deque
     each time. The problem here is that the RexxIO methods are static (always were).
     
     Arg1 is the Object or Rexx string to be written.
     If the line ends in the NUL character ('\-' or '\0') then no
     line termination is provided (and the NUL is deleted).
     If the write succeeds 0 is returned, otherwise 1 is returned.
     
     We handle all the well-known character forms directly to
     minimize code generation in caller; null is allowed for all
     objects.
     We also handle Object here, so null can be processed efficiently.
     We provide versions for all the other primitives, too.
   */
  method pipeSay(obj=Object) static returns boolean
    if obj=null then return pipeSay(char[] null)
    return pipeSay(obj.toString().toCharArray())
    
  method pipeSay(str=String) static returns boolean
    if str=null then return pipeSay(char[] null)
    return pipeSay(str.toCharArray())
    
  method pipeSay(line=Rexx) static returns boolean
    --if line='' then Exception().printStackTrace()
    return pipeSay(Rexx.tochararray(line))       -- null passes through
    
  method pipeSay(c=char) static returns boolean
    ca=char[1]; ca[0]=c
    return pipeSay(ca)
    
    -- numeric primitives
  method pipeSay(n=long) static returns boolean  -- handles byte, short, int
    return pipeSay(Long.toString(n).toCharArray())
  method pipeSay(f=float)   static returns boolean; return pipeSay(Rexx(f))
  method pipeSay(d=double)  static returns boolean; return pipeSay(Rexx(d))
  method pipeSay(b=boolean) static returns boolean; return pipeSay(Rexx(b))
    
  method pipeSay(aline=char[]) static returns boolean
    out=PrintWriter(System.out)
    if aline=null then out.println()        -- just new line
    else do                                 -- have some data
      select
        when aline.length=0 then out.println()
        when aline[aline.length-1]\=='\-' then out.println(aline)
        otherwise                            -- rarer continuation case
          bline=char[aline.length-1]
          System.arraycopy(aline, 0, bline, 0, bline.length)
          out.print(bline)
      end
    end
    out.flush()  -- could be a real user out there
    return 0
    
 