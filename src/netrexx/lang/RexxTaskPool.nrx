/* IBM Materials Licensed under International Components for Unicode  */
/* Licence version 1.8.1 (ICU Licence) - Property of IBM              */
/* NetRexx                                                            */
/* Copyright (c) 2015- RexxLA                                         */
/* ------------------------------------------------------------------ */
/* netrexx.lang.RexxTaskPool                                          */
/* ------------------------------------------------------------------ */
-- This module adds a simple parallel processing API to NetRexx
/* ------------------------------------------------------------------ */
/* 2015.05.04 Initial version in NetRexx     -- Kermit Kiser  --  KK  */
/* 18.04.17 package protect field poolmap and ca1      (Jason Martin) */
/* 18.04.17 add to caught exceptions - waitforallpools (Jason Martin) */
/* 18.04.17 make poolmap volatile                      (Jason Martin) */
/* 18.04.18 change more properties and run Privileged  (Jason Martin) */
/* 18.04.20 reduce code in RxPrivilegedAction run      (Jason Martin) */
/* 18.04.20 reorder properties                         (Jason Martin) */

package netrexx.lang
options strictargs strictcase noformat

import java.security.AccessController
import java.security.PrivilegedAction

/*
sample usage doc:

rtp=RexxTaskPool(size,number)
---- where size is the number of parallel threads desired - default is the current number of available processors
---- number is the number of the threadpool if using multiple pools - default is pool number 0

rtp.start(runtask)
---- where runtask is a Java "runnable" class

rtp.start(maintask,mainparm)
--- where maintask is a NetRexx Java class with a standard "main" method
--- mainparm is a string parm to pass to the main method at startup

rtp.start("taskname",mainparm)
--- "taskname" is a string identifying a Java class with a standard main method
--- mainparm is a string parm to pass to the main method at startup

Note: the start method returns the RexxTaskPool instance it is called on so that multiple calls can be stacked
Note: due to reflection use when starting "main" methods that call format cannot be interpreted - runnables interpret ok

rtp.waituntildone
--- Blocks until all threads in the pool are finished

rtp.waitforallpools
--- Blocks until all threads in all task pools are complete

examples:

RexxTaskPool(3,1).start(Test(7)).start(Test(8)).start("TestMain","9").start("enviroscan")
RexxTaskPool(9).start(Test(1)).start(Test(2)).start(TestMain("3"),"3").start(enviroscan.class)
RexxTaskPool().start(Test(4)).start(Test(5)).start(TestMain("6"),"6").waituntildone
RexxTaskPool().start(Test(4)).start(Test(5)).start(TestMain("6"),"6").waitforallpools
*/

Class RexxTaskPool implements Executor,Runnable

	properties shared constant
		sa0=String[0]
		ca1=[Class sa0.getClass()]

	properties shared
		poolno=Rexx
		poolsiz3=Rexx
		realtask=Object
		saveparms=String

	properties shared volatile
		poolmap=HashMap null

	properties public
		poolnumber=int
		poolsize=int
		threadpool=ThreadPoolExecutor

	method RexxTaskPool()  signals Exception
		this(Runtime.getRuntime().availableProcessors())

	method RexxTaskPool(psize=int,pno=int -1) signals Exception
		if psize=0 then signal Exception('RexxTaskPool - pool of zero threads not allowed.')
		poolsize=psize
		if pno=-1 then poolnumber=0
			else poolnumber=pno
		poolno=poolnumber
		poolsiz3=poolsize

		if poolmap=null then poolmap=HashMap()
		if \poolmap.containsKey(poolno) then
			poolmap.put(poolno,HashMap()) 		--		nested map of threadpools by size
		if \(HashMap poolmap.get(poolno)).containsKey(poolsiz3) then
			(HashMap poolmap.get(poolno)).put(poolsiz3,ThreadPoolExecutor(poolsize,poolsize,1,TimeUnit.HOURS,LinkedBlockingQueue()))		--	build initial threadpool
		threadpool=ThreadPoolExecutor (HashMap poolmap.get(poolno)).get(poolsiz3)

	method start(to=Object,parms=String null) returns RexxTaskPool  signals ClassNotFoundException,SecurityException
		if to<=Runnable then startrunnable(Runnable to)
			else startmain(to,parms)
		return this

	method execute(to=Object,parms=String null) returns RexxTaskPool  signals ClassNotFoundException,SecurityException
		return start(to,parms)

	method execute(to=Runnable)
		startrunnable(to)

	method startrunnable(to=Runnable)
		(ThreadPoolExecutor (HashMap poolmap.get(poolno)).get(poolsiz3)).execute(to)

	method startmain(to=Object,parms=String) signals ClassNotFoundException,SecurityException
		if to<=String then to=Class.forName(String to)
		if to<=Class then do
			mainmethod = (Class to).getMethod('main',ca1)
			catch e=Exception
				say e
			end
		else -
		do
			mainmethod = to.getClass().getMethod('main',ca1)
			catch e=Exception
				say e
			end
		if mainmethod = null then return
		(ThreadPoolExecutor (HashMap poolmap.get(poolno)).get(poolsiz3)).execute(RexxTaskPool(to,parms))	--	add task to queue

	method waituntildone
		pool=ThreadPoolExecutor (HashMap poolmap.get(poolno)).get(poolsiz3)
		loop forever
			if pool.getQueue().size()+pool.getActiveCount() = 0 then return		--	all tasks done?
			Thread.sleep(100) 		-- wait .1 seconds
			catch e=Exception
				say e
			end

	method waitforallpools
		loop label busy forever
			loop pnum over poolmap.keySet()
				pools=HashMap poolmap.get(pnum)
				loop psize over pools.keySet()
					if (ThreadPoolExecutor pools.get(psize)).getQueue().size()+(ThreadPoolExecutor pools.get(psize)).getActiveCount() \= 0 then 		--	all tasks done?
						do
							Thread.sleep(100) 		-- wait .1 seconds
							 iterate busy
							 end
					end
				end
			return
			catch exec=RuntimeException
				signal exec
			catch e=Exception
				say e
			end

	method RexxTaskPool(rt=Object,parms=String)
		realtask=rt
		saveparms=parms

	method run
		AccessController.doPrivileged(RexxTaskPool.RxPrivilegedAction())

class RexxTaskPool.RxPrivilegedAction private dependent implements PrivilegedAction

	method run returns Object
		if parent.saveparms\=null then sa=parent.saveparms.split(" ")
		else sa=parent.sa0
		oa1=Object[1]
		oa1[0]=sa
		do
			if parent.realtask<=Class then do
				mainmethod=(Class parent.realtask).getMethod("main",parent.ca1)
				end
			else do
				mainmethod=parent.realtask.getClass().getMethod("main",parent.ca1)
				end
			/* AccessibleObject.setAccessible deprecated in Java 9
				and in Java 10 - expected not to work */
			mainmethod.setAccessible(1)
			mainmethod.invoke(null,oa1)
			catch nsm=NoSuchMethodException
				say nsm
			catch iae=IllegalAccessException
				say iae
			catch ite=InvocationTargetException
				say ite
		end
		return null
