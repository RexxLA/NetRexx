/* IBM Materials Licensed under International Components for Unicode  */
/* Licence version 1.8.1 (ICU Licence) - Property of IBM              */
/* IBM NetRexx                                                        */
/* Copyright (c) 1995-2009 IBM Corp.                                  */
/* Copyright (c) 2011- RexxLA                                         */
/* ------------------------------------------------------------------ */
/* netrexx.lang.RexxChannel -- channels for go methods                */
/* ------------------------------------------------------------------ */
/*                                                                    */
/*                                                                    */
/* ------------------------------------------------------------------ */
/* 2025.10.04 MRE Initial                                             */
/* 2025.12.11 MRE Handle concurrent execution                         */
/* ------------------------------------------------------------------ */

package netrexx.lang
options binary nodecimal strictargs strictcase noformat

class RexxChannel implements Serializable
--trace results
  properties private
    queue        = LinkedBlockingQueue
    capacity     = int
    closed       = boolean 0
    unbuffered   = boolean    
    lockObject   = java.lang.Object
    canWrite     = Semaphore
    canRead      = Semaphore
    readComplete = Semaphore   
  
  
/**
  Constructor
    s = 0 : Unbuffered/Synchronous (Rendezvous) - Go-style channel
    s > 0 : Buffered/Asynchronous (Flow control) - Go-style channel
*/
  method RexxChannel(s = int 0)  
    if s = 0 then do
      unbuffered = 1
      capacity   = 1 -- Needs 1 physical slot to hold the item during the handshake
    end
    else do
      unbuffered = 0
      capacity   = s
    end
    queue        = LinkedBlockingQueue(capacity)  
    lockObject   = java.lang.Object()    -- locking object
    canWrite     = Semaphore(capacity)   -- writeable slots availabe 
    canRead      = Semaphore(0)          -- signal data available
    readComplete = Semaphore(0)          -- signal read completed

    return this

/**
  Write to a channel

*/
  method write(o = Object) signals IOException
    do protect lockObject      -- check closed flag
      if closed then signal IOException('Writing to a closed channel')
    end  

    do 
      canWrite.acquire()       -- wait for an available slot or flooding close()
      
      do protect lockObject    -- recheck closed flag
        if closed then do
          canWrite.release() 
          signal IOException('Writing to a closed channel')
        end
      end
      
      queue.put(o)             -- put it on queue

      canRead.release()        -- notify reader(s)
      if unbuffered then do
        readComplete.acquire() -- wait for a reader to send a readComplete

        do protect lockObject  -- recheck closed flag
          if closed then signal IOException('Writing to a closed channel')
        end
      end
    catch InterruptedException
      nop                  
    end
    return

/**
  Read from a channel

*/
  method read() returns Object signals IOException

    o = Object null
  
    loop forever
      canRead.acquire()       -- wait for data available or flooding close()
            
      o = queue.poll()        -- non-blocking, returns null when queue is empty.
      
      if o \= null then do
        if unbuffered then readComplete.release()  -- notify writer
        canWrite.release()    -- release slot
        return o
      end

                              -- queue is empty, check if we should close.
      do protect lockObject   
        if closed then do
          canRead.release() 
          signal IOException('Reading a closed channel')
        end
      end
                              -- queue is empty, but not closing  
                              -- phantom wakeup or race. We loop back acquire again.
    catch InterruptedException
      nop
    end
    return null               -- never reached

/**
  Close a channel

*/
  method close() protect
    do protect lockObject
      if closed then return
      closed = 1
    end
    
                              -- flood the semaphores
                              -- all blocked threads wake up 
                              -- release a number larger than any possible number of threads
    
    canWrite.release(2000000) 
    canRead.release(2000000)
    readComplete.release(2000000)     

