/* IBM Materials Licensed under International Components for Unicode  */
/* Licence version 1.8.1 (ICU Licence) - Property of IBM              */
/* IBM NetRexx                                                        */
/* Copyright (c) 1995-2009 IBM Corp.                                  */
/* Copyright (c) 2011- RexxLA                                         */
/* ------------------------------------------------------------------ */
/* NetRexx language processor                                     mfc */
/* Copyright (c) IBM Corporation 1996, 2000.  All Rights Reserved.    */
/* ------------------------------------------------------------------ */
/* RxVarpool                                                          */
/*                                                                    */
/*  The variables pool manager.  This object manages and maintains    */
/*  the local variables and properties for a program.  It does not    */
/*  actually hold any variables or values.                            */
/*                                                                    */
/*  Variable names are as first used in the program except:           */
/*                                                                    */
/*    -- if Java reserved words they have $ prefixed                  */
/*    -- if they begin with $ they have $ prefixed                    */
/*                                                                    */
/*  Variables generated by the compiler (temporaries, etc.) follow    */
/*  the rules:                                                        */
/*                                                                    */
/*    -- $0  is the source file name                                  */
/*    -- $0x (where x is a letter) is a special name                  */
/*           [none used at present]                                   */
/*    -- $0n (where n is one or more digits) is a class constant      */
/*    -- $n  (where n is one or more digits, the first of which is    */
/*           non-zero) is a temporary variable                        */
/*                                                                    */
/*  In proxies, we use:                                               */
/*    -- $0  interpreter instance (static property)                   */
/*    -- $1  arguments array in a method [name not actually present]  */
/*                                                                    */
/*  Variable pools contain RxVariable objects, indexed by lowercase   */
/*  name.  Two are used:                                              */
/*                                                                    */
/*    curcpool -- class variables (held in the RxClass)               */
/*    curlpool -- local (method) variables (referred from cursor)     */
/*                                                                    */
/*  During execution, only the local pool is used for data values as  */
/*  we have a 'real' class (and instances thereof) to contain         */
/*  properties.  However, we still need/use the curcpool for lookup   */
/*  variables by name.                                                */
/*                                                                    */
/*  In addition, two housekeeping lists are held in the RxClass       */
/*  object:                                                           */
/*                                                                    */
/*    varlist   -- a list of all variables seen, used for cross-      */
/*                 referencing during pass2 only.                     */
/*    varindirs -- a list of all indirect properties seen             */
/*                                                                    */
/* ------------------------------------------------------------------ */
/* Change list (see RxLanguage for master change list)                */
/* 1996.05.31 Initial                                                 */
/* 1996.02.12 Variables changed to allow only a single visible        */
/*            variable of a given name in a class, with no block-     */
/*            scoping of variables in methods.                        */
/* 1996.08.21 Support STRICTCASE                                      */
/* 1996.09.24 Support characters >'\x7f' in identifiers               */
/* 1996.10.06 Local variables now initialized                         */
/* 1997.02.09 Boolean VAR_types                                       */
/* 1997.02.13 Indirect variable collection                            */
/* 1997.07.14 Allow re-pooling of RxVariables, for arguments          */
/* 1998.01.10 Add EXPLICIT option handling                            */
/* 1998.03.08 Allow $ in user names, and don't generate if avoidable. */
/* 1999.04.06 Add warning for unqualified properties [strictprops]    */
/* 2000.02.19 Make cursor based, so there is no 'current varpool'     */
/* 2000.02.19 Move variables to static, object, or local pools        */
/* 2000.04.05 Three pools simplified down to local and class pools    */
/* ------------------------------------------------------------------ */
package COM.ibm.netrexx.process
options binary nodecimal strictcase strictargs

class RxVarpool uses RxVariable

 properties private
  rxt=RxTranslator       -- the boss
  program=RxProgram      -- the program
  parser=RxParser        -- the parser
  classer=RxClasser      -- the class manager

 /* Variable pool constructor/initialization */
 /* [INITVAR in prototype] */
 method RxVarpool(newrxt=RxTranslator)
  rxt=newrxt
  program=rxt.program
  parser=rxt.program.parser
  classer=rxt.classer

 /* CHECKVAR -- check a variable declaration or assignment
    Arg1   is cursor
    Arg2   is variable attributes (if new or known), as in RxVariable
    Arg3   is name of variable
    Arg4/5 are type of variable, and token where that starts
    Arg6/7 are type of new value, and token where that starts
    Arg8   is 1 if rhs is just a Type, 0 if a value given
    Arg9   is the flag to use in crossref (normally automatic from Arg7)

    If Arg4 is null then this is (and must be) a new declaration.
    Arg4 may be null only for a synthetic variable.

    Name is a simple symbol; it is being logically set.

    Returns (old or new) variable reference if OK, error otherwise.

    varspell for the variable should always be used used after a call to
      CHECKVAR, to find the actual (in Java) spelling of the name -- both
      for case and possible prefix of '$'.
 */
 method checkvar(cursor=RxCursor, varatts=int, varname=Rexx,-
                 lhtype=RxType, lhswhere=RxToken,-
                 rhtype=RxType, rhswhere=RxToken,-
                 rhsistype=boolean, flag=char '?') returns RxVariable

  /* first double-check the RHS signature is valid, and qualify if need be */
  /* [this may simplify later] */
  -- say '# looking for:' rhtype.classname rhtype.dimension
  classinfo=classer.findclass(cursor, rhtype, rhswhere, 1)
  if classinfo=null then select
    when rhtype=RxType.NULL_TYPE then nop   -- leave it this way
    when rhtype=RxType.VOID_TYPE then do
      if rxt.pass2 then signal RxError(rxt, rhswhere, 'cannot.assign.no.result')
      -- it's pass1 .. variables may be void during tentative assignment
      end
    otherwise signal RxError(rxt, rhswhere, 'class.not.found', rhtype.classname)
    end

  if flag='?' then do                   -- automatic flag please
    if rhsistype then flag=' '          -- indicator for crossref listing
                 else flag='='
    end

  if program.flag.strictcase
   then keyname=varname.toString()        -- exact lookup
   else keyname=varname.lower().toString()  -- caseless lookup
  -- lookup variable (even if new)
  oldvar=poolget(cursor, keyname)

  if lhtype<>null then do               -- checking an old variable
    if oldvar=null then                 -- sanity check
      signal RxQuit(rxt, lhswhere, 'internal.error', 'RxVarpool: checkvar var new:' keyname)
    if (oldvar.varatts & VAR_CONSTANT)\=0 then
      signal RxError(rxt, lhswhere, 'cannot.change.constant')
    /* multiples allowed .. but type should match */
    /* assert base type is genuine; assigncost will handle dimensions */
    lsig=lhtype.classname
    vsig=oldvar.vartype.classname
    if lsig\==vsig then
      signal RxQuit(rxt, lhswhere, 'internal.error', 'RxVarPool: checkvar sigs:' lsig vsig)
    if rxt.converter.assigncost(cursor, lhtype, rhtype).cost-
      >program.flag.maxassign then
      signal RxError(rxt, rhswhere, 'cannot.assign',-
                     program.babel.typeString(rhtype),-
                     program.babel.typeString(lhtype))
    if program.flag.diag then
      say '# OldVar: ['oldvar.varatts oldvar.vartype.toSig()':'-
                       oldvar.varspell']' rhtype.toSig() 'to' lhtype.toSig()
    addxref(cursor, oldvar, lhswhere, flag, 1) -- always needed, for later check
    return oldvar; end

  /* --- Is a new variable --- */
  if oldvar<>null then   -- sanity check
    signal RxQuit(rxt, lhswhere, 'internal.error', 'RxVarpool: checkvar var not new:' keyname)

  /* 'null' isn't sufficient */
  if rhtype=RxType.NULL_TYPE then
    signal RxError(rxt, lhswhere, 'cannot.declare.null')

  /* If pass2, then some extra checks */
  if rxt.pass2 then do label ispass2
    if classer.isshortref(varname) then
      RxWarn(rxt, lhswhere, 'variable.name.replaces.type', classer.getshortref(varname))
    -- For both the following errors we continue, to avoid spurious
    -- errors later
    if rhsistype then do
      -- Error if type and not tentative assignment
      if (varatts & VAR_CONSTANT)\=0 then
        RxError(rxt, lhswhere, 'constant.must.be.given.value')
      end
     else /* not a type on first assignment */ do
      -- Error if EXPLICIT and a local variable
      if (varatts & VAR_LOCAL)\=0 then
       if program.flag.explicit then
        RxError(rxt, lhswhere, 'no.explicit.declaration')
      end
    end ispass2

  /* === It's new and OK.  Record and return. === */

  /* Change any exotic characters to Unicode escapes for the Java spelling */
  varspell=varname
  car=varspell.toCharArray()
  loop i=car.length-1 to 0 by -1  -- from right
    if car[i]<<='\x7f' then iterate
    varspell=varspell.left(i)-
         ||'\\u'Rexx(car[i]).c2x().right(4, 0) -
         ||varspell.substr(i+2)
    end i

  /* We avoid Java reserved words if possible by prefixing local
     variable names and arguments which are Java reserved words with
     '$'.  We cannot do this with properties (even private ones),
     however; they will fall through and be caught by RxClasser.

     1998.03.08: We also allow $ in variable names; to avoid conflict
       with generated names, these have any leading $ doubled.  Again,
       this cannot be done for properties, so we need to apply the
       restriction elsewhere that these cannot begin with '$0'.
     */
  if (varatts & VAR_PROP)=0 then do
    if varspell.left(1)=='$' then varspell='$'varspell       -- add prefix
     else
      if classer.javakey(varspell) then varspell='$'varspell -- add prefix
    end

  -- now make the variable, after determining if it's abstract
  select
    when cursor.curclass.classinfo.isabstract  then varabstract=boolean 1
    when cursor.curclass.classinfo.isinterface then varabstract=1
    when cursor.curmethod=null                 then varabstract=0
    when cursor.curmethod.isAbstract()         then varabstract=1
    otherwise                                       varabstract=0
    end
  newvar=RxVariable(varname, varspell, lhswhere, varatts, rhtype, varabstract)
  poolput(cursor, keyname, newvar) -- .. and add to pool
  if program.flag.diag then say '# NewVar: ['varatts rhtype.toSig()':' varspell']'

  /* If a property then register it for this class, if unregistered.
     This will take place on pass1 now [1997.04.10], as it will get a
     'void' value if undetermined.  On pass2 we still must look it up,
     to set the new signature if (on pass1) it was set to 'void' due to
     a forward reference. */
  /* Also count it, and take note of it if not static, on all passes */
  /* Also add to the Indirects list, if indirect, on all passes */
  if newvar.isproperty() then do          -- is property
    cursor.curclass.props=cursor.curclass.props+1    -- bump count
    if \newvar.isstaticprop() then        -- non-static property
      cursor.curclass.nonstatics=cursor.curclass.nonstatics+1
    if newvar.isindirect() then
      cursor.curclass.varindirs.addElement(newvar) -- add it to the indirects list
    field=classer.findfield(cursor, 1, 0, 1, 0, cursor.curclass.classinfo,-
                            varspell, RxType[] null, null)
    if field=null then do               -- it's a new property
      -- just register it, indicating it's local
      classer.registerfield(lhswhere, cursor.curclass.classinfo, varspell,-
                            rhtype, newvar.visibility(), newvar.attributes(),-
                            RxType[] null, null, cursor.curclass)
      end
     else do
      -- it's known.  Update the signature if necessary.
      if field.fieldtype=RxType.VOID_TYPE then field.fieldtype=rhtype
      -- [if ambiguous it would have been reported when created]
      end
    newvar.varfield=field               -- save for reuse
    end

  /* If a true local variable (not a property or an argument), add
     local declaration to this method (on pass 2 only).
     It needs initializing if either of the following apply:
       -- user has not specified a value
       -- we are not top-level [this is conservative but safe]
     Initial value is 0 for primitives, null otherwise.
     */
  if varatts=VAR_LOCAL then
   if program.flag.java then
   if rxt.pass2 then do
    /* convert the signature to java-style, and reorder for cosmetics */
    cla=rhtype.classname
    def='[]'.copies(rhtype.dimension)
    /* set up initialization string, if needed */
    if parser.level=2 & \rhsistype then init=''   -- no initialization needed
     else select
      when rhtype=RxType.BOOL_TYPE then init='=false'
      when rhtype.isPrimitive()  then init='=0'
      otherwise                     init='=null'  -- array or object
      end
    program.streamer.outinsert(cla varspell||def||init';',-
                                   cursor.curmethod.methodstartchunk, 2)
    end

  /* Now cross-reference the new variable [always needed] */
  addxref(cursor, newvar, lhswhere, flag, 1)
  return newvar

 /* REPOOLVAR -- re-register a method argument variable
    Arg1 is cursor
    Arg2 is the variable
    Arg3 is 1 if the argument is being given an initial value
    This is an optimization, as method argument variables are registered
    in pass1 and are saved until pass2.
    */
 method repoolvar(cursor=RxCursor, var=RxVariable, init=boolean)
  if program.flag.strictcase
   then keyname=var.varname.toString()         -- exact lookup
   else keyname=var.varname.lower().toString()   -- caseless lookup
  poolput(cursor, keyname, var)              -- add to pool
  if program.flag.diag then say '# RePoolVar: ['var.varspell']' init
  if init then flag=char '='; else flag=' '
  addxref(cursor, var, var.vartoken, flag, 1)-- cross-reference it
  return

 /* REFINDVAR -- quick lookup when we know the variable is in a pool
    Arg1 is cursor
    Arg2 is name of variable
    returns RxVariable object from one of the pools

    Note that this does no checking or cross-referencing, so in general
    is not suitable for use during parsing.
  */
 method refindvar(cursor=RxCursor, varname=Rexx) returns RxVariable
  if program.flag.strictcase
   then keyname=varname.toString()        -- exact lookup
   else keyname=varname.lower().toString()  -- caseless lookup
  return poolget(cursor, keyname)

 /* FINDVAR -- test if a name is that of a NetRexx variable
    Arg1 is cursor
    Arg2 is name of variable
    Arg3 is WHERE for the name (for xref)
    Arg4 is 1 if this is a recordable cross-reference, 0 otherwise
    Arg5 is 1 if this is a set, 0 otherwise [valid iff Arg3=1]
    Arg6 is 1 if this is an unqualified reference, or 2 if an
            unqualified reference where 'this.' is not allowed

    returns RxVariable object if known (exists), null otherwise

    Note that this returns an object for both local variables and
    properties in the current class, and never returns an object for
    external variables.

    A reference to an optional argument in pass1 can only happen from
    another optional argument, and so can be reported as an error in
    this common place.
  */
 method findvar(cursor=RxCursor, varname=Rexx, where=RxToken,-
                isref=boolean, isset=boolean 0,-
                isunqual=int 0) returns RxVariable
  if program.flag.strictcase
   then keyname=varname.toString()        -- exact lookup
   else keyname=varname.lower().toString()  -- caseless lookup

  --if cursor.curexec then
  --  if program.flag.diag then
  --    say '# FindVar:' keyname

  var=poolget(cursor, keyname)
  if var=null then return null          -- not found

  if cursor.curexec then do
    if program.flag.diag then
      say '# FoundVar: ['var.varatts var.vartype.toSig()':' var.varspell']'
    return var
    end

  if (var.varatts & VAR_OPTIONAL)\=0 then
   if rxt.pass1 then
    signal RxError(rxt, where, 'optional.to.optional')

  -- check to warn of an unqualified local property
  if isunqual\=0 then                   -- not qualified ..
   if program.flag.strictprops then     -- .. and checking
   if var.isproperty() then do            -- .. and a property
    -- warning needed
    if var.isstaticprop() then do
      classname=cursor.curclass.classname
      if isunqual=1 then RxWarn(rxt, where, 'static.property.unqualified', classname)
                    else RxWarn(rxt, where, 'static.property.unqualified.alone', classname)

      end
     else do                            -- not static
      if isunqual=1 then RxWarn(rxt, where, 'property.unqualified')
                    else RxWarn(rxt, where, 'property.unqualified.alone')
      end
    end

  if \isref then return var             -- no cross-referencing needed
  if program.flag.diag then
    say '# RefVar: ['var.varatts var.vartype.toSig()':' var.varspell']'
  if isset then flag=char '='; else flag=' '
  addxref(cursor, var, where, flag, isset)   -- always needed
  return var

 /* GETINDIRECTS -- return an array of Indirect properties
    returns an array of RxVariables
    */
 method getindirects(cursor=RxCursor) returns RxVariable[]
  list=RxVariable[cursor.curclass.varindirs.size()]
  cursor.curclass.varindirs.copyInto(list)
  return list

 /* ADDXREF -- add a line reference to the cross-reference line
               for a variable.
    Arg1 is cursor
    Arg2 is the variable object
    Arg3 is the WHERE for the variable name
    Arg4 is a flag to append to the line number ('=' or ' ')
    Arg5 is 1 if we are setting the var, or 0 for a reference

    This has to be called, even if not cross-referencing, so the 'set
    but not used' check can be made later.
    */
 method addxref(cursor=RxCursor, var=RxVariable, tok=RxToken,-
                flag=char, set=boolean) private
  if \rxt.pass2 then return        -- only cross-reference on pass 2
  /* say '# Addxref:' var.varname',' tok.line',' flag */
  if tok=null then tok=RxToken(';', 0, 0, 0, null)     -- dummy token
  if var.varrefs=null then do      -- first reference/use
    cursor.curclass.varlist.addElement(var)  -- add it to cross-reference list
    var.varrefs=StringBuffer(8).append(tok.line)
    end
   else
    var.varrefs.append(' ').append(tok.line)
  if \set      then var.varseen=1       -- has been a reference
  if flag\=' ' then var.varrefs.append(flag)
  return

 /* CHECKCLASSUNUSED -- check variables associated with a class
    Arg1 is cursor
    */
 method checkclassunused(cursor=RxCursor)
   if \rxt.pass2 then signal RxQuit(rxt, null, 'internal.error', 'RxVarPool: CCU')
   enum=cursor.curclass.curcpool.elements()  -- enumerate variables in the pool
   loop while enum.hasMoreElements()         -- while some left
     var=RxVariable enum.nextElement()       -- get next
     if var.isprivateprop() then warnclassunused(var) -- check for warnings
     end
   return

 /* CHECKMETHODUNUSED -- check variables associated with a method
    Arg1 is cursor
    */
 method checkmethodunused(cursor=RxCursor)
   if \rxt.pass2 then signal RxQuit(rxt, null, 'internal.error', 'RxVarPool: CMU')
   -- only local pool is interesting
   enum=cursor.curlpool.elements()      -- enumerate the variables in the pool
   loop while enum.hasMoreElements()    -- while some left
     var=RxVariable enum.nextElement()  -- get next
     warnmethodunused(var)              -- warn if unused
     end
   return

 /* warnclassunused -- check a private property for warnings
    Arg1 is the variable to test

    Warn if the property is unused, or UNUSED property is in fact used.
    */
 method warnclassunused(var=RxVariable) private
  if var.varseen then do                     -- has been seen
    if var.isunused() then RxWarn(rxt, var.vartoken, 'property.not.unused')
    return
    end
  if var.varabstract then return             -- cannot be seen
  if \var.isunused() then RxWarn(rxt, var.vartoken, 'property.not.used')
  return

 /* warnmethodunused -- warn if a method variable/argument is unused
    Arg1 is the variable to test
    The special ARG variable in main() is allowed to be unused.
    */
 method warnmethodunused(var=RxVariable) private
  if var.varseen then return                 -- has been seen
  if var.varabstract then return             -- cannot be seen
  select
    when var.islocal() then
      RxWarn(rxt, var.vartoken, 'variable.not.used')
    when var.isargument() then do
      if var.varmain then return             -- don't warn of unused ARG
      -- Only give the method argument warning if we are picky about methods.
      if \program.flag.strictargs then return -- not being picky
      if program.flag.diag then
        say '# anu:' var.varspell var.varrefs.toString()
      RxWarn(rxt, var.vartoken, 'argument.not.used')
      end
    otherwise  -- a property, shouldn't ever get here
      signal RxQuit(rxt, null, 'internal.error', 'RxVarpool: prop in local pool:' var.varspell)
    end
  return

 /* poolget -- find a variable in one of the three pools
    Arg1 is cursor
    Arg2 is the keyname [exact case for strictcase, lowercase otherwise]
    returns found RxVariable, or null if not in any of the pools
    */
 method poolget(cursor=RxCursor, keyname=String) returns RxVariable private
  var=RxVariable null
  if cursor.curlpool\=null then /* in a method */ do
    var=RxVariable cursor.curlpool.get(keyname)   -- try local pool
    end
  if var=null then do                             -- not in local
    -- possibly no class; e.g., in NUMERIC
    if cursor.curclass\=null then do
      var=RxVariable cursor.curclass.curcpool.get(keyname)
      end
    end
  return var

 /* poolput -- put a variable into the appropriate pool
    Arg1 is cursor
    Arg2 is the keyname [exact case for strictcase, lowercase otherwise]
    Arg3 is the variable
    */
 method poolput(cursor=RxCursor, keyname=String, var=RxVariable) private
  select
    when (var.varatts & VAR_PROP)=0 then
      cursor.curlpool.put(keyname, var)           -- local pool
    otherwise
      cursor.curclass.curcpool.put(keyname, var)  -- class pool
    end
  return

 /* SHOWXREF -- display cross-reference listing for a class
    Arg1 is cursor

    Plan is to add a crossref2, where names are broken down to class and
    method scope, and perhaps add method cross-reference, too.
    */
 method showxref(cursor=RxCursor)
  first=boolean 1                       -- delay header

  /* Make an array of references to the variables */
  num=cursor.curclass.varlist.size()           -- number of variables
  list=RxVariable[num]
  cursor.curclass.varlist.copyInto(list)

  /* Spin through, reducing signatures to short forms (if unambiguous),
     and measuring the longest of name and signature for later
     formatting.
     */
  maxname=0; maxctype=0
  loop i=0 for num
    var=list[i]
    if var.varname.length().toint()>maxname then
      maxname=var.varname.length()             -- longest so far
    /* use the short signature, if not ambiguous */
    var.varctype=program.babel.typeConcise(var.vartype)
    if var.varctype.length().toint()>maxctype then
      maxctype=var.varctype.length()           -- longest so far
    end i

  /* Now sort and display.
     Simple bubble sort is OK, as classes should not be huge.
     [1997.12.20 sanity check: Rexx class, 450 variables, -nocrossref
     saves 2%, so sorting is less than this.]

     We sort by name then line, as bubble sort isn't stable (if it were
     we could just sort on names, as entries are originally sorted by
     line). */

  thisclassname=cursor.curclass.classinfo.fullname
  thisclassnum=cursor.curclass.classnum

  loop i=0 to num-1
    vi=list[i]
    loop j=i+1 to num-1
      vj=list[j]
      if vi.varname.OpLt(null, vj.varname) then iterate
      if vi.varname==vj.varname then
        if vi.vartoken.line<=vj.vartoken.line then iterate
      /* time for a swap */
      list[j]=vi; list[i]=vj
      vi=vj
      end j

    /* Now layout variables that we want */
    refs=vi.varrefs.toString()
    varatts=vi.varatts
    select
      when (varatts & VAR_LOCAL)\=0 then id='v'  -- local variable
      when (varatts & VAR_ARG)\=0 then do
        id='a'                                              -- argument
        if vi.varmain then                   -- the magic ARG
         if Rexx(refs).words().toint()=1         -- .. with only setup
          then iterate i                     -- .. so ignore
        end
      when (varatts & VAR_CONSTANT)\=0 then id='c'     -- a constant
      when (varatts & VAR_STATIC)\=0   then id='s'     -- a static
      otherwise id='p'                                 -- a property
      end
    if first then do
      first=0
      if thisclassnum>1 then program.streamer.crossref('') -- space
      program.streamer.crossref('--- Variables for class' thisclassname '---')
      end
    program.streamer.crossref(vi.varname.left(maxname)-
                                  Rexx(vi.varctype).left(maxctype) id refs)
    end i

  if first then                              -- no variables
   if program.classes.size()>1 then do         -- and more than one class
    if thisclassnum>1 then program.streamer.crossref('')    -- space
    program.streamer.crossref('--- No variables in class' thisclassname '---')
    end
  return

