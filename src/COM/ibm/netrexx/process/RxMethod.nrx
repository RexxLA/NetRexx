/* IBM Materials Licensed under International Components for Unicode  */
/* Licence version 1.8.1 (ICU Licence) - Property of IBM              */
/* IBM NetRexx                                                        */
/* Copyright (c) 1995-2009 IBM Corp.                                  */
/* Copyright (c) 2011- RexxLA                                         */
/* ------------------------------------------------------------------ */
/* NetRexx language processor                                     mfc */
/* Copyright (c) IBM Corporation 1996, 2000.  All Rights Reserved.    */
/* ------------------------------------------------------------------ */
/* RxMethod                                                           */
/*                                                                    */
/*   An object that represents a Method instruction.                  */
/*                                                                    */
/*   Structural errors during method start are all Quits, as if the   */
/*   method isn't set up correctly then the rest of the method is     */
/*   likely to be meaningless.                                        */
/* ------------------------------------------------------------------ */
/* Change list (see RxLanguage for master change list)                */
/* 1996.05.29 Initial                                                 */
/* 1996.08.29 Signals processing and checking                         */
/* 1996.08.30 Overrides checking                                      */
/* 1996.08.31 Missing Return, of flavours                             */
/* 1996.11.29 Override checking in pass1, for name-spelling           */
/* 1997.02.13 Indirect access methods pattern-checking, etc.          */
/* 1997.05.31 Add Deprecated option                                   */
/* 1997.06.14 Test for forward-reference Signals                      */
/* 1997.06.21 Add Shared attribute                                    */
/* 1997.06.30 Overridden methods might be deprecated                  */
/* 1997.07.01 General rework of options handling for better messages  */
/* 1997.07.12 Major reorganization for RxClauseParser                 */
/* 1997.07.19 Addition of super() done by endmethod                   */
/* 1997.07.22 Signals list may use superclass of checked Exception    */
/* 1997.08.04 Start conversion to use RxCode objects                  */
/* 1997.12.17 Reparse argument expressions on pass2                   */
/* 1998.04.30 Use Methodatts                                          */
/* 1999.10.19 Add method body clause list [used iff exec]             */
/* 2000.02.28 Allow the construction of synthetic methods             */
/* ------------------------------------------------------------------ */
package COM.ibm.netrexx.process
options binary nodecimal strictcase strictargs

class RxMethod implements RxClauseParser uses RxCode, RxField
 properties shared
  -- fixed or parse-time attributes of a method (others must be in cursor)
  methodname         =Rexx         -- name of this method
  methodprogram      =RxProgram    -- the program we belong to
  methodclause       =RxClause     -- our clause (with argument expressions)
  methodset          =Rexx         -- RexxSet object name for this method
  methodtrace        =Rexx         -- RexxTrace object name for this method
  methodrettype      =RxType       -- return type
  methodrettypeknown =boolean 0    -- return type (signature) is confirmed
  methodconstructor  =boolean 0    -- method is a constructor
  methodstartchunk   =int 0        -- where local declares will go
  methodhadnumeric   =boolean 0    -- method includes a NUMERIC instruction
  methodtracechange  =boolean 0    -- method includes a TRACE with effect
  methodhadthissuper =boolean 0    -- method includes a this()/super() call
  methodbinary       =boolean 0    -- method is binary (inherited or explicit)
  methodprotected    =boolean 0    -- method is protected
  methodstatic       =boolean 0    -- method is static
  methodsynthetic    =boolean 0    -- method is synthetic
  methoddefault      =boolean 0    -- method is implied (default method)
  methodclauses      =RxClause     -- -> first clause in method (used iff exec)
  methodprotopool    =Hashtable    -- prototype local variables pool
  methodargvars      =RxVariable[] -- variables corresponding to arguments
  methodargcode      =RxCode[]     -- initialization codes for arguments
  methodtracedefer   =boolean 1    -- defer trace code generation until safe
  methodtracevars    =Rexx 0       -- dictionary of method-level TRACE VAR names
  methodmaxtrace     =int RexxTrace.OFF -- method maximum tracing level

 properties constant shared
  SYN_DEFCON         =int 1        -- synthetic default constructor
  SYN_EMPTY          =int 2        -- synthetic empty method (adapter)
  SYN_INDIRECT       =int 3        -- synthetic indirect method

  methodargends=RxToken.COMMA||RxToken.RPAR  -- used by RxInterpreter, too

 properties private
  rxt    =RxTranslator             -- the boss
  parser =RxParser                 -- our parser
  pooler =RxVarpool                -- our variables manager
  pcursor=RxCursor                 -- our parsing cursor
  classer=RxClasser                -- class manager
  tokens =RxToken[]                -- local reference

  methodtoken        =RxToken      -- Token at start of method
  methodfields       =RxField[]    -- RxField objects for this method
  methodnative       =boolean 0    -- method is native (system-supplied)
  methodabstract     =boolean 0    -- method is abstract
  methoddeprecated   =boolean 0    -- method is deprecated
  methodempty        =boolean 0    -- method has no body
  methodvisib        =int          -- visibility of this method [RxField.VIS_]
  methodatts         =int          -- attributes of this method [RxField.ATT_]
  methodsyntype      =int          -- SYN_ type of this method, if synthetic
  methodpropname     =Rexx         -- associated property name if SYN_INDIRECT
  methodsuperchunk   =int 0        -- where super() will go, if constructor
  methodsetpending   =Rexx ''      -- pending creation statement
  methodtracepending =Rexx ''      -- ..
  methodargpending   =Rexx ''      -- ..
  staticandfinal     =boolean 0    -- both STATIC and FINAL specified [warning]
  staticimplied      =boolean 0    -- STATIC implied for 'main' [warning]
  impliedreturns     =boolean 0    -- method had RETURNS Rexx implied
  impliedreturnstok  =RxToken null -- .. by whomsoever

  argvar             =RxVariable   -- the ARG local variable [pass2, default only]
  deferred           =Rexx ''      -- deferred lines of code
  defers             =int 0        -- count of deferred lines of code
  classinfo          =RxClassInfo  -- local copy

  overrides          =Vector(10)   -- list of found overridden fields
  explicitsignals    =Vector(8)    -- SIGNALS given explicitly [RxException]
  methodsignalschunks=Rexx ''      -- where to put THROWS insert(s)
                                   -- [blank-separated list if more than one]

  describe   =Rexx                 -- method descriptor string

  /* Argument descriptors, valid for explicit methods */
  optargfirst=0                    -- number of first optional arg, 0 if none
  optargtoken=RxToken null         -- .. and its whereabouts

 /* Construct an object from the current clause */
 /* This is used for all methods, including implied and synthetic ones */
 method RxMethod(newrxt=RxTranslator)
  rxt    =newrxt                        -- the boss
  classer=rxt.classer                   -- class manager
  methodprogram=rxt.program             -- our program
  parser =methodprogram.parser          -- our parser
  pooler =methodprogram.pooler          -- our variables manager
  pcursor=parser.cursor                 -- our parsing cursor
  methodclause=pcursor.curclause        -- our clause
  classinfo=pcursor.curclass.classinfo  -- local copy
  methodbinary=pcursor.curclass.classbinary  -- inherited binary setting

 /* Pass processing */
 method scan(pass=int)
  if pass=0 then signal RxQuit(rxt, tokens[0], 'internal.error', 'RxMethod: 0')
  tokens=methodclause.tokens            -- local reference for scanning
  beginmethod()                           -- initialize
  if pass=1 then scan1()
            else scan2()
  beginmethod2()

 /* ----------------------------------------------------------------- */
 /* Pass1 checking                                                    */
 /* ----------------------------------------------------------------- */
 method scan1
  if tokens[1].type\=RxToken.SP  then signal RxQuit(rxt, tokens[1], 'method.name.expected')
  if tokens[2].type\=RxToken.SYM then signal RxQuit(rxt, tokens[2], 'method.name.expected')

  methodname=tokens[2].value
  methodtoken=tokens[2]
  if rxt.program.flag.strictcase
    then methodconstructor=(methodname==classinfo.shortname)
    else methodconstructor=(methodname.OpEq(null, classinfo.shortname))

  if methodconstructor then do
    if classinfo.isinterface then
      signal RxQuit(rxt, methodtoken, 'no.constructors.in.interface.class')
    /* Force name to match spelling of class */
    methodname=classinfo.shortname
    describe='constructor'
    end
   else do;
    describe='method'
    end

  methodmaxtrace=pcursor.curclass.tracelevel -- includes pre-class TRACE

  /* During pass1, say who we are before we start loading classes (if
       verbose>3).
     Unfortunately, that means we can't indicate functions (needs
       CONSTANT/STATIC kw).  [This is perhaps an argument for a FUNCTION
       instruction :-)]
     Hence on pass1 we just describe as 'method', and on pass2 (below)
       use the more accurate description.
     */
  if rxt.program.flag.verbose>3 then
    rxt.say('    method' methodname '[line' tokens[0].line']')
   else if rxt.program.flag.diag then
    say '# --- method' methodname '[line' tokens[0].line']'

  -- We have to process the words after the argument list first, because
  -- the validity of references in that list depends on the STATICality.
  -- First determine the end of the arguments (if any)
  if tokens[3].type\=RxToken.LPAR then afterarg=3 -- definitely no arguments
   else do     -- argument list expected
    endpar=RxClauser.match(tokens, 3)
    if endpar=0 then signal RxQuit(rxt, tokens[3], 'argument.list.unfinished')
    afterarg=endpar+1
    end

  /* ----- Collect sub-keyword parts ----- */
  abstract   =boolean 0            -- method is abstract
  deprecated =boolean 0            -- method is deprecated
  final      =boolean 0            -- method is final
  native     =boolean 0            -- method is native
  protect    =boolean 0            -- method is synchronized
  static     =boolean 0            -- method is static
  binary     =boolean 0            -- method is explicitly binary
  rettype    =RxType null          -- RETURNS determined type
  visib      =int VIS_UNKNOWN      -- visibility
  access     =Rexx                 -- [last seen, for error]
  modifier   =Rexx ''              -- modifier
  signals    =Rexx ''              -- signals list

  loop n=afterarg by 1     -- loop along tokens
    tok=tokens[n]; t=tok.type
    if t=RxToken.SP then iterate
    if t=RxToken.END then leave /* done */
    if t<>RxToken.SYM then signal RxQuit(rxt, tok, 'keyword.expected')
    select
      when parser.iskey(tok.value, 'RETURNS') then do
        if rettype\=null then signal RxQuit(rxt, tok, 'duplicate.keyword')
        n=n+1; tok=tokens[n]; t=tok.type
        if t<>RxToken.SP then signal RxQuit(rxt, tok, 'type.expected')
        n=n+1; tok=tokens[n]; t=tok.type
        if t<>RxToken.SYM then signal RxQuit(rxt, tok, 'type.expected')
        term=rxt.tparser.parseterm(pcursor, n, 1) -- ONRHS as Type allowed
        next=term.endoff+1
        if term.group\=S_TYPE then do
          if term.group=S_VAR then -- improved message...
            signal RxQuit(rxt, tok, 'type.not.var.expected')
          signal RxQuit(rxt, tok, 'type.expected')
          end
        if methodconstructor then
         if term.type\=classinfo.type then
          signal RxQuit(rxt, tok, 'constructor.returns.must.match.class')
        rettype=term.type
        n=next-1
        end
      when parser.iskey(tok.value, 'SIGNALS') then do
        if signals\=='' then signal RxQuit(rxt, tok, 'duplicate.keyword')
        n=n+1; tok=tokens[n]
        if tok.type==RxToken.SP then n=n+1          -- step over blank
        loop forever
          tok=tokens[n]
          term=rxt.tparser.parseterm(pcursor, n, 1) -- ONRHS as Type expected
          next=term.endoff+1
          if term.group<>S_TYPE then
            signal RxQuit(rxt, tok, 'exception.type.expected')
          if term.type.isarray() then
            signal RxQuit(rxt, tok, 'simple.exception.expected')
          siginfo=rxt.classer.findclass(pcursor, term.type, tok, 1)
          signals=signals||siginfo.type.classname -- for pass1 registration
          /* Add signal to list of explicit signals for later checking
             and code generation during ENDMETHOD */
          if rxt.program.flag.diag then
            say '#' parser.level 'add signal' siginfo.type.toSig()
          do
            -- This may report 'not throwable' as an RxError
            excep=RxException(pcursor, siginfo, tok)   -- construct
          catch RxError
            signal RxQuit                              -- transmute to Quit
          end
          /* Add unless it is already there */
          if excep.find(explicitsignals)=null
           then explicitsignals.addElement(excep)
          n=next; if tokens[n].type<>RxToken.COMMA then leave
          signals=signals','
          n=n+1
          end /* collecting signals */
        n=n-1
        end
      when parser.iskey(tok.value, 'PUBLIC') then do
        if visib\=VIS_UNKNOWN then signal RxQuit(rxt, tok, 'duplicate.visibility', access)
        access=tok.value
        visib=VIS_PUB
        end
      when parser.iskey(tok.value, 'INHERITABLE') then do
        if visib\=VIS_UNKNOWN then signal RxQuit(rxt, tok, 'duplicate.visibility', access)
        if classinfo.isinterface then
          signal RxQuit(rxt, tok, 'not.allowed.in.interface')
        access=tok.value
        visib=VIS_INHER
        end
      when parser.iskey(tok.value, 'SHARED') then do
        if visib\=VIS_UNKNOWN then signal RxQuit(rxt, tok, 'duplicate.visibility', access)
        if classinfo.isinterface then
          signal RxQuit(rxt, tok, 'not.allowed.in.interface')
        access=tok.value
        visib=VIS_SHAR
        end
      when parser.iskey(tok.value, 'PRIVATE') then do
        if visib\=VIS_UNKNOWN then signal RxQuit(rxt, tok, 'duplicate.visibility', access)
        if classinfo.isinterface then
          signal RxQuit(rxt, tok, 'not.allowed.in.interface')
        access=tok.value
        visib=VIS_PRIV
        end
      when parser.iskey(tok.value, 'CONSTANT') then do
        if modifier\=='' then signal RxQuit(rxt, tok, 'duplicate.modifier', modifier)
        if classinfo.isinterface then
          signal RxQuit(rxt, tok, 'not.allowed.in.interface')
        if methodconstructor then
          signal RxQuit(rxt, tok, 'not.allowed.for.constructor')
        describe='function'
        static=1; final=1
        modifier='constant'
        end
      when parser.iskey(tok.value, 'ABSTRACT') then do
        if modifier\=='' then signal RxQuit(rxt, tok, 'duplicate.modifier', modifier)
        if classinfo.isadapter then
          signal RxQuit(rxt, tok, 'not.allowed.in.adapter')
        if methodconstructor then
          signal RxQuit(rxt, tok, 'not.allowed.for.constructor')
        abstract=1
        modifier='abstract'
        end
      when parser.iskey(tok.value, 'FINAL') then do
        if modifier\=='' then do
          if static then do
            staticandfinal=1       -- warn on pass 2
            modifier='constant'
            end
           else signal RxQuit(rxt, tok, 'duplicate.modifier', modifier)
          end
         else modifier='final'
        if classinfo.isinterface then
          signal RxQuit(rxt, tok, 'not.allowed.in.interface')
        final=1
        end
      when parser.iskey(tok.value, 'STATIC') then do
        if modifier\=='' then do
          if final then do
            staticandfinal=1       -- warn on pass 2
            modifier='constant'
            end
           else signal RxQuit(rxt, tok, 'duplicate.modifier', modifier)
          end
         else modifier='static'
        if classinfo.isinterface then
          signal RxQuit(rxt, tok, 'not.allowed.in.interface')
        if methodconstructor then
          signal RxQuit(rxt, tok, 'not.allowed.for.constructor')
        describe='function'
        static=1
        end
      when parser.iskey(tok.value, 'NATIVE') then do
        if modifier\=='' then signal RxQuit(rxt, tok, 'duplicate.modifier', modifier)
        if classinfo.isinterface then
          signal RxQuit(rxt, tok, 'not.allowed.in.interface')
        if methodconstructor then
          signal RxQuit(rxt, tok, 'not.allowed.for.constructor')
        native=1
        modifier='native'
        end
      when parser.iskey(tok.value, 'PROTECT') then do
        if protect then signal RxQuit(rxt, tok, 'duplicate.keyword')
        if classinfo.isinterface then
          signal RxQuit(rxt, tok, 'not.allowed.in.interface')
        protect=1
        end
      when parser.iskey(tok.value, 'BINARY') then do
        if binary then signal RxQuit(rxt, tok, 'duplicate.keyword')
        binary=1
        end
      when parser.iskey(tok.value, 'DEPRECATED') then do
        if deprecated then signal RxQuit(rxt, tok, 'duplicate.keyword')
        -- deprecated isn't allowed in an interface as it would be
        -- unimplementable without warnings; whole class should be deprecated
        if classinfo.isinterface then
          signal RxQuit(rxt, tok, 'not.allowed.in.interface')
        -- We cannot safely add /** @deprecated */ later if comments pass through
        if rxt.program.flag.comments then RxWarn(rxt, tok, 'deprecated.not.available')
         else deprecated=1
        end
      otherwise signal RxQuit(rxt, tok, 'not.a.keyword', tok.value)
      end
    end n

  /* --- We have the keywords; semantic check and record --- */
  if visib==VIS_UNKNOWN then visib=VIS_PUB   -- default
  methodvisib=visib                     -- save for pass2/endmethod

  if pcursor.curclass.classinfo.isinterface then do
    abstract=1                          -- forced abstract
    protect=0                           -- PROTECT is a nop
    end
  if pcursor.curclass.classinfo.isabstract | methodconstructor then do
    protect=0                           -- PROTECT is a nop
    end

  if binary then methodbinary=1         -- save permanent setting
  if native   then methodnative=1       -- ..
  if abstract then methodabstract=1     -- ..
  if protect  then methodprotected=1    -- ..
  if deprecated then methoddeprecated=1 -- ..

  if static then do
    if abstract then
      signal RxQuit(rxt, methodtoken, 'static.method.cannot.be.abstract')
    if pcursor.curclass.classinfo.isdependent then
      signal RxQuit(rxt, methodtoken, 'dependent.method.cannot.be')
    methodstatic=1                      -- save
    pcursor.curstatic=1                 -- .. and set context
    end
   else do -- non static; unless a constructor we have an instance now
    if \methodconstructor then pcursor.curthis=this
    end

  if abstract | native then methodempty=1
                       else methodempty=0

  if methodconstructor then rettype=pcursor.curclass.classinfo.type
  if rettype=null then rettype=RxType.VOID_TYPE  -- may change later
                  else methodrettypeknown=1  -- .. or not
  methodrettype=rettype                      -- for RETURN checks

  /* --- Now collect any arguments --- */
  -- this is completed in pass1 [i.e., we don't allow forward references
  -- to other methods in the same class in an argument list, at present.
  -- This could be improved, at least for simple cases, later.
  n=3                         -- back to start of possible argument list
  if tokens[n].type\=RxToken.LPAR then do -- definitely no arguments
    methodargvars=RxVariable[0]
    methodargcode=RxCode[0]
    end
   else do label collectargs  -- possibly have some arguments
    arglist =Vector(10)       -- list of RxVariable items
    arginits=Vector(10)       -- list of initialization RxCodes
    -- In constructors, no reference to instance is allowed in the
    -- argument expressions, as object hasn't been constructed (so
    -- cursor.curthis is null)
    n=n+1
    if tokens[n].type=RxToken.RPAR then n=4  -- empty argument list
     else loop n=n by 1
      /* If an RxError in this loop, if an invalid expression, raise
         RxQuit (abandon the method instruction) */
      /* "var", or "var=expr" [type allowed] expected */
      tok=tokens[n]; tn=tok.type
      if tn<>RxToken.SYM then signal RxQuit(rxt, tok, 'argument.name.expected')
      oname=tok.value                   -- get name
      name=oname; nametoken=tok         -- save name and its whereabouts
      -- don't warn for strictprops, here [is an error at present]
      var=pooler.findvar(pcursor, name, nametoken, 0, 0, 0)
      if var\=null then do
        if (var.varatts & RxVariable.VAR_ARG)\=0 then details='argument'
                                                 else details='property'
        signal RxQuit(rxt, nametoken, 'argument.name.is.'details)
        end
      n=n+1; tok=tokens[n]; tn=tok.type
      if tn=RxToken.OP then op=tok.value; else op='?'
      if op\=='=' then do
        if tn<>RxToken.COMMA then if tn<>RxToken.RPAR then
          signal RxQuit(rxt, tok, 'equals.or.comma.expected')
        exprtoken=nametoken
        code=RxCode(S_TYPE, RxType.REXX_TYPE, null)    -- empty code object
        end
       else /* assignment form */ do
        n=n+1 /* step past '=' */
        exprtoken=tok
        -- NB, type allowed in prototype
        code=rxt.eparser.parseexpr(pcursor, 1, n, methodargends, null)
        if code.group=S_LIT then   -- we choose type
          rxt.converter.litexpr(pcursor, code)
        n=code.endoff+1
        tok=tokens[n]; tn=tok.type
        end /* assignment */
      typeonly=(code.group=S_TYPE)
      /* Now register the variable -- we already know it's not a duplicate. */
      if typeonly then varatts=RxVariable.VAR_ARG
                  else varatts=RxVariable.VAR_ARG+RxVariable.VAR_OPTIONAL
      var=pooler.checkvar(pcursor, varatts, name, null, nametoken,-
                          code.type, exprtoken, typeonly)
      arglist.addElement(var)      -- record it in the arguments list
      arginits.addElement(code)    -- record initialization code [if any]

      /* check semantics of optional arguments, and record first */
      if typeonly then do    -- just type
        if optargfirst>0 then signal RxQuit(rxt, exprtoken, 'optional.arg.must.have.value')
        end
       else /* an optional */ do
        if optargfirst=0 then do
          optargfirst=arglist.size()      -- record first
          optargtoken=nametoken         -- ..
          end
        end
      if tn==RxToken.RPAR then leave
      if tn<>RxToken.COMMA then
        signal RxQuit(rxt, tok, 'comma.or.right.parenthesis.expected')
      catch RxError
        signal RxQuit
      end n /* collecting args */
    n=n+1 /* step over the ')' */

    finally
      args=arglist.size()
      methodargvars=RxVariable[args]
      arglist.copyInto(methodargvars)
      methodargcode=RxCode[args]
      arginits.copyInto(methodargcode)
    end collectargs

  /* Now semantic checks on arguments, etc. */
  if methodempty & optargfirst>0 then do
    if abstract then signal RxQuit(rxt, optargtoken, 'abstract.cannot.have.optional')
                else signal RxQuit(rxt, optargtoken, 'native.cannot.have.optional')
    end

  /* Register argument variables in empty methods as abstract: 'no
     further references expected' */
  if methodempty then do
    loop i=0 for methodargvars.length
      methodargvars[i].varabstract=1
      end i
    end

  /* signals list is handled later, in endmethod */

  /* Next check is for Java implementation only */
  if modifier=='' then                       -- no explicit modifier
   if methodname=='main' then                -- the special name
   if methodargvars.length=1 then            -- exactly one argument
   if \abstract then do label maincheck      -- static not allowed if abstract
    var=methodargvars[0]                     -- get the first
    if var.vartype\=RxType.STRINGARRAY_TYPE then leave maincheck -- not String[]
    modifier='static'; static=1
    staticimplied=1
    end maincheck


  /* Built the attributes flags */
  methodatts=0
  if native     then methodatts=methodatts | ATT_NATIVE
  if static     then methodatts=methodatts | ATT_STATIC
  if final      then methodatts=methodatts | ATT_FINAL
  if abstract   then methodatts=methodatts | ATT_ABSTRACT
  if protect    then methodatts=methodatts | ATT_PROTECT
  if deprecated then methodatts=methodatts | ATT_DEPRECATED

  /* Now register the method(s): optional first */
  args=methodargvars.length                  -- number of arguments
  if optargfirst=0 then optarg=args+1        -- make truthful number
                   else optarg=optargfirst
  /* First determine the argument list for each variety of method and
     do the override checking.  We have to do this before registering or
     code generation in case the name spelling (case) changes. */
  spellname=''                     -- name spelling, if not the original
  methodargtypes=Vector(args)      -- RxType[] lists for methods
  loop methnum=optarg to args+1    -- number of methods to generate
    methargs=methnum-1             -- arguments in this method

    /* Build the arguments type array */
    thisargtypes=RxType[methargs]
    loop i=0 for methargs          -- build signature array
      thisargtypes[i]=methodargvars[i].vartype
      end i
    methodargtypes.addElement(thisargtypes)  -- save for spin2

    /* Collect all fields that are overridden.
       This is needed on pass1 so we can correct the spelling (case) of
       methodname, if necessary.  Checks are done in pass2. */
    /* Make list of superclass and interfaces */
    -- Resolve the interface names, if needed [only in 0-length case, in fact]
    if classinfo.impinfos=null then classer.findimps(pcursor, classinfo, null)
    /* add superclass to front of list */
    ccount=classinfo.impinfos.length+1
    classlist=RxClassInfo[ccount]
    classlist[0]=classinfo.superinfo    -- fixed slot for Super
    System.arraycopy(classinfo.impinfos, 0, classlist, 1, ccount-1)
    -- classlist is now array of classinfos from which we inherit
    loop cc=0 for ccount
      checkinfo=classlist[cc]
      if checkinfo=null then iterate    -- [i.e., superclass null -- rare]
      if methodconstructor then do
        if cc>0 then iterate            -- constructor cannot be in interface
        methname=checkinfo.shortname
        end
       else methname=methodname
      -- Look for the method above us (only found if visible)
      efield=classer.findfield(pcursor, 0, 1, 0, 0, checkinfo, methname,-
                               thisargtypes, null)
      if efield=null then iterate                      -- no match found
      if efield.fieldcost\=0 then iterate              -- not exactly overriding
      if efield.fieldambig then                        -- trouble...
        RxError(rxt, methodtoken, 'ambiguous.override')
      -- if we searched an 'implements' class we are only interested in
      -- abstract fields [B&B check]
      if cc>0 then if \efield.isAbstract() then iterate
      -- new override or potential implement found
      overrides.addElement(efield)                     -- save it
      if \methodconstructor then do                    -- name spelling
        if spellname\=='' then
         if spellname\==efield.fieldname then
          if \efield.fieldambig then                   -- [already reported]
           RxError(rxt, methodtoken, 'ambiguous.override')
        spellname=efield.fieldname
        end
      end -- each class
    end methnum

  if spellname\=='' then if methodname\==spellname then do
    methodname=spellname           -- update/preserve
    if rxt.program.flag.diag then say '# method name spelled' spellname
    end

  /* Now actually register the fields */
  togen=args+2-optarg              -- number of methods to generate
  methodfields=RxField[togen]      -- slots to save fields
  loop methnum=optarg for togen    -- for number of methods to generate
    methargs=methnum-1             -- arguments in this method
    -- retrieve the signature array, saved in last loop
    thisargtypes=RxType[] methodargtypes.elementAt(methnum-optarg)

    /* See if we exist already in this class [ignore exceptions] */
    mfield=classer.findfield(pcursor, 1, 1, 0, 0, classinfo,-
                             methodname, thisargtypes, null)
    if mfield\=null                                    -- found method
     then if mfield.fieldcost=0                        -- really is the same
     then signal RxQuit(rxt, methodtoken, 'duplicate.method.signature',-
                        mfield.fieldname,-
                        methodprogram.toConciseString(thisargtypes))
    /* [without fieldcost check we may have multiples anyway] */
    field=classer.registerfield(methodtoken, classinfo, methodname,-
                                methodrettype, methodvisib, methodatts,-
                                thisargtypes, signals, this)
    methodfields[methnum-optarg]=field  -- save the field
    end methnum

 /* ----------------------------------------------------------------- */
 /* Pass2 checking                                                    */
 /* ----------------------------------------------------------------- */
 method scan2
  /* Progress report.  See above for pass 1 */
  if rxt.program.flag.verbose>1 then
    rxt.say('   ' describe toConciseString())

  -- If not a constructor or static then show we have an instance now
  if \methodstatic then if \methodconstructor then pcursor.curthis=this

  if staticandfinal then RxWarn(rxt, methodtoken, 'static.and.final.is.constant')
  if staticimplied then RxWarn(rxt, methodtoken, 'main.assumed.static', 'String[]')

  /* Warnings and errors for malformed or misspelled indirect access methods */
  -- note certain caseless compares, here
  select
    when methodname.left(3)=='get' then namerest=methodname.substr(4)
    when methodname.left(3)=='set' then namerest=methodname.substr(4)
    when methodname.left(2)=='is'  then namerest=methodname.substr(3)
    otherwise namerest=''
    end
  if namerest\=='' then do label checkpattern
    list=pooler.getindirects(pcursor)
    if list.length=0 then leave checkpattern      -- fast exit
    args=methodargvars.length
    verb=methodname.left(methodname.length().toint()-namerest.length().toint())
    loop i=0 to list.length-1
      item=list[i]                 -- we know it's an indirect property
      if item.varspell.upper(1,1)==namerest then if verb==verb.lower() then do
        -- It's an exact match for an indirect access method
        select
          when verb=='is' | verb=='get' then do
            /* Check getter patterns */
            select
              when args=0 then expecttype=item.vartype
              when args>1 then expecttype=null
              when item.vartype.dimension\=1 then expecttype=null
              when methodargvars[0].vartype\=RxType.INT_TYPE then expecttype=null
              otherwise expecttype=item.vartype.basetype()
              end
            if expecttype=null then do
              if item.isarray() then
                signal RxQuit(rxt, methodtoken, 'indirect.getter.bad.array', methodname, item.varspell)
               else
                signal RxQuit(rxt, methodtoken, 'indirect.getter.bad', methodname, item.varspell)
              end
            /* expecttype\=null */
            if verb=='is' & expecttype\=RxType.BOOL_TYPE then
              signal RxQuit(rxt, methodtoken, 'indirect.getter.not.boolean', methodname, item.varspell)
            if verb=='get' & expecttype=RxType.BOOL_TYPE then
              signal RxQuit(rxt, methodtoken, 'indirect.getter.is.boolean', methodname, item.varspell)
            if methodrettype=RxType.VOID_TYPE then rett=RxType.REXX_TYPE
                                          else rett=methodrettype
            if expecttype\=rett then
              signal RxQuit(rxt, methodtoken, 'indirect.getter.bad.result',-
                            methodname, item.varspell,-
                            rxt.program.babel.typeString(expecttype))
            end
          when verb=='set' then do
            /* Check setter patterns */
            if args=0 then
              signal RxQuit(rxt, methodtoken, 'indirect.setter.no.arguments', methodname, item.varspell)
            if args>item.vartype.dimension+1 then
              signal RxQuit(rxt, methodtoken, 'indirect.setter.too.many.arguments', methodname, item.varspell)
            if args=1 then
             if item.vartype\=methodargvars[0].vartype then
              signal RxQuit(rxt, methodtoken, 'indirect.setter.bad.value',-
                            methodname, item.varspell,-
                            rxt.program.babel.typeString(item.vartype))
            if args=2 then
             if methodargvars[0].vartype\=RxType.INT_TYPE then
              signal RxQuit(rxt, methodtoken, 'indirect.setter.bad.first',-
                            methodname, item.varspell)
            if args=2 then
             if item.vartype.classname\==methodargvars[1].vartype.toJava() then
              signal RxQuit(rxt, methodtoken, 'indirect.setter.bad.value',-
                            methodname, item.varspell, item.vartype.classname)
            -- OK so far
            if methodrettype\=RxType.VOID_TYPE then do
              -- if RETURNS was implied, then defer error until the RETURN
              if impliedreturns then
                signal RxQuit(rxt, impliedreturnstok, 'indirect.setter.cannot.return.value',-
                              methodname, item.varspell)
               else
                signal RxQuit(rxt, methodtoken, 'indirect.setter.bad.returns', methodname, item.varspell)
              end
            if item.isreadonly() then
              signal RxQuit(rxt, methodtoken, 'indirect.setter.constant', methodname, item.varspell)
            end
          end
        -- finally, mellower check(s)
        if methodvisib\=VIS_PUB then
          RxWarn(rxt, methodtoken, 'indirect.access.not.public', item.varspell)
        iterate i
        end
      -- Here if a case mismatch
      if item.varspell.OpEq(null, namerest) then
        RxWarn(rxt, methodtoken, 'indirect.access.misspelled',-
               item.varspell, verb.lower()||item.varspell.upper(1,1))
      end i
    end checkpattern

 /* Re-register the argument variables, saved from pass1, and re-parse
    any initialization expression for pass2-quality code [consider calls
    to AddConstant or other side-effects] */
 loop i=0 for methodargvars.length
   var=methodargvars[i]                      -- get the saved VAR
   initcode=methodargcode[i]
   init=initcode.group\=S_TYPE               -- 1 if has initialization
   pooler.repoolvar(pcursor, var, init)
   if init then do
     ends=RxToken.COMMA||RxToken.RPAR
     code=rxt.eparser.parseexpr(pcursor, 1, initcode.begoff, ends, null) -- NB, type allowed
     if code.group=S_LIT then                -- we choose type
       rxt.converter.litexpr(pcursor, code)
     methodargcode[i]=code                   -- replace the old one
     end
   end i

 /* Trace names list */
 method getAssigns returns String[]
  return null

 /* ----------------------------------------------------------------- */
 /* Pass2 code generation                                             */
 /* ----------------------------------------------------------------- */
 method generate

  /* Build the common Java keywords modifiers strings and the method
     prefix derived from it */
  javamods=RxField.visibilityToJava(methodvisib)-
           RxField.attributesToJava(methodatts)

  if methodconstructor then prefix=javamods methodname
                       else prefix=javamods methodrettype.toJava() methodname
  prefix=prefix.space()

  -- prefix all methods by a cosmetic blank line
  rxt.program.streamer.out(null)

  /* Now generate the method(s): optional first, then the full arguments
     version, which may be followed by the real body.
     (Overrides are checked in endmethod, when we have signals.) */
  args=methodargvars.length
  if optargfirst=0 then optarg=args+1        -- make truthful number
                   else optarg=optargfirst
  togen=args+2-optarg              -- number of methods to generate
  loop methnum=optarg for togen    -- for number of methods to generate
    methargs=methnum-1             -- arguments in this method

    -- build generated arguments list
    javaarglist=''
    loop i=0 for methargs
      if i>0 then javaarglist=javaarglist','
      var=methodargvars[i]
      type=var.vartype
      -- move any array part to name, for valid Java
      def='[]'.copies(type.dimension)
      javaarglist=javaarglist||type.classname var.varspell||def
      end i
    if \rxt.program.flag.comments then do
      rxt.program.streamer.out('')                -- blank line in output
      if methoddeprecated then rxt.program.streamer.out('/** @deprecated */')
      end
    rxt.program.streamer.outpart(prefix)
    rxt.program.streamer.outpart('('javaarglist')')
    -- record where signals will go for each generated method
    methodsignalschunks=methodsignalschunks rxt.program.streamer.chunks
    if methodempty then body=';'; else body='{'
    if methnum=args+1 then do
      -- if a constructor, create a point for possible 'super()' insertion
      if \methodconstructor
       then rxt.program.streamer.out(body)
       else do
        rxt.program.streamer.outpart(body)
        methodsuperchunk=rxt.program.streamer.chunks
        rxt.program.streamer.out('')              -- start will be after
        end
      -- save start point of method for local variable insertions
      methodstartchunk=rxt.program.streamer.chunks-- [no harm if no body]
      end
     else /* methnum<args+1 */ do
      rxt.program.streamer.out(body)
      -- it's a generated optional method, so complete it
      ret=''
      loop i=0 for args                           -- build arguments list
        if i>0 then ret=ret','
        if i<methargs
         then /* pass argument by name */
          ret=ret||methodargvars[i].varspell
         else /* initial value */                 -- always right type
          ret=ret||methodargcode[i].javacode
        end i
      /* is one of: constructor, returns void, or returns something */
      select
        when methodconstructor then rxt.program.streamer.out(' this('ret');return;')
        when methodrettype=RxType.VOID_TYPE then rxt.program.streamer.out(' 'methodname'('ret');return;')
        otherwise rxt.program.streamer.out(' return' methodname'('ret');')
        end
      parser.indention=2                          -- cosmetic
      rxt.program.streamer.out('}')
      parser.indention=1                          -- ..
      end
    end methnum

  /* Now special-case provisional setup for an 'arg' variable */
  if argvar\=null then do
    -- argvar remembers the 'arg' variable.  The name of the temporary
    -- String[] variable is in the arguments list.
    tvar=methodargvars[0]                         -- get the argument
    methodargpending=RxType.REXX_CLASS argvar.varspell'=new'-
                     RxType.REXX_CLASS'('tvar.varspell');'
    end

 /* ----------------------------------------------------------------- */
 /* Set up default 'main' method                                      */
 /* [DEFMETHODSTART in prototype]                                     */
 /* ----------------------------------------------------------------- */
 /* This method replaces the usual 'scan' method calls for a default  */
 /* method generation (where there is no clause to scan).  It sets    */
 /* up the properties as though a clause had been scanned.            */
 /* The 'generate' method is called, as usual, to generate code.      */
 /* ----------------------------------------------------------------- */
 method defaultscan(pass=int)
  if pass=0 then signal RxQuit(rxt, tokens[0], 'internal.error', 'RxMethod: D0')
  tokens=methodclause.tokens            -- local reference for scanning
  beginmethod()                         -- initialize
  if pass=1 then defaultscan1()
            else defaultscan2()
  beginmethod2()

 method defaultscan1
  methoddefault=1                       -- method is default method
  methodname='main'
  methodmaxtrace=pcursor.curclass.tracelevel -- may have been pre-class TRACE
  methodrettype=RxType.VOID_TYPE
  methodtoken=tokens[0]                 -- associated token is implied
  methodargtype=RxType.STRINGARRAY_TYPE     -- String[]
  methodvisib=VIS_PUB                   -- visibility
  methodatts=ATT_STATIC                 -- attributes
  methodstatic=1                        -- we are a static method

  field=classer.registerfield(null, classinfo, methodname,-
                              methodrettype, methodvisib, methodatts,-
                              [methodargtype], '', this)
  methodfields=RxField[1]               -- and save
  methodfields[0]=field                 -- ..
  methodrettypeknown=1                  -- returns is known to be void

  /* build a variable for the arguments list */
  vname='0s'                            -- temporary for String array
  tname='$'vname                        -- actual spelling
  -- Make an RxVariable object.  This is independent of any varpool, as
  -- it is only used for passing the information to the generator.
  var=RxVariable(vname, tname, methodtoken, RxVariable.VAR_ARG,-
                 methodargtype, 0)
  methodargvars=RxVariable[1]
  methodargvars[0]=var                  -- record it in the arguments list
  code=RxCode(S_TYPE, RxType.REXX_TYPE, null) -- empty code object [no initialization]
  methodargcode=RxCode[1]
  methodargcode[0]=code                 -- record initialization code to list
  /* [In theory we should build an overrides list, here, for later checking] */

 method defaultscan2
  /* Set up local 'ARG' variable, in case it's used */
  name='arg'                            -- name for the argument string
  argvar=pooler.checkvar(pcursor, RxVariable.VAR_ARG, name,-
                         null, methodtoken, RxType.REXX_TYPE, null, 0)
  argvar.varmain=1                      -- flag it as the special
  -- don't add a trace for this method start


 /* ----------------------------------------------------------------- */
 /* Set up a synthetic method                                         */
 /* ----------------------------------------------------------------- */
 /* This method replaces the usual 'scan' method calls for a          */
 /* synthetic method (where there is no clause to scan).              */
 /* It sets up the properties as though a clause had been scanned.    */
 /* At present, code is generated by the caller [it should probably   */
 /* be shared code in generate()].                                    */
 /* ----------------------------------------------------------------- */
 /* Arg1 is the pass (should always be 1 at present)
    Arg2 is the field describing the method
    Arg3 is the SYN_ type of the method
    Arg4 is associated property name, for SYN_INDIRECT
    */
 method synthetic(pass=int, field=RxField, syntype=int, synname=Rexx)
  if pass\=1 then signal RxQuit(rxt, tokens[0], 'internal.error', 'RxMethod: SYN02')
  methodsyntype=syntype                 -- copy
  methodpropname=synname                -- copy
  beginmethod()                         -- initialize
  dosynthetic(field)
  beginmethod2()

 method dosynthetic(field=RxField)
  methodfields=RxField[1]               -- save the field
  methodfields[0]=field                 -- ..
  methodrettypeknown=1                  -- returns is known to be void
  methodsynthetic=1                     -- method is synthetic
  methodconstructor=field.isConstructor()
  methodname=field.fieldname
  methodrettype=field.fieldtype
  methodtoken=null                      -- associated token
  methodvisib=VIS_PUB                   -- visibility
  methodatts=ATT_SYNTHETIC              -- attributes
  methodclauses=null                    -- no body
  -- Setup the argument variables needed, according to the field
  argcount=field.fieldargtypes.length
  methodargvars=RxVariable[argcount]    -- make an array of variables
  loop i=0 for argcount
    argname='$'||(i+1)                  -- temporary name
    -- it's safe to uses, as local pool is checked first
    /* Now register the variable, type known, in the local pool */
    var=pooler.checkvar(pcursor, RxVariable.VAR_ARG, argname, null,-
                        methodtoken, field.fieldargtypes[i], null, 1)
    methodargvars[i]=var
    end

 /* ----------------------------------------------------------------- */
 /* BEGINMETHOD -- initialize method state as seen by class           */
 /* ----------------------------------------------------------------- */
 method beginmethod
  pcursor.curclass.methods=pcursor.curclass.methods+1  -- bump count
  pcursor.curclass.classmethods.addElement(this)       -- add to list
  pcursor.curbinary=methodbinary   -- propagate binary setting
  pcursor.curstatic=0              -- assume non-static

  methodprotopool=Hashtable(10)    -- make the local variables prototype pool
  pcursor.curlpool=methodprotopool -- and make it current

  /*** [1998.05.26] not at all clear why this moved constants down --
       seems to be purely cosmetic, but can cause javac problems due to
       forward references from static property initializers.  Removed...
  -- next should be pass2 only
  if pcursor.curclass.methods=1 then /* first real method */ do
    -- record where remaining class constants will go
    pcursor.curclass.constantchunk=rxt.program.streamer.chunks
    end
  ***/

 /* ----------------------------------------------------------------- */
 /* BEGINMETHOD2 -- common method state                               */
 /* ----------------------------------------------------------------- */
 method beginmethod2
  if \methodsynthetic then parser.pushlevel('METHOD') -- new structural level now

  -- update Class status [later this should only need to be in pass1]
  if methodabstract then pcursor.curclass.abstracts=pcursor.curclass.abstracts+1
  if methodstatic then pcursor.curstatic=1
   else do label nonstatic
    pcursor.curclass.nonstatics=pcursor.curclass.nonstatics+1
    -- unless we are a constructor with a super, indicate we have an instance now
    pcursor.curthis=this
    /* If starting a constructor then require a super/this constructor call */
    if methodconstructor then do
      pcursor.curclass.constructors=pcursor.curclass.constructors+1
      -- this()/super() neither allowed nor needed if we have no superclass
      if classinfo.superinfo\=null then pcursor.curthis=null
      end
    end nonstatic

  /* Settings and trace stuff not needed on pass 1 */
  if rxt.pass1 then return

  if \methodhadnumeric                       -- [we assume it changes a setting]
   then methodset=pcursor.curclass.classset  -- use class setting directly
   else do                                   -- need a local settings object
    /* Create a settings object local variable, and initialize it */
    pcursor.curclass.uniques=pcursor.curclass.uniques+1
    sname='$'pcursor.curclass.uniques        -- the settings object
    if pcursor.curclass.classset=='null' then clone=''
     else clone=pcursor.curclass.classset
    /* Save the actual creation statement until the first NUMERIC, in
       case this is a constructor (with call to super()).  We must
       follow any such call. */
    methodsetpending=RxType.REXXSET_CLASS sname'=new'-
                     RxType.REXXSET_CLASS'('clone');'
    methodset=sname                          -- use this from now on
    end

  if \methodtracechange                      -- no TRACEs in method
   then do
    methodtrace=pcursor.curclass.classtrace  -- use class tracing directly
    end
   else do                                   -- need a local trace object
    /* Create a trace object local variable, and initialize or clone it */
    pcursor.curclass.uniques=pcursor.curclass.uniques+1
    sname='$'pcursor.curclass.uniques        -- the trace object
    if pcursor.curclass.classtrace=='null'
     then initial=Rexx rxt.program.source.getLineCount()','-
                  ||'System.'||'err out err'.word(rxt.program.flag.trace+1)','-
                  ||'"'rxt.program.source.getName()'"'
     else initial=pcursor.curclass.classtrace
    /* Save the actual creation statement until later, in case this is a
       constructor (with call to super()).  We must follow any such
       call. */
    methodtracepending=RxType.REXXTRACE_CLASS sname'=new'-
                       RxType.REXXTRACE_CLASS'('initial');'
    methodtrace=sname                        -- use this from now on
    end
  return

 /* ----------------------------------------------------------------- */
 /* ENDMETHOD -- clean up at end of method, and add deferred code.    */
 /* ----------------------------------------------------------------- */
 method endmethod
  if parser.level<2 then RxWarn(rxt, null, 'internal.error', 'RxMethod pl' parser.level)
  if rxt.pass2 then do
    endmethod2()
    pooler.checkmethodunused(pcursor)   -- warn of unused locals
    end
  parser.poplevel()                     -- back to Class level
  parser.cursor.curmethod=null          -- method no longer valid
  parser.cursor.curlpool=null           -- local variables longer valid

 /* Pass2 processing at end of method */
 -- [This must run to completion: do not signal RxQuit or RxError,
 -- unless caught in endmethod.]
 method endmethod2 private
  parser.checknest()                    -- ensure clean controls
  /* Here we:
     1. Add code to end method (checking for missing RETURN, too)
     2. Add default super() call if needed
     3. Check SIGNALS, and add signals phrase if required
     4. List and check overrides/implements
     5. Add any other pending code */

  /* --- Finish off the method, if needed --- */
  if \methodempty then do
    close='}'
    if \parser.thislevel.terminal then do    -- didn't end in return, etc.
      if methodconstructor then close='return;'close
       else do
        if methodrettype=RxType.VOID_TYPE
         then close='return;'close
         else RxError(rxt, methodtoken, 'return.with.value.expected.at.method.end',-
                      rxt.program.babel.typeString(methodrettype))
        end
      end
    parser.indention=2                       -- cosmetic
    rxt.program.streamer.out(close, 1)
    parser.indention=1                       -- ..
    end

  /* --- Add super() call, if needed --- */
  if methodconstructor then if \methodhadthissuper then
   if \methodempty then do label addsuper
    -- Adding a default constructor implies that the superclass had better
    -- have one, too.
    superinfo=classinfo.superinfo
    if superinfo=null then leave addsuper    -- Object class
    /* If the superclass is a dependent class then we cannot add super() */
    if superinfo.isdependent then
      RxError(rxt, methodtoken, 'dependent.subclass.needs.super')
     else do
      /* Look for the unqualified bit (method name), in superclass only */
      methname=superinfo.shortname
      field=rxt.classer.findfield(pcursor, 1, 1, 0, 0, superinfo, methname,-
                                  RxType[] null, null)
      if field=null then                     -- no matching constructor above
        RxError(rxt, methodtoken, 'default.constructor.call.fails', methname'()')
       else do
        /* OK, superclass constructor exists [doesn't matter if ambiguous] */
        parser.addexceptions(1, field.fieldexcep, methodtoken) -- it could signal exceptions
        -- this will go on method-open line, to show it's generated
        rxt.program.streamer.outinsertpart('super();', methodsuperchunk)
        getField().fieldspecial=field     -- save reference
        end
      end
    end addsuper

  /* --- Ensure fieldspecials are set ---
     If a constructor, set all fields with optional arguments to refer
     to the this() call (final field).
     */
  if methodconstructor then do
    finalfield=getField()
    loop i=0 to methodfields.length-2   -- very often none
      methodfields[i].fieldspecial=finalfield
      end i
    end

  /* --- Check SIGNALS, and add signals phrase if required ---
     Build the SIGNALS list.  This will be:
       1. All explicit items, except those not in pending list (which
          always raise a warning)
       2. All pending HARD exceptions (unless STRICTSIGNAL, in which
          case these raise error)
     */
  /* Make arrays of explicit and pending lists (expl/pend) */
  x=explicitsignals
  if x=null then do; nume=0; expl=RxException[0]; end
    else do; nume=x.size(); expl=RxException[nume]; x.copyInto(expl); end

  n=parser.thislevel.signals
  parser.thislevel.signals=null  -- they'll be handled, now
  if n=null then do; nump=0; pend=RxException[0]; end
    else do; nump=n.size(); pend=RxException[nump]; n.copyInto(pend); end
  /* [note: nume and nump are also used below] */

  exceplist=''           -- complete list of signals, fully qualified
  misslist=''            -- list of missing signals, concise
  loop i=0 for nume
    e=expl[i]
    if rxt.program.flag.diag then say '# explicit:' e.excephard e.excepinfo.type.toSig()
    -- If one of the pending list is us then we are useful.
    found=e.find(pend)   -- find e in Vector n's list
    -- if not found (and we're checked and not abstract/interface) then
    -- warn the user that method may be incomplete.  We do include it in
    -- the list, though, for callers.
    if found=null then if \methodabstract then if e.excephard then do
      concisename=rxt.program.babel.typeConcise(e.excepinfo.type)
      RxWarn(rxt, e.exceptok, 'exception.not.signalled', concisename)
      end
    if exceplist\=='' then exceplist=exceplist','
    exceplist=exceplist||e.excepinfo.type.classname
    end i
  loop i=0 for nump
    e=pend[i]
    -- if rxt.program.flag.diag then say '# pending:' e.excephard e.excepinfo.type.toSig()
    if \e.excephard then iterate i      -- ignore softies
    -- OK if one of the explicits is us or a superclass of us
    found=e.find(expl)                  -- find e in Vector x's list
    if found=null then do
      concisename=rxt.program.babel.typeConcise(e.excepinfo.type)
      if rxt.program.flag.strictsignal then
        RxError(rxt, e.exceptok, 'exception.not.in.signals.list', concisename)
      if misslist=='' then misslist=concisename
                      else misslist=misslist','concisename
      if exceplist\=='' then exceplist=exceplist','
      exceplist=exceplist||e.excepinfo.type.classname
      end
    end i

  if misslist\=='' then                                -- some missing
   if \methoddefault then do                           -- not implied
    -- If a forward reference to any of us, we're in trouble
    accum=boolean 0
    loop i=0 for methodfields.length until accum
      if methodfields[i].fieldref2 then accum=1
      end i
    if accum & \rxt.program.flag.strictsignal then     -- [unless already error]
      RxError(rxt, methodtoken, 'exceptions.not.explicit', misslist)
     else if rxt.program.flag.verbose>2 then
      rxt.say('      signals' misslist)
    end

  /* Now add the 'throws' phrase for all the generated methods, as
     needed, and update the field definition for each.
     [This can over-specify, if some were raised in optional
     arguments, but javac allows this] */
  if exceplist\=='' then do
    loop fnum=0 for methodfields.length
      methodfields[fnum].fieldexcep=exceplist
      end fnum
    clist=methodsignalschunks
    piece=' throws' exceplist
    loop while clist\==''
      parse clist chunk clist
      rxt.program.streamer.outinsertpart(piece, chunk)
      end
    end /* have signals */

  /* --- Check overrides, for all flavours of method --- */
  num=overrides.size(); olist=RxField[num]; overrides.copyInto(olist)
  loop o=0 for num
    f=olist[o]                                    -- get a field

    /* Check visibility .. we cannot be more private than the method
       we are overriding */
    fromtype=f.fieldinfo.type
    ok=boolean 1
    select
      when methodconstructor       then nop  -- not actually overriding
      when methodvisib ==VIS_PUB   then nop  -- always OK
      when f.fieldvisib==VIS_PUB   then ok=0 -- downgrading
      when methodvisib ==VIS_INHER then nop  -- now always OK
      when f.fieldvisib==VIS_INHER then ok=0 -- downgrading
      when methodvisib ==VIS_SHAR  then nop  -- now always OK
      when f.fieldvisib==VIS_SHAR  then ok=0 -- downgrading
      otherwise nop                          -- [both private (impossible!)]
      end

    /* Now display progress and/or error message, if required */
    if rxt.program.flag.verbose>2 | \ok then do label message
      /* Get the descriptor, using concise names where possible */
      describe=f.toConciseString(methodprogram, 0)
      if rxt.program.flag.verbose>2 then do
        if f.isAbstract() then rxt.say('      implements' describe)
                        else rxt.say('      overrides'  describe)
        end
      if \ok then RxError(rxt, methodtoken, 'cannot.override',-
                          rxt.program.babel.fieldVisibility(methodvisib),-
                          rxt.program.babel.fieldVisibility(f.fieldvisib),-
                          describe,-
                          rxt.program.babel.typeString(fromtype))
      end message

    /* Check deprecation */
    if f.isDeprecated() then do label depwarn
      -- we assume a method in an interface class won't be deprecated
      -- (NetRexx enforces, Java may not)
      if rxt.deprecateds.containsKey(f) then leave depwarn -- already warned
      RxWarn(rxt, methodtoken, 'deprecated.method.override',-
             f.toConciseString(methodprogram))
      rxt.deprecateds.put(f,f) -- just the once, please
      end depwarn

    /* Check finality */
    if f.isFinal() then RxError(rxt, methodtoken, 'cannot.override.final',-
                              rxt.program.babel.typeString(fromtype))

    /* Check static/non-static agree */
    select
      when methodstatic=f.isStatic() then nop  -- good match
      when methodstatic then
        RxError(rxt, methodtoken, 'cannot.override', 'static', 'non-static',-
                rxt.program.babel.typeString(fromtype))
      otherwise
        RxError(rxt, methodtoken, 'cannot.override', 'non-static', 'static',-
                rxt.program.babel.typeString(fromtype))
      end

    /* Check return signatures match */
    if methodrettype\=f.fieldtype then do label retcheck
      /* if a constructor, it's OK so long as it matches the
         constructor type */
      if methodconstructor then
       if f.fieldtype=fromtype then leave retcheck
      select
        when methodrettype=RxType.VOID_TYPE
          then RxError(rxt, methodtoken, 'return.override.void',-
                       rxt.program.babel.typeString(f.fieldtype),-
                       rxt.program.babel.typeString(fromtype))
        when f.fieldtype=RxType.VOID_TYPE
          then RxError(rxt, methodtoken, 'return.override.notvoid',-
                       rxt.program.babel.typeString(methodrettype),-
                       rxt.program.babel.typeString(fromtype))
        otherwise
          RxError(rxt, methodtoken, 'return.override.mismatch',-
                  rxt.program.babel.typeString(methodrettype),-
                  rxt.program.babel.typeString(f.fieldtype),-
                  rxt.program.babel.typeString(fromtype))
        end
      end retcheck

    /* Check SIGNALS list is a proper subset of the overridden list */
    supotypes=f.excepTypes()
    loop i=0 for nump
      e=pend[i]
      if \e.excephard then iterate i  -- ignore softies
      -- javac doesn't do this check for constructors (because
      -- strictly constructors do not override.
      -- This must be so, as Object.Object() has no signals list.
      if methodconstructor then iterate i
      -- must be a subclass of one of the exceptions thrown by superior
      foundup=boolean 0
      loop j=0 for supotypes.length
        if classer.issubclass(pcursor, e.excepinfo, supotypes[j],-
                              methodtoken) then do
          foundup=1
          leave
          end
        end
      if \foundup then RxError(rxt, methodtoken,-
                              'exception.not.signalled.by.overridden',-
                              e.excepinfo.type.classname)
      end i
    end o

  /* --- Add remaining inserts --- */
  /* If we have a potential ARG variable we had a default main method
     and we need some special actions.

     o If it's referenced, then add the initializer for it, and update
       the arguments list

     o If it's not referenced, then we don't need the initialization,
       but we still need to update the name in the arguments list
     */
  -- if rxt.program.flag.diag then
  --   say '# argvar:' (argvar=null) ''''methodargpending'''' methodstartchunk
  if argvar\=null then do
    if argvar.varseen then
      rxt.program.streamer.outinsert(methodargpending, methodstartchunk, 2)
    methodargvars[0]=argvar             -- record it in the arguments list
    end

  /* If any tracing, create the clone trace object now, at the start
     of the method (after any constructor call). */
  if pcursor.curmethod.methodtracepending\=='' then
    rxt.program.streamer.outinsert(methodtracepending, methodstartchunk, 2)

  /* Similarly for the Settings object, if needed */
  if pcursor.curmethod.methodsetpending\=='' then
    rxt.program.streamer.outinsert(methodsetpending, methodstartchunk, 2)

  /* Finally, add any 'deferred' lines... */
  loop i=1 to defers
    rxt.program.streamer.outinsert(deferred[i], methodstartchunk, 2)
    end i

 /* TRACEARGS -- trace any arguments */
 /* These will be deferred, for a constructor */
 method traceargs
  if methodabstract then return              -- no execution/trace possible
  if methodnative   then return              -- ..
  loop i=0 for methodargvars.length
    rxt.program.tracer.tracearg(methodargvars[i])
    end i

 /* CHECKPRIVATEREFS -- warn if private method and not referenced
    -- should be called at class end
    -- currently if any sub-method is referenced, we don't warn
    -- could be stricter is strictargs in effect.
    */
 method checkprivaterefs
  if methodvisib\=VIS_PRIV then return       -- not private
  -- it's private; check for a reference
  loop i=0 for methodfields.length
    if methodfields[i].fieldref2 then return
    end i
  -- drop through if no flavour of the method had a reference
  RxWarn(rxt, methodtoken, 'method.not.used')

 /* SETRETTYPE -- set the method return signature (and fields)
    Arg1 is the type to be set
    Arg2 is whereabouts of the token that changes the signature
            [e.g., the start of the expression on a RETURN]
    This is used when signature is changed from void to Rexx when a
      RETURN with expression is found in pass1. */
 method setrettype(type=RxType, where=RxToken)
  methodrettype=type
  loop fnum=0 for methodfields.length
    methodfields[fnum].fieldtype=methodrettype
    end fnum
  methodrettypeknown=1                       -- we can't change it again
  impliedreturns=1                           -- remember the force
  impliedreturnstok=where                    -- ..
  return

 /* DEFER -- add a piece of code to deferred tracing queue */
 method defer(string=Rexx)
  defers=defers+1
  deferred[defers]=string

 /* isXXX -- methods for testing attributes easily */
 method isAbstract returns boolean; return methodabstract
 method isNative   returns boolean; return methodnative

 /* GETFIELD -- return primary (final) field for this method */
 method getField returns RxField
  return methodfields[methodfields.length-1]

 /* TOCONCISESTRING -- return concise description of method */
 method toConciseString returns String
  return getField().toConciseString(methodprogram, 1)

 /* Interpretation */
 method interpret(cursor=RxCursor null)
  -- The only methods that are interpreted here are synthetic ones;
  -- others have their body clauses interpreted by RxInterpreter
  if \methodsynthetic then
    signal RxQuit(rxt, null, 'internal.error', 'RxMethod: interpret')

  cursor.curreturn=null            -- no explicit return object
  select case methodsyntype
    when SYN_DEFCON then return    -- (return should be null)
    when SYN_EMPTY then do
      -- just return default value for the type
      cursor.curreturn=rxt.interpreter.initvalue(methodrettype)
      return
      end
    when SYN_INDIRECT then do
      -- find the property to get or set
      prop=pooler.refindvar(cursor, methodpropname)
      propvalue=rxt.interpreter.getVar(cursor, prop, null) -- used 3/4 paths
      if methodrettype=RxType.VOID_TYPE then do label setprop
        arg1=pooler.refindvar(cursor, '$1')       -- get index or value
        arg1value=rxt.interpreter.getVar(cursor, arg1, null)
        if methodargvars.length=2 then do label setarray
          arg2=pooler.refindvar(cursor, '$2')     -- get set value
          arg2value=rxt.interpreter.getVar(cursor, arg2, null)
          -- the following fixed-sized objects could be cached
          code1=RxCode(S_VAR, arg1.vartype, null)
          code1.value=arg1value
          array=RxArray(null, 0, 1, 0)
          array.arraycode=[code1]
          rxt.interpreter.setArrayElementValue(cursor, propvalue,-
                                               arg2.vartype,-
                                               array, null, arg2value)
          end
         else do
          rxt.interpreter.setVar(cursor, prop, null, arg1value) -- set it
          end
        end
       else do label getprop

        if methodargvars.length=1 then do label getarray
          arg1=pooler.refindvar(cursor, '$1')   -- get index
          arg1value=rxt.interpreter.getVar(cursor, arg1, null)
          -- the following fixed-sized objects could be cached
          code1=RxCode(S_VAR, arg1.vartype, null)
          code1.value=arg1value
          array=RxArray(null, 0, 1, 0)
          array.arraycode=[code1]
          cursor.curreturn=rxt.interpreter.getArrayElementValue(cursor,-
            propvalue, prop.vartype, array, null)
          end
         else cursor.curreturn=propvalue

        end
      end
    end

