/* IBM Materials Licensed under International Components for Unicode  */
/* Licence version 1.8.1 (ICU Licence) - Property of IBM              */
/* IBM NetRexx                                                        */
/* Copyright (c) 1995-2009 IBM Corp.                                  */
/* Copyright (c) 2011- RexxLA                                         */
/* ------------------------------------------------------------------ */
/* NetRexx language processor                                     mfc */
/* Copyright (c) IBM Corporation 1996, 2001.  All Rights Reserved.    */
/* ------------------------------------------------------------------ */
/* NrLoop                                                             */
/*                                                                    */
/*   An object that represents a parsed Loop instruction.             */
/*                                                                    */
/* ------------------------------------------------------------------ */
/* 1996.06.10 Initial                                                 */
/* 1996.06.23 Rework; FOR added                                       */
/* 1996.08.31 Record if loop has terminating condition (dropout)      */
/* 1996.12.15 Order TO, BY, FOR parts as specified, and improve trace */
/* 1997.01.11 Rework OVER for proper snapshot and filter [testnode]   */
/* 1998.06.05 Allow label to be requested by LEAVE/ITERATE            */
/* 2000.03.06 Rework for interpretation; add LoopExpr class           */
/* 2000.03.07 Make LoopExpr the generalized RxExpr class              */
/* 2000.03.10 Move much code down to generate, and use .constant      */
/* 2000.03.11 Implement OVER for interpretation                       */
/* 2001.05.22 Until code stepped control variable in wrong place      */
/* ------------------------------------------------------------------ */
package COM.ibm.netrexx.process
options binary nodecimal

/**   An object that represents a parsed Loop instruction.             */
class NrLoop extends NrBlock implements RxClauseParser-
             uses RxCode, RxExpr, RxCursor
 properties private
  rxt       =RxTranslator          -- root
  parser    =RxParser              -- local reference
  pooler    =RxVarPool             -- variables manager
  pcursor   =RxCursor              -- local reference
  converter =RxConverter           -- local reference
  tokens    =RxToken[]             -- local reference
  labelchunk=int                   -- insert point for label code

  -- scan results follow
  tracelevel=int                   -- tracing level
  tracetag  =char '\0'             -- assigned variable tag
  tracename =Rexx ''               -- assigned name as spelled
  tracenames=String[]              -- lowercase assigned names
  var       =RxVariable            -- control variable (during parsing)
  varname   =Rexx ''               -- variable spell name [= or OVER found]
  varcode   =RxCode                -- code object for variable math
  varlook   =Rexx null             -- variable original name [= or OVER found]
  initexpr  =RxExpr                -- initial-value expression
  toexpr    =RxExpr                -- TO expression
  byexpr    =RxExpr                -- BY expression
  forexpr   =RxExpr                -- FOR expression
  exprs     =Vector(3)             -- TO, BY, and FOR expressions, in order
  whileexpr =RxExpr                -- WHILE expression
  untilexpr =RxExpr                -- UNTIL expression
  byonecode =RxCode                -- code for '1' if BY is defaulted
  overterm  =RxCode                -- code OVER term [null if none]
  overtype  =RxType                -- OVER collection type
  overrexx  =boolean 0             -- stepping over a Rexx indexed string

  looplabel =''                    -- explicit label
  firsttriv =boolean 1             -- firstpart is trivial assignment
  needfirst =boolean 0             -- need a 'first' test
  maytrace  =boolean 0             -- may need tracing wrappers
  assign    =boolean 0             -- loop has VAR=

  tokby     =RxToken null          -- token for BY
  tokto     =RxToken null          -- token for TO
  tokfor    =RxToken null          -- token for FOR
  tokvar    =RxToken null          -- token for control variable

 properties private constant
  dicttype  =RxType('java.util.Dictionary', 0)

 /** Construct an object from the current clause */
 method NrLoop(newrxt=RxTranslator)
  super(newrxt)
  rxt      =newrxt                      -- the boss
  parser   =rxt.program.parser          -- our parser
  pooler   =rxt.program.pooler          -- our variables manager
  pcursor  =parser.cursor               -- our parsing cursor
  tokens   =pcursor.curclause.tokens    -- local reference

 /** Pass processing */
 method scan(pass=int)
  if pass<2 then signal RxQuit(rxt, tokens[0], 'internal.error', 'NrLoop', pass)

  -- If add code here then NrDo retry may need update
  converter=rxt.converter               -- spin doctor

  parser.pushlevel('LOOP')              -- new level
  maytrace=(pcursor.curmethod.methodmaxtrace\=RexxTrace.OFF) -- could be VAR
  if maytrace then do
    needfirst=1                         -- need a first part
    firsttriv=0                         -- it could be non-trivial
    end

  /* Syntax:                      [i=1 to x by y for n]                */
  /*   loop [label l] [protect x] [forever            ]  [while exprw] */
  /*                              [for count          ]  [until expru] */
  /*                              [i over x           ]                */
  /* 'forever' is default if no repetitor part                         */
  /* I= form must have a simple name (no []).                          */

  if tokens[1].type=RxToken.END then n=1
   else do /* non-empty */
    if tokens[1].type<>RxToken.SP then signal RxError(rxt, tokens[1], 'blank.expected')
    /* first collect the front stuff and repetitor */
    n=1                                 -- start of content, -1
    loop label named forever
      n=n+1; tok=tokens[n]; tn=tok.type
      if tn<>RxToken.SYM then signal RxError(rxt, tok, 'name.or.keyword.expected')
      assign=boolean 0
      if tokens[n+1].type=RxToken.OP then
       if tokens[n+1].value[0]='=' then assign=1

      if \assign then /* not an X=... form */ do label nonassign
        if parser.iskey(tok.value, 'WHILE')   then do;        leave named; end
        if parser.iskey(tok.value, 'UNTIL')   then do;        leave named; end
        if parser.iskey(tok.value, 'FOREVER') then do; n=n+1; leave named; end
        if parser.iskey(tok.value, 'LABEL')   then do
          if looplabel\=='' then signal RxError(rxt, tok, 'duplicate.keyword')
          n=n+1; tok=tokens[n]; tn=tok.type
          if tn<>RxToken.SP then signal RxError(rxt, tok, 'blank.expected')
          n=n+1; tok=tokens[n]; tn=tok.type
          if tn<>RxToken.SYM then signal RxError(rxt, tok, 'label.expected')
          looplabel=tok.value
          parser.checkduplabel(looplabel, tok)
          parser.thislevel.blocklabel=looplabel
          parser.thislevel.javalabel=safelabel(looplabel)
          n=n+1; tok=tokens[n]; tn=tok.type
          if tn=RxToken.END then leave named
          if tn<>RxToken.SP then signal RxError(rxt, tok, 'blank.expected')
          iterate named
          end
        if parser.iskey(tok.value, 'PROTECT') then do
          if super.protcode\=null then signal RxError(rxt, tok, 'duplicate.keyword')
          n=n+1; tok=tokens[n]; tn=tok.type
          if tn=RxToken.SP then do; n=n+1; tok=tokens[n]; tn=tok.type; end
          term=rxt.tparser.parseterm(pcursor, n, 1) -- is an RHS reference
          next=term.endoff+1
          if term.group=T_UNKNOWN then
            signal RxError(rxt, tokens[n], 'unknown.variable')
          if term.type.isprimitive then
            signal RxError(rxt, tok, 'cannot.protect.primitive',-
                           rxt.program.babel.typeString(term.type))
          if term.type.isnull then
            signal RxError(rxt, tok, 'cannot.protect.null')
          /* If a type then we have to handle it indirectly */
          /* [don't do this for now, as would need to catch ClassNotFoundException] */
          /* if term.group=S_TYPE then term.javacode='Class.forName("'term.termsig'")' */
          if term.group=S_TYPE then
            signal RxError(rxt, tok, 'cannot.protect.type')
          parser.addexceptions(1, term.exceptions, tok, 1) -- to level above
          super.protcode=term                -- save in block
          pcursor.curclause.startprot=1      -- and add alert
          n=next; tok=tokens[n]; tn=tok.type
          if tn=RxToken.END then leave named
          if tn<>RxToken.SP then signal RxError(rxt, tok, 'blank.expected')
          iterate named
          end
        if parser.iskey(tok.value, 'FOR') then do
          parser.thislevel.dropout=1              -- is leavable loop
          n=n+1; if tokens[n].type=RxToken.SP then n=n+1
          tokfor=tokens[n]
          code=rxt.eparser.parseexpr(pcursor, 0, n, null, 'WHILE UNTIL')
          forexpr=RxExpr(rxt, pcursor, LOOP_EXPRF, code)
          n=code.endoff+1
          /* Add 0 (OpPlus) unless BINARY and working on a primitive type */
          if \code.type.isprimitive | \pcursor.curbinary then do
            ocode=rxt.eparser.oneopdo(pcursor, '+', tokfor, code)
            -- may be new code object
            code.type=ocode.type
            code.value=ocode.value
            code.constant=ocode.constant
            code.javacode=ocode.javacode
            forexpr.addzero=1
            end
          conv=converter.assigncost(pcursor, rxt.inttype, code.type)
          if conv.cost>rxt.program.flag.maxassign then
            signal RxError(rxt, tokfor, 'for.needs.int.type',-
                           rxt.program.babel.typeString(code.type))
          converter.convertcode(pcursor, rxt.inttype, conv.proc, code)
          if code.constant then do
            forcount=(Integer code.value).intValue
            if forcount<0 then
              signal RxError(rxt, tokfor, 'for.count.negative', forcount)
            end
          forexpr.type=rxt.inttype
          forexpr.conv=conv
          exprs.addElement(forexpr)
          leave named              -- we have all the repetitor
          end

        /* Only keyword possibility now is OVER form; we are at the name */
        parser.thislevel.dropout=1 -- is leavable loop
        tokvar=tok                 -- save the name coordinates
        varname=tok.value          -- and the name
        varlook=varname            -- save original spelling
        n=n+1; tok=tokens[n]; tn=tok.type
        -- 2000.06.28: this next message more helpful than blank.expected
        if tn<>RxToken.SP then signal RxError(rxt, tok, 'over.keyword.expected')
        n=n+1; tok=tokens[n]; tn=tok.type
        if \parser.iskey(tok.value, 'OVER') then
          signal RxError(rxt, tok, 'over.keyword.expected')
        n=n+1; tok=tokens[n]; tn=tok.type
        if tn=RxToken.SP then do; n=n+1; tok=tokens[n]; tn=tok.type; end
        /* Now at the term to iterate over */
        overterm=rxt.tparser.parseterm(pcursor, n, 1) -- is an RHS reference
        next=overterm.endoff+1
        if overterm.group=T_UNKNOWN then
          signal RxError(rxt, tokens[n], 'unknown.variable')
        if overterm.type.isprimitive then
          signal RxError(rxt, tok, 'cannot.loop.over.primitive',-
                         rxt.program.babel.typeString(overterm.type))
        if overterm.group=S_TYPE then
          signal RxError(rxt, tok, 'cannot.loop.over.type')
        /* syntax is OK */
        /* It must either extend Rexx or Dictionary */
        select
          when rxt.classer.issubclass(pcursor, overterm.type, NrBabel.rexxtype,-
                                      tokens[n]) then do
            overtype=NrBabel.rexxtype
            overrexx=1                            -- for faster tests
            end
          when rxt.classer.issubclass(pcursor, overterm.type,-
                                      dicttype, tokens[n]) then do
            overtype=rxt.objecttype
            overrexx=0
            end
          otherwise
            signal RxError(rxt, tokens[n], 'cannot.loop.over',-
                           rxt.program.babel.typeString(overterm.type))
          end
        /* Check we are allowed this control variable */
        parser.checkdupconvar(varname, tokvar)
        parser.thislevel.loopvarname=varname -- save for check
        if looplabel=='' then do
          looplabel=varname                  -- Classic Rexx naming
          parser.checkduplabel(looplabel, tokvar)
          parser.thislevel.blocklabel=looplabel
          parser.thislevel.javalabel=safelabel(looplabel)
          end
        /* Check we can assign to the tail variable, and find its real name */
        var=pooler.findvar(pcursor, varname, tokvar, 0, 0, 2)
        if var<>null then lhtype=var.vartype      -- we know it
                     else lhtype=null
        var=pooler.checkvar(pcursor, RxVariable.VAR_LOCAL, varname,-
                            lhtype, tokvar, overtype, tokens[n], 0)
        varname=var.varspell                      -- get real spelling
        tracename=varname                         -- request tracing
        varcode=RxCode(S_VAR, var.vartype, null)  -- in case trace during
        varcode.javacode=varname                  -- .. interpretation

        parser.addexceptions(1, overterm.exceptions, tok)  -- record exceptions

        n=next
        leave named                     -- we have all the repetitor
        end nonassign /* up-front bits, \assign */

      /* --- Here for X=... form --- */
      needfirst=1
      endwords='TO BY FOR WHILE UNTIL'
      tokvar=tok                        -- used below
      varname=tok.value                 -- checked and used below
      varlook=varname                   -- save original spelling
      parser.checkdupconvar(varname, tokvar)
      parser.thislevel.loopvarname=varname   -- save for check
      if looplabel=='' then do
        looplabel=varname                    -- Classic Rexx naming
        parser.checkduplabel(looplabel, tokvar)
        parser.thislevel.blocklabel=looplabel
        parser.thislevel.javalabel=safelabel(looplabel)
        end
      n=n+2; tok=tokens[n]

      /* lookup the variable name [now, so we can determine trace tag] */
      var=pooler.findvar(pcursor, varname, tokvar, 0, 0, 2)
      if var\=null then do; tracetag=var.tracetag; tracename=var.varname; end
                   else do; tracetag='v';          tracename=varname; end
      /* get and handle initial expression */
      initstart=n                       -- used below
      initcode=rxt.eparser.parseexpr(pcursor, 0, initstart,-
                                     null, endwords, tracetag, tracename)
      initexpr=RxExpr(rxt, pcursor, LOOP_EXPRI, initcode)
      n=initcode.endoff+1
      /* Add 0 unless BINARY and working on a primitive type.   Note
         that we cannot easily test if the expression is already a
         constant that's canonical, due to NUMERIC DIGITS.  We do
         special-case the very common single-digit cases, though.
         [since we generate +xxx, cost is low anyway]
         The adding zero also checks for valid arithmetical type (that
           is, primitive or Rexx/String/char[]).
         */
      canon=boolean 0
      if tok.type=RxToken.NUM
        then if tok.len=1
        then if n=initstart+1,-
               (n=initstart+2 & tokens[initstart+1].type=RxToken.SP)
        then canon=1
      select
        when canon then nop                                 -- trivial case
        when initcode.type.isprimitive & pcursor.curbinary then nop -- leave asis
        otherwise
          ocode=rxt.eparser.oneopdo(pcursor, '+', tokens[initstart], initcode)
          -- may be new code object
          initcode.type=ocode.type
          initcode.value=ocode.value
          initcode.constant=ocode.constant
          initcode.javacode=ocode.javacode
          initexpr.addzero=1
        end

      /* check and handle the variable name [we already looked it up] */
      if var<>null then /* known variable */ do
        conv=converter.assigncost(pcursor, var.vartype, initcode.type)
        if conv.cost>rxt.program.flag.maxassign then
          signal RxError(rxt, tokens[initstart], 'cannot.assign',-
                         rxt.program.babel.typeString(initcode.type),-
                         rxt.program.babel.typeString(var.vartype))
        converter.convertcode(pcursor, var.vartype, conv.proc, initcode)
        initexpr.type=initcode.type
        initexpr.conv=conv
        lhtype=var.vartype
        end
       else do
        if initcode.group=S_LIT then do
          converter.litexpr(pcursor, initcode)    -- we choose type
          initexpr.litexpr=1                      -- remember we did that
          end
        initexpr.type=initcode.type
        initexpr.conv=null
        lhtype=null                          -- new variable
        end

      initexpr.type=initcode.type
      initexpr.conv=conv

      var=pooler.checkvar(pcursor, RxVariable.VAR_LOCAL, varname,-
                          lhtype, tokvar, initcode.type, tokens[initstart], 0)
      varname=var.varspell                   -- get real spelling
      -- we'll need an RxCode object for it below
      varcode=RxCode(S_VAR, initcode.type, null)
      varcode.javacode=varname

      /* Here either at ';' or known keyword from endwords list
         (with possible preceding blank).  Process following parts,
         recording the expressions in exprs. */
      loop label oparts forever
        tok=tokens[n]; t=tok.type
        if t=RxToken.END then leave oparts
        if t=RxToken.SP then do; n=n+1; tok=tokens[n]; t=tok.type; end
        /* at keyword */
        key=Rexx(tok.value).upper
        select
          when key=='WHILE' then leave oparts
          when key=='UNTIL' then leave oparts
          when key=='TO' then do
            parser.thislevel.dropout=1            -- is leavable loop
            if toexpr\=null then signal RxError(rxt, tok, 'duplicate.to')
            n=n+1; if tokens[n].type=RxToken.SP then n=n+1
            tokto=tokens[n]
            code=rxt.eparser.parseexpr(pcursor, 0, n, null, endwords)
            toexpr=RxExpr(rxt, pcursor, LOOP_EXPRT, code)
            next=code.endoff+1
            -- No need to add zero for TO as effectively happens
            -- during comparison
            conv=converter.assigncost(pcursor, initcode.type, code.type)
            if conv.cost>rxt.program.flag.maxassign then
              signal RxError(rxt, tokto, 'to.bad.expression.type',-
                             rxt.program.babel.typeString(initcode.type),-
                             rxt.program.babel.typeString(code.type))
            if initcode.type=NrBabel.rexxtype then /* OK to use constant */
              converter.torexx(pcursor, code, 1)
             else
              converter.convertcode(pcursor, initcode.type, conv.proc, code)
            toexpr.type=initcode.type
            toexpr.conv=conv
            exprs.addElement(toexpr)
            end
          when key=='BY' then do
            if byexpr\=null then signal RxError(rxt, tok, 'duplicate.by')
            n=n+1; if tokens[n].type=RxToken.SP then n=n+1
            tokby=tokens[n]
            code=rxt.eparser.parseexpr(pcursor, 0, n, null, endwords)
            byexpr=RxExpr(rxt, pcursor, LOOP_EXPRB, code)
            next=code.endoff+1
            -- No need to add zero for BY as effectively happens
            -- during addition to the variable's value

            conv=converter.assigncost(pcursor, initcode.type, code.type)
            if conv.cost>rxt.program.flag.maxassign then
              signal RxError(rxt, tokby, 'by.bad.expression.type',-
                             rxt.program.babel.typeString(initcode.type),-
                             rxt.program.babel.typeString(code.type))
            if initcode.type=NrBabel.rexxtype then /* OK to use constant */
              converter.torexx(pcursor, code, 1)
             else
              converter.convertcode(pcursor, initcode.type, conv.proc, code)
            byexpr.type=initcode.type
            byexpr.conv=conv
            exprs.addElement(byexpr)
            end
          when key=='FOR' then do
            if forexpr\=null then signal RxError(rxt, tok, 'duplicate.for')
            /* now essentially the same code as before */
            parser.thislevel.dropout=1            -- is leavable loop
            n=n+1; if tokens[n].type=RxToken.SP then n=n+1
            tokfor=tokens[n]
            code=rxt.eparser.parseexpr(pcursor, 0, n, null, endwords)
            forexpr=RxExpr(rxt, pcursor, LOOP_EXPRF, code)
            next=code.endoff+1
            /* Add 0 unless BINARY and working on a primitive type */
            /* [This makes a difference if rounds to an int] */
            if \code.type.isprimitive | \pcursor.curbinary then do
              ocode=rxt.eparser.oneopdo(pcursor, '+', tokfor, code)
              -- may be new code object
              code.type=ocode.type
              code.value=ocode.value
              code.constant=ocode.constant
              code.javacode=ocode.javacode
              forexpr.addzero=1
              end
            conv=converter.assigncost(pcursor, rxt.inttype, code.type)
            if conv.cost>rxt.program.flag.maxassign then
              signal RxError(rxt, tokfor, 'for.needs.int.type',-
                             rxt.program.babel.typeString(code.type))
            converter.convertcode(pcursor, rxt.inttype, conv.proc, code)
            if code.constant then do
              forcount=(Integer code.value).intValue
              if forcount<0 then
                signal RxError(rxt, tokfor, 'for.count.negative', forcount)
              end
            forexpr.type=rxt.inttype
            forexpr.conv=conv
            exprs.addElement(forexpr)
            end
          end /* select */
        n=next
        end oparts
      if byexpr=null then makebyone     -- make constant 1 for BY 1
      leave named /* done */
      end named
    end /* not LOOP; */

  /* Reach here when the repetitor has been processed successfully   */
  /* 'n' is token number of next part start (may have leading blank) */
  tok=tokens[n]; t=tok.type
  if t=RxToken.END then nop /* done now */
   else /* 'while' or 'until' expected */ do
    if t=RxToken.SP then do; n=n+1; tok=tokens[n]; t=tok.type; end
    if t<>RxToken.SYM then signal RxError(rxt, tok, 'while.or.until.expected')
    iswhile=boolean 0    -- else appears uninitialized
    select
      when parser.iskey(tok.value, 'WHILE') then iswhile=1
      when parser.iskey(tok.value, 'UNTIL') then iswhile=0
      otherwise signal RxError(rxt, tok, 'while.or.until.expected')
      end
    parser.thislevel.dropout=1          -- is leavable loop
    n=n+1
    /* Evaluate the conditional expression */
    if tokens[n].type=RxToken.SP then n=n+1
    code=rxt.eparser.parseexpr(pcursor, 0, n, null, 'WHILE UNTIL')
    condexpr=RxExpr(rxt, pcursor, LOOP_EXPRW, code)    -- assume While
    next=code.endoff+1
    /* conditional now exists */
    if tokens[next].type<>RxToken.END then
      signal RxError(rxt, tokens[next], 'junk.on.end') -- both/repeat specified
    conv=converter.assigncost(pcursor, rxt.booltype, code.type)
    if conv.cost>rxt.program.flag.maxassign then do
      if iswhile then verb='while'; else verb='until'
      signal RxError(rxt, tokens[n], verb'.needs.boolean.type',-
                     rxt.program.babel.typeString(code.type))
      end
    converter.convertcode(pcursor, rxt.booltype, conv.proc, code)
    condexpr.type=rxt.booltype
    condexpr.conv=conv
    if iswhile then whileexpr=condexpr
     else /* isuntil */ do
      condexpr.exprtype=LOOP_EXPRU
      untilexpr=condexpr
      end
    end /* while or until */

  -- finally set up the trace names list
  if tracename=='' then do
    tracenames=null
    tracelevel=RexxTrace.ALL
    end
   else do
    tracenames=String[1]
    tracenames[0]=tracename.lower.toString
    tracelevel=RexxTrace.VAR
    end

 /** Trace names list */
 method getAssigns returns String[]
  return tracenames

 /** Code generation [only] */
 method generate
  begpart  =Rexx ''                     -- stuff before the for(;;)
  allpart  =Rexx ''                     -- stuff for all iterations

  /* Handle OVER loop code */
  if overterm\=null then do label overgen
    /* We now generate the code for an OVER loop
       The 'introductory' part (begpart) for an OVER loop must
       snapshot the elements in the HashTable (Rexx collection or
       Dictionary).
       This must spin through and set elements in an array as we
       have discovered [1997.01.11] that HashTable.keys does not
       snapshot.  While spinning through, we discard non-existing
       indexes for Rexx collections.

       We use a Vector rather than an array, as 1.00 Rexx class
       doesn't implement Dictionary, so we don't have size().
       We do use an array for the Dictionary case.
       */

    /* Make variables to hold:
       enum -- the enumerator [note: it's not an enumeration]
       vect -- the snapshot Vector or array of objects
       work -- the counter/indexer [int]
       stem -- the stem (collection) [only needed if complicated term]
       */
    pcursor.curclass.uniques=pcursor.curclass.uniques+1
    enumname='$'pcursor.curclass.uniques
    pcursor.curclass.uniques=pcursor.curclass.uniques+1
    vectname='$'pcursor.curclass.uniques
    pcursor.curclass.uniques=pcursor.curclass.uniques+1
    workname='$'pcursor.curclass.uniques
    -- If term is a simple name (very common) then we can avoid a
    -- temporary variable.  Could allow some other cases, possibly.
    if overterm.group=S_VAR
     then stemname=overterm.javacode
     else do
      pcursor.curclass.uniques=pcursor.curclass.uniques+1
      stemname='$'pcursor.curclass.uniques
      begpart=begpart||overterm.type.toJava stemname'='overterm.javacode';'
      end

    /* Initialize variables */
    begpart=begpart||rxt.intclass workname'=0;'
    if overrexx then begpart=begpart||rxt.vectorclass vectname'=new'-
                                      rxt.vectorclass'(100,0);'
                else begpart=begpart||rxt.objectclass'[]' vectname'=new'-
                                      rxt.objectclass'['stemname'.size()];'

    /* Protect the object during snapshot, and get enumerator. */
    begpart=begpart||'synchronized('stemname'){'
    begpart=begpart||rxt.enumclass enumname'='stemname'.keys();'
    /* the snapshot loop... */
    begpart=begpart||'for(;;){'
    if \overrexx then do
      begpart=begpart||'if('workname'=='vectname'.length)break;'
      begpart=begpart||vectname'['workname']='enumname'.nextElement();'
      end
     else /* is Rexx */ do
      begpart=begpart||'if(!'enumname'.hasMoreElements())break;'
      begpart=begpart||vectname'.addElement('enumname'.nextElement());'
      /* Is a Rexx collection, so discard and ignore item if it's unreal */
      begpart=begpart||'if(!'stemname'.testnode(('NrBabel.rexxclass')('-
                     ||vectname'.elementAt('workname')))){'-
                     ||vectname'.removeElementAt('workname');'-
                     ||'continue;}'
      end
    begpart=begpart||workname'++;}}'     -- second '}' is for synchronized
    -- at end of snapshot loop, workname variable is true count of elements

    /* Now set up the code for within the main loop */
    allpart=allpart||'if(--'workname'<0)break;'    -- decrement and test
    -- we'll need a code object for conversions [could move earlier]
    code=RxCode(S_EXPR, overtype, null)
    if \overrexx then                              -- recover item
      code.javacode='('overtype.toJava')'vectname'['workname']'
     else
      code.javacode='('overtype.toJava')'vectname'.elementAt('workname')'
    if maytrace then                               -- add tracing if necessary
      rxt.program.tracer.tracecode(code, pcursor.curclause.tokens[0],-
        var.tracetag, RexxTrace.VAR, var.varname)  -- VAR as setting
    /* Convert the RHS as required (usually not); we know it's safe */
    conv=converter.assigncost(pcursor, var.vartype, overtype)
    converter.convertcode(pcursor, var.vartype, conv.proc, code)
    allpart=allpart||varname'='code.javacode';'    -- set the tail variable
    end overgen


  /* For each of any TO, BY, FOR we generate a temporary and assignment
     only if necessary (or if tracing).
     1998.07.16: tests reversed so can be used directly in forseg2
     2000.03.10: during rework, evaluate any TO, BY, and FOR expressions
                 in the order they appear
    */
  byinit=Rexx ''                   -- initialization part
  toinit=Rexx ''                   -- ..
  forinit=Rexx ''                  -- ..
  forseg2=Rexx ''                  -- for(;seg;)
  forseg3=Rexx ''                  -- for(;;seg)
  firstpart=Rexx ''                -- stuff for 2+ iteration
  bystep1=1; bysign=1              -- default BY is BY +1
  loop v=0 for exprs.size
    expr=RxExpr exprs.elementAt(v)
    select case expr.exprtype
      when LOOP_EXPRT then do
        /* Avoid generating assignment if all constant [unless tracing] */
        toinit=toexpr.code.javacode
        select
          when maytrace then needass=boolean 1    -- cannot optimize
          when toinit.verify('1234567890+*-/()')==0 then needass=0
          when toexpr.code.constant then needass=0 -- indirect constant
          otherwise needass=1
          end
        if needass then /* general/tracing case */ do
          pcursor.curclass.uniques=pcursor.curclass.uniques+1
          totemp='$'pcursor.curclass.uniques
          -- save assignment
          toinit=initexpr.code.type.toJava totemp'='toinit';'
          end
         else do
          totemp=toinit  -- propagate directly usable code
          toinit=''      -- nothing for front part
          end
        end
      when LOOP_EXPRB then do
        /* Determine the sign and step as best we can */
        code=byexpr.code
        bystep1=0                      -- assume we don't know about BY
        bysign=0                       -- ..
        if code.constant then /* constant BY */ do label conby
          r=Rexx(rxt.interpreter.stringvalue(code))
          select
            when r=='1' then do
              bystep1=1
              bysign=1
              end
            when r=='-1' then do
              bystep1=1
              bysign=-1
              end
            when \r.datatype('N') then nop   -- worry about it later
            when r.sign.toint<0 then do      -- 'sign' does add 0
              bystep1=0
              bysign=-1
              end
            otherwise
              bystep1=0
              bysign=1
            end
          end conby
        -- setup byinit later, if we cannot optimize it
        end
      when LOOP_EXPRF then do
        /* make a counter */
        pcursor.curclass.uniques=pcursor.curclass.uniques+1
        fortemp='$'pcursor.curclass.uniques
        -- make the assignment
        forinit=rxt.intclass fortemp'='forexpr.code.javacode';'
        end
      end
    end v

  /* Custom BY processing if we had var= form */
  if assign then do label assign
    /* If tracing and there is a bypart expression, then avoid the
       bystep1 optimization so the initial BY expression is traced
       in the right place */
    if bystep1-                       -- we know it's +/- 1
     & (\maytrace | byexpr=null)      -- either not tracing or no BY part
     then do                          -- optimize...
      if bysign>0 then do; stepop='+'; compop='<='; end
                  else do; stepop='-'; compop='>='; end
      -- optimize to use Java ++/-- (increment/decrement) operator, if
      -- possible [unless tracing]
      if initexpr.code.type=rxt.inttype & \maytrace
       then firstpart=varname||stepop||stepop';'
       else /* be general, but it is +/- 1 */ do
        makebyone -- ensure we have 1
        if byexpr=null then tokby=tokvar
        code=rxt.eparser.codeop(pcursor, stepop, tokby, varcode, byonecode)
        /* Call converter.assigncost to get the conversion procedure (usu. none) */
        conv=converter.assigncost(pcursor, initexpr.code.type, code.type)
        -- already checked assignable
        converter.convertcode(pcursor, initexpr.code.type, conv.proc, code)
        if maytrace then              -- add tracing if necessary
          rxt.program.tracer.tracecode(code, pcursor.curclause.tokens[0],-
                  var.tracetag, RexxTrace.VAR, var.varname)
        firstpart=varname'='code.javacode';'
        end
      if toexpr\=null then /* forseg2=varname'<='totemp */ do
        code=RxCode(S_VAR, initexpr.code.type, null)
        code.javacode=totemp
        code=rxt.eparser.codeop(pcursor, compop, tokto, varcode, code)
        forseg2=code.javacode
        end
      end
     else /* step not known to be 1 (general by), or must trace */ do
      /* Generate the BY code evaluation */
      bypart=byexpr.code.javacode
      pcursor.curclass.uniques=pcursor.curclass.uniques+1
      bytemp='$'pcursor.curclass.uniques
      byinit=initexpr.code.type.toJava bytemp'='bypart';'   -- save assignment

      code=RxCode(S_VAR, initexpr.code.type, null)
      code.javacode=bytemp
      code=rxt.eparser.codeop(pcursor, '+', tokby, varcode, code)
      /* Call converter.assigncost to get the conversion procedure */
      conv=converter.assigncost(pcursor, initexpr.code.type, code.type)
      if conv.cost>rxt.program.flag.maxassign then
        signal RxError(rxt, tokby, 'cannot.assign',-
                       rxt.program.babel.typeString(code.type),-
                       rxt.program.babel.typeString(initexpr.code.type))
      converter.convertcode(pcursor, initexpr.code.type, conv.proc, code)
      if maytrace then                -- add tracing if necessary
        rxt.program.tracer.tracecode(code, pcursor.curclause.tokens[0],-
                var.tracetag, RexxTrace.VAR, var.varname)

      firstpart=varname'='code.javacode';'      -- [incrementer]

      if toexpr\=null then do label haveto
        /* We need to test ending condition.  If we know the sign,
           this is simple.  Otherwise we need a temporary variable. */
        tocode=RxCode(S_VAR, initexpr.code.type, null)
        tocode.javacode=totemp
        select label signtest
          when bysign>0 then do
            code=rxt.eparser.codeop(pcursor, '<=', tokto, varcode, tocode)
            forseg2=code.javacode
            end
          when bysign<0 then do
            code=rxt.eparser.codeop(pcursor, '>=', tokto, varcode, tocode)
            forseg2=code.javacode
            end
          otherwise /* sign not known */
            -- We'll need to compare the BY to zero to see what test we
            -- need.  This is done once and saved in a boolean temporary.
            zerocode=RxCode(S_LIT, rxt.inttype, null)
            zerocode.javacode='0'
            /* convert 0 to Rexx if not BINARY */
            if \pcursor.curbinary then converter.torexx(pcursor, zerocode, 1)
            bycode=RxCode(S_VAR, initexpr.code.type, null)
            bycode.javacode=bytemp
            code=rxt.eparser.codeop(pcursor, '>=', tokby, bycode, zerocode)
            pcursor.curclass.uniques=pcursor.curclass.uniques+1
            byge0temp='$'pcursor.curclass.uniques
            /* this depends on the BY value, so add to the BY assignment */
            byinit=byinit||rxt.boolclass byge0temp'='code.javacode';'
            /* Now generate: */
            /* allpart= bytemp'>=0 ?' varname'<='totemp ':' varname'>='totemp */
            code=rxt.eparser.codeop(pcursor, '<=', tokto, varcode, tocode)
            gtezcase=code.javacode
            code=rxt.eparser.codeop(pcursor, '>=', tokto, varcode, tocode)
            ltzcase=code.javacode
            forseg2= byge0temp'?'gtezcase':'ltzcase
          end signtest
        end haveto
      end /* general by */
    end assign

  /* Add the three initializer parts to the begpart, in the order coded */
  -- [there may always be a FOR part]
  loop v=0 for exprs.size
    expr=RxExpr exprs.elementAt(v)
    select case expr.exprtype
      when LOOP_EXPRT then begpart=begpart||toinit
      when LOOP_EXPRB then begpart=begpart||byinit
      when LOOP_EXPRF then begpart=begpart||forinit
      end
    end v

  /* Add the variable's initial asignment (after TO and BY and FOR are
     calculated).  Note this is different from the Rexx specification;
     but it saves a temporary variable (scarce resource for javac). */
  if assign then if initexpr.code.javacode\==varname then  -- [unless a nop]
    begpart=begpart||varname'='initexpr.code.javacode';'-- initialization

  -- handle FOR test and decrement (as above)
  if forinit\=='' then do
    if forseg2\=='' then forseg2='('forseg2')&&('fortemp'>0)'
                    else forseg2=fortemp'>0'
    if forseg3\=='' then forseg3=forseg3||','     -- [cannot be, in fact]
    forseg3=forseg3||fortemp'--'
    end

  /* code for WHILE or UNTIL */
  whilepart=Rexx ''      -- default none
  if whileexpr\=null then do
    converter.javawrap(whileexpr.code)
    whilepart='if(!'whileexpr.code.javacode')break;'
    end
   else if untilexpr\=null then do
    needfirst=1
    firstpart='if('untilexpr.code.javacode')break;'firstpart
    firsttriv=0          -- firstpart is no longer trivial
    isuntil=1            -- test is at loop end only
    end

  /* If needfirst is set, we have a firstpart.  If trivial, this can be
     incorporated in the for(;;); otherwise we need a boolean to test
     for the first iteration, and code to handle it.  This latter case
     is for when there's an UNTIL, which must be tested before the
     control variable, if any, is stepped; it must also be tested at the
     top of the loop so the correct line number is used if tracing or an
     exception.

     [1996.08.01] This is further complicated by tracing; if tracing is
     possible, we have to do it the long way so the LOOP is traced on
     second and subsequent iterations.
     */
  firstpar1=Rexx ''      -- stuff for 2+ iteration, part 1
  firstpar2=Rexx ''      -- stuff for 2+ iteration, part 2
  if needfirst then do
    if firsttriv then do -- (i.e., not tracing and not UNTIL)
      if forseg3\=='' then forseg3=forseg3||','
      forseg3=forseg3||firstpart.left(firstpart.length.toint-1) -- drop ';'
      -- firstpar1/2 remain null (we have used firstpart)
      end
     else do             -- nontrivial (UNTIL or maybe tracing)
      pcursor.curclass.uniques=pcursor.curclass.uniques+1
      firsttemp='$'pcursor.curclass.uniques
      begpart=begpart'boolean' firsttemp'=true;'
      firstpar1='if('firsttemp'){'firsttemp'=false;}else{'
      firstpar2=firstpart
      -- 2001.05.22: any test must always be moved to after the step (we
      -- forgot to do this in the UNTIL case)
      if forseg2\=='' then do label forseg2
        quitpart='if(!('forseg2'))break;'
        -- the test goes either inside the UNTIL second part, or following
        if isuntil then firstpar2=firstpar2||quitpart
                   else allpart=quitpart||allpart
        forseg2=''            -- consumed
        end forseg2
      firstpar2=firstpar2'}'  -- finish the part 2 segment
      end
    end

  -- add "synchronized" start if needed [before Try]
  if super.protcode\=null then
    rxt.program.streamer.outpart('synchronized('super.protcode.javacode'){')
   else
    rxt.program.streamer.outpart('') -- place to hang trychunk
  parser.thislevel.trychunk=rxt.program.streamer.chunks   -- where we might add "try"

  -- and now the real 'for-loop' code
  rxt.program.streamer.outpart('{')
  -- add iteration1 trace code if needed
  rxt.program.tracer.traceclause(pcursor.curclause, tracelevel, tracenames)
  rxt.program.streamer.outpart(begpart)
  labelchunk=rxt.program.streamer.chunks     -- record where we might add label
  rxt.program.streamer.outpart('for(;'forseg2';'forseg3'){')
  rxt.program.streamer.outpart(firstpar1)
  -- add iteration2+ trace code if needed
  rxt.program.tracer.traceclause(pcursor.curclause, tracelevel, tracenames)
  rxt.program.streamer.out(firstpar2||allpart||whilepart)

 /** Return a safe Java label from a NetRexx label */
 method safelabel(lab=Rexx) private returns Rexx
  if rxt.classer.javakey(lab) then lab='$'lab
  return lab

 /** Ensure we have a byonecode object */
 method makebyone private
  if byonecode\=null then return        -- already have one
  byonecode=RxCode(S_LIT, rxt.inttype, null)
  byonecode.javacode='1'
  byonecode.value=Integer(1)
  byonecode.constant=1
  conv=converter.assigncost(pcursor, initexpr.code.type, byonecode.type)
  -- can always convert 1 to a primitive or Rexx
  converter.convertcode(pcursor, initexpr.code.type, conv.proc, byonecode)
  return

 /** endinitial -- end the initial LOOP block, code generation */
 method endinitial
  -- A label might come from out LABEL or control variable, or because
  -- we had an unlabelled LEAVE or ITERATE that refers to us.
  if parser.thislevel.javalabel\=='' then    -- have a label to add
    rxt.program.streamer.outinsertpart(parser.thislevel.javalabel':', labelchunk)
  -- trivial ending
  rxt.program.streamer.out('}') -- end for(...) block

 /** Interpretation */
 method interpret(cursor=RxCursor null)
  -- PROTECT is handled at the NrBlock level
  -- note that any 'hidden' values, such as the FOR count, must be held
  -- in NrLevel, as a loop can be used recursively
  level=cursor.curlevel                 -- local reference
  cvar=level.loopvar                    -- retrieve any loop variable

  if level.clause=null, level.clause.lookaside\==this then do label firsttime
    level=rxt.interpreter.pushlevel(cursor)  -- start the LOOP block
    level.forcount=-1                        -- indicate no FOR limit

    -- find the variable if we'll be using it
    -- [could cache this in NrLevel after first time]
    if varlook\=null then cvar=pooler.refindvar(cursor, varlook)
    level.loopvar=cvar

    if overterm=null then do label nonover   -- repetitor is not OVER
      /* Evaluate any TO, BY, and FOR expressions in the order they appear */
      loop v=0 for exprs.size
        expr=RxExpr exprs.elementAt(v)
        ecode=expr.evaluate(cursor)
        select case expr.exprtype
          when LOOP_EXPRT then level.tocode=ecode
          when LOOP_EXPRB then level.bycode=ecode
          when LOOP_EXPRF then do
            -- say '# FOR:' ecode.type ecode.value forexpr.type (forexpr.conv=null)
            level.forcount=(Integer ecode.value).intValue
            -- Test for negative.  Note that compiled code doesn't, at present
            if level.forcount<0 then
              signal RxSignal(cursor, RunTimeException('For count negative'),-
                              tokfor)
            end
          end
        end v

      /* Evaluate, set and trace any assignment to control variable */
      if initexpr\=null then do
        ecode=initexpr.evaluate(cursor, cvar.tracetag, cvar.varname)
        -- it should now be of exactly the right type
        if cvar.vartype\=ecode.type then if rxt.superflag.diag then do
          say '# Loop type mismatch:' cvar.vartype '<=' ecode.type
          signal RxQuit(rxt, null, 'internal.error')
          end
        rxt.interpreter.setVar(cursor, cvar, tokvar, ecode.value) -- assign
        if level.bycode=null then level.bycode=byonecode -- [remember 1]
        bycode=level.bycode                  -- local reference
        sign=rxt.interpreter.signvalue(bycode)
        if sign>=0 then level.compop='>'
                   else level.compop='<'
        end
      end nonover
     else do label isover                    -- repetitor is OVER
      -- the code here mirrors the code generated by compiler, except
      -- that we use a Vector in both cases, for simplicity.
      -- First get the OVER term object
      item=rxt.tparser.evalterm(cursor, overterm.begoff, 1) -- this is an RHS term
      termo=item.value                       -- the term object
      do protect termo                       -- while we snapshot
        if overrexx then do
          termr=Rexx termo
          snap=Vector(100, 0)
          enum=termr.keys
          loop while enum.hasMoreElements
            ro=Rexx enum.nextElement
            -- add it to the vector iff it's real
            if termr.testnode(ro) then snap.addElement(ro)
            end
          end
         else do
          termd=Dictionary termo
          -- We know exactly how big the Vector needs to be for this
          -- non-Rexx case.
          snap=Vector(termd.size)
          enum=termd.keys
          loop for termd.size
            snap.addElement(enum.nextElement)
            end
          end
        level.oversnap=snap                  -- snapshot of objects
        level.forcount=snap.size             -- this will terminate the loop
        end -- protected snapshot
      end isover
    end firsttime

  else do label repeat
    -- [we're already on the stack]
    -- second or subsequent time here
    /* Check for UNTIL termination, if any */
    if untilexpr\=null then do
      ecode=untilexpr.evaluate(cursor)
      if ecode.isOne then do
        cursor.curact=1                      -- alert
        cursor.curacttype=CUR_LEAVE
        cursor.curactblock=this
        return
        end
     catch e=NullPointerException
      signal RxSignal(cursor, e, untilexpr.firsttoken)
      end

    /* step the control variable, if any, and trace assignment */
    -- If there's no INIT expression then it must be an OVER loop
    if cvar\=null then if initexpr\=null then do label havevar
      bycode=level.bycode
      -- directly add if Rexx type, otherwise call general adder
      varvalue=rxt.interpreter.getVar(cursor, cvar, tokvar)
      if cvar.vartype=NrBabel.rexxtype then
        varvalue=(Rexx varvalue).OpAdd(cursor.curnumer, Rexx bycode.value)
       else do protect varcode
        varcode.value=varvalue          -- copy to code object
        code=rxt.eparser.codeop(cursor, '+', tokby, varcode, bycode)
        -- conversion may be needed (e.g., if arithmetic was RexxOp)
        if code.type\=cvar.vartype then do
          conv=converter.assigncost(cursor, cvar.vartype, code.type)
          converter.convertcode(cursor, cvar.vartype, conv.proc, code)
          end
        varvalue=code.value
        end
      rxt.interpreter.setVar(cursor, cvar, tokvar, varvalue) -- assign
      if cursor.curtrace\=null then tracevar(cursor, cvar)
      end havevar
    end repeat

  /* $start: see whether to end the loop */

  /* Check control variable termination */
  if toexpr\=null then do protect varcode
    varcode.value=rxt.interpreter.getVar(cursor, cvar, tokvar)
    ecode=rxt.eparser.codeop(cursor, level.compop, tokto,-
                             varcode, level.tocode)
    if ecode.isOne then do              -- we met the condition
      cursor.curact=1                   -- alert
      cursor.curacttype=CUR_LEAVE
      cursor.curactblock=this
      return
      end
   catch e=NullPointerException
    signal RxSignal(cursor, e, tokto)
    end

  /* Check FOR count termination */
  -- This is also used to terminate an OVER loop
  if level.forcount>=0 then do
    if level.forcount=0 then do         -- loop is done
      cursor.curact=1                   -- alert
      cursor.curacttype=CUR_LEAVE
      cursor.curactblock=this
      return
      end
    level.forcount=level.forcount-1     -- count down
    end

  /* Check for WHILE termination if any */
  if whileexpr\=null then do
    ecode=whileexpr.evaluate(cursor)
    if \ecode.isOne then do
      cursor.curact=1                   -- alert
      cursor.curacttype=CUR_LEAVE
      cursor.curactblock=this
      return
      end
   catch e=NullPointerException
    signal RxSignal(cursor, e, whileexpr.firsttoken)
    end

  /* If an OVER loop, get the next value and trace it */
  if overterm\=null then do
    -- the forcount is a convenient index; the order is undefined.
    -- type of the variable was checked during parse
    rxt.interpreter.setVar(cursor, cvar, tokvar,-
                       level.oversnap.elementAt(level.forcount))
    if cursor.curtrace\=null then tracevar(cursor, cvar)
    end

  return

 /** tracevar -- trace variable as appropriate
    Arg1 is the context
    Arg2 is the variable
    */
 method tracevar(cursor=RxCursor, cvar=RxVariable) private
  -- as we didn't have a real expression to do the tracing, we must
  -- do it ourselves
  do protect varcode
    varcode.value=rxt.interpreter.getVar(cursor, cvar, tokvar) -- copy to code
    val=rxt.interpreter.stringValue(varcode)  -- always to String
    cursor.curtrace.traceString(tokens[0].line, val,-
                                cvar.tracetag, RexxTrace.VAR, cvar.varname)
    end
  return
