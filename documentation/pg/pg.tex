 \documentclass[10pt]{book}
\usepackage[FINAL]{../boilerplate/rexx} 
\usepackage{hyperref}
\usepackage{graphics}
\usepackage{fontspec} 
%\setmainfont[Mapping=tex-text]{Garamond Premier Pro}
\setmainfont[Mapping=tex-text]{Times New Roman}
\setmonofont[Mapping=tex-text,Scale=0.85]{Courier New}
%\setmainfont[Mapping=tex-text]{Helvetica}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{makeidx}
\usepackage[all]{xy}
\usepackage{lingmacros}
\usepackage{color}
\usepackage{xcolor}
%\usepackage[usenames]{color}
\usepackage{listings}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\usepackage{listings}
\input{../boilerplate/netrexxformat}
\usepackage{../boilerplate/rail}
\usepackage{pst-barcode,pstricks-add}
\hyphenation{Net-Rexx Net-Rexx-A Net-Rexx-C Net-Rexx-R Mac-OSX}
\makeindex
% \usepackage{sectsty}
% \allsectionsfont{\fontspec[Scale=0.75]{Helvetica}}
\begin{document} 
\DeclareGraphicsExtensions{.jpg,.png}
\setcounter{tocdepth}{1} 
\title{NetRexx Programming Guide}
\author{RexxLA}
\date{Version 3.01 of \today}
\maketitle
\pagenumbering{Roman}
\pagestyle{plain}
\frontmatter
\pagenumbering{Roman}
\pagestyle{plain}
\section*{Temporary Disclaimer}
This is not official in any way yet
\newpage
\tableofcontents
\newpage
\pagenumbering{arabic}
\frontmatter
\large
\input{../boilerplate/series}
\input{../boilerplate/conventions}
\include {introduction}
\mainmatter
\chapter{Meet the Rexx Family}
\section{Once upon a Virtual Machine}
On the 22nd of March 1979, to be precise, Mike Cowlishaw of IBM had a
vision of an easier to use command processor for VM, and wrote down a
specification over the following days.
VM\textsuperscript{\texttrademark} (now called z/VM) is the original Virtual Machine operating system,  stemming from an
era in which time sharing was acknowledged to be the wave of the
future and when systems as CTSS (on the IBM 704) and TSS (on the IBM
360 Family of computers) were early timesharing systems, that offered
the user an illusion of having a large machine for their exclusive
use, but fell short of virtualising the entire hardware. The CP/CMS
system changed this; CP virtualised the hardware completely and CMS was the OS
running on CP. CMS knew a succession of command interpreters, called
EXEC, EXEC2 and Rexx\textsuperscript{\texttrademark}  (originally REX - until IBM Legal interfered) -
the EXEC roots are the explanation why some people refer to an NetRexx
program as an ``exec''. As a prime example of a \emph{backronym}, Rexx
stands for ``Restructured Extended Executor''. It
can be defended that Rexx came to be as a reaction on EXEC2, but it
must be noted that both command interpreters shipped around the same
time. From 1988 on Rexx was available on MVS/TSO and other systems,
like DOS, Amiga and various Unix systems. Rexx was branded the
official SAA procedures language and was implemented on all IBM's
Operating Systems; most people got to know Rexx on OS/2. In the late
eighties the Object-Oriented successor of Rexx, Object Rexx, was
designed by Simon Nash and his colleagues in the IBM Winchester
laboratory. Rexx was thereafter known as Classic Rexx. Several open
source versions of Classic Rexx were made over the years, of which
Regina is a good example.

\section{Once upon another Virtual Machine}
In 1995 Mike Cowlishaw ported Java\textsuperscript{\texttrademark} to OS/2\textsuperscript{\texttrademark} and soon after started with
an experiment to run Rexx on the JVM\textsuperscript{\texttrademark}. With Rexx generally considered
the first of the general purpose scripting languages, NetRexx\textsuperscript{\texttrademark}  is the
first alternative language for the JVM. The 0.50 release, from April
1996, contained the NetRexx runtime classes and a translator written
in Rexx but tokenized and turned into an OS/2 executable. The 1.00
release came available in January 1997 and contained a translator
bootstrapped to NetRexx. The Rexx string type that can also handle
unlimited precision numerics is called Rexx in Java and NetRexx.
Where Classic Rexx was positioned as a system \emph{glue} language and
application macro language, NetRexx is seen as the one language that
does it all, delivering system level programs or large applications.

Release 2.00 became available in August 2000 and was a major upgrade,
in which interpreted execution was added. Until that release, NetRexx
only knew \emph{ahead of time} compilation (AOT).

Mike Cowlishaw left IBM in March 2010. IBM announced the transfer of NetRexx source code to the Rexx Language Association (RexxLA) on June 8, 2011, 14 years after the v1.0 release.

On June 8th, 2011, IBM released the NetRexx source code to RexxLA
under the ICU open source license. RexxLA shortly after released this
as NetRexx 3.00 and has followed with updates.
\section{Features of NetRexx}
\begin{description}
\item[Ease of use]
The NetRexx language is easy to read and write because many instructions are meaningful English words. Unlike some lower level programming languages that use abbreviations, NetRexx instructions are common words, such as \textbf{say}, \textbf{ask}, \textbf{if...then...else}, \textbf{do...end}, and \textbf{exit}.
\item[Free format] There are few rules about NetRexx format. You need not start an instruction in a particular column, you can also skip spaces in a line or skip entire lines, you can have an instruction span many lines or have multiple instructions on one line, variables do not need to be pre-defined, and you can type instructions in upper, lower, or mixed case.
\item[Convenient built-in functions] NetRexx supplies built-in functions
  that perform various processing, searching, and comparison
  operations for both text and numbers. Other built-in functions
  provide formatting capabilities and arithmetic calculations.
\item[Easy to debug]
When a NetRexx exec contains an error, messages with meaningful explanations are displayed on the screen. In addition, the \textbf{trace} instruction provides a powerful debugging tool.
\item[Interpreted]
The NetRexx language is an interpreted language. When a NetRexx exec
runs, the language processor directly interprets each language
statement, or translates the program in JVM bytecode.
\item[Extensive parsing capabilities]
NetRexx includes extensive parsing capabilities for character
manipulation. This parsing capability allows you to set up a pattern
to separate characters, numbers, and mixed input.
\item[Seamless use of JVM Class Libraries]
NetRexx can use any class, and class library for the JVM (written in
Java or other JVM languages) in a seamless manner, that is, without
the need for extra declarations or definitions in the source code.
\end{description}

\chapter{Learning to program}
\section{Console Based Programs}
One way that a computer can communicate with a user is to ask
questions and then compute results based on the answers typed in. In
other words, the user has a conversation with the computer. You can
easily write a list of  NetRexx instructions that will conduct a conversation. We call such a list of instructions a program.
The following listing shows a sample NetRexx program. The sample program asks the user to give his name, and then responds to him by name. For instance, if the user types in the name Joe, the reply Hello Joe is displayed. Or else, if the user does not type anything in, the reply Hello stranger is displayed.
First, we shall discuss how it works; then you can try it out for
yourself.
\begin{lstlisting}[label=hello,caption=Hello Stranger]
/* A conversation */
say "Hello! What's your name?"
who=ask
if who = '' then say "Hello stranger"
else say "Hello" who
\end{lstlisting}
Briefly, the various pieces of the sample program are:
\begin{description}
\item[\texttt{/* ... */}] A comment explaining what the program is
  about. Where Rexx programs on several platforms must start with a comment, this is not
  a hard requirement for NetRexx anymore. Still, it is a good idea to start
  every program with a comment that explains what it does.
\item [\texttt{say}] An instruction to display Hello! What' s your name? on the screen.
\item [\texttt{ask}] An instruction to read the response entered from the keyboard and put it into the computer's memory.
\item [\texttt{who}] The name given to the place in memory where the user's response is put.
\item [\texttt{if}] An instruction that asks a question. 
\item [\texttt{who = ''}] A test to determine if who is empty.
\item [\texttt{then}] A direction to execute the instruction that follows, if the tested condition is true.
\item [\texttt{say}] An instruction to display Hello stranger on the screen.
\item [\texttt{else}] An alternative direction to execute the
  instruction that follows, if the tested condition is not true. Note
  that in NetRexx, else needs to be on a separate line.
\item [\texttt{say}] An instruction to display Hello, followed by whatever is in who on the screen.
\end{description}
The text of your program should be stored on a disk that you have
access to with the help of an \emph{editor} program. On Windows,
notepad or (notepad++), jEdit, X2 or SlickEdit are suitable
candidates. On Unix based systems, including MacOSX, vim or emacs are
plausible editors. If you are on z/VM or z/OS, XEDIT or ISPF/PDF are a
given. More about editing NetRexx code in chapter \ref{editors},
\emph{Editor Support}, on page \pageref{editors}. 

When the text of the program is stored in a file, let's say we called
it \texttt{hello.nrx}, and you installed NetRexx as indicated in the
\emph{NetRexx Quick Beginning Guide}, we can run it with
\begin{verbatim}
    nrc -exec hello
\end{verbatim}
and this will yield the result:
\begin{verbatim}
NetRexx portable processor, version NetRexx after3.01, build 1-20120406-1326
Copyright (c) RexxLA, 2011.  All rights reserved.
Parts Copyright (c) IBM Corporation, 1995,2008.
Program hello.nrx
===== Exec: hello =====
Hello! What’s your name?
\end{verbatim}
If you do not want to see the version and copyright message every
time, which would be understandable, then start the program with:
\begin{verbatim}
nrc -exec -nologo hello
\end{verbatim}
This is what happened when Fred tried it.
\begin{verbatim}
Program hello.nrx
===== Exec: hello =====
Hello! What’s your name?
Fred
Hello Fred
\end{verbatim}
The \textbf{ask} instruction paused, waiting for a reply. Fred typed
Fred on the command line and, when he pressed the ENTER key, the
\textbf{ask} instruction put the word Fred into the place in the
computer's memory called ``who''. The \textbf{if} instruction asked,
is ``who'' equal to nothing:
\begin{verbatim}
who = '' 
\end{verbatim}
meaning, is the value of ``who''  (in this case, Fred) equal to
nothing:
\begin{verbatim}
"Fred = ''
\end{verbatim}
This was not true; so, the instruction after \texttt{then} was not executed; but the instruction
after \texttt{else}, was.

But when Mike tried it, this happened:
\begin{verbatim}
Program hello.nrx
===== Exec: hello =====
Hello! What’s your name?

Hello stranger
Processing of 'hello.nrx' complete
\end{verbatim}
Mike did not understand that he had to type in his name. Perhaps the
program should have made it clearer to him. Anyhow, he just pressed
ENTER. The \textbf{ask} instruction put '' (nothing) into the place in the
computer's memory called ``who''. The \textbf{if} instruction asked, is:
\begin{verbatim}
who = ''
\end{verbatim}
meaning, is the value of ``who'' equal to nothing:
\begin{verbatim}
'' = ''
\end{verbatim}
 
In this case, it was true. So, the instruction after \textbf{then} was
executed; but the instruction after \textbf{else} was not.

\section{Comments in programs}
When you write a program, remember that you will almost certainly want to read it over later (before improving it, for example). Other readers of your program also need to know what the program is for, what kind of input it can handle, what kind of output it produces, and so on. You may also want to write remarks about individual instructions themselves. All these things, words that are to be read by humans but are not to be interpreted, are called comments.
To indicate which things are comments, use:
\begin{verbatim}
/* to mark the start of a comment 
*/ to mark the end of a comment.
\end{verbatim}
The \texttt{/*} causes the translator to stop compiling and interpreting;
this starts again only after a \texttt{*/} is found, which may
be a few words or several lines later. For example,
\begin{verbatim}
/* This is a comment. */
say text /* This is on the same line as the instruction */
/* Comments may occupy more
than one line. */

\end{verbatim}
NetRexx also has line mode comments - those turn a line at a time into
a comment. They are composed of two dashes (hyphens, in listings sometimes
fused to a typographical \emph{em dash} - remember that in reality
they are two \emph{n dashes}.
\begin{verbatim}
-- this is a line comment
\end{verbatim}
\section{Strings}
When the translator sees a quote (either " or ') it stops
interpreting or compiling and just goes along looking for the matching quote. The
string of characters inside the quotes is used just as it is. Examples
of strings are:
\begin{verbatim}
'Hello'
"Final result: "
\end{verbatim}
If you want to use a quotation mark within a string you should use
quotation marks of the other kind to delimit the whole string.
\begin{verbatim}
"Don't panic"
'He said, "Bother"'
\end{verbatim}
There is another way. Within a string, a pair of quotes (of the same
kind as was used to delimit the string) is interpreted as one of that
kind.
\begin{verbatim}
'Don''t panic' (same as "Don't panic" )
 "He said, ""Bother""" (same as 'He said, "Bother"')
\end{verbatim}
\section{Clauses}
Your NetRexx program consists of a number of \emph{clauses}. A clause
can be:
\begin{enumerate}
 \item A \emph{keyword instruction} that tells the interpreter to do something; for
   example,
\begin{verbatim}
say  "the word"
\end{verbatim}
In this case, the interpreter will display the word on the user's
screen. 
\item An \emph{assignment}; for example,
\begin{verbatim}
Message = 'Take care!'
\end{verbatim}
\item A \emph{null} clause, such as a completely blank line, or
\begin{verbatim}
    ;
\end{verbatim}
\item A \emph{method call instruction} which invokes a \emph{method}
    from a \emph{class}
\begin{verbatim}
'hiawatha'.left(2)
\end{verbatim}
\end{enumerate}
\section{When does a Clause End?}
It is sometimes useful to be able to write more than one clause on a
line, or to extend a clause over many lines. The rules are:
\begin{itemize}
\item Usually, each clause occupies one line.
\item If you want to put more than one clause on a line you must use a semicolon (;) to separate the clauses.
\item If you want a clause to span more than one line you must put a
  dash (hyphen) at the end of the line to indicate that the clause
  continues on the next line. If a line does not end in a dash, a
  semicolon is implied.
\end{itemize}
What will you see on the screen when this exec is run?
\begin{lstlisting}[label=rah,caption=RAH Exec]
/* Example: there are six clauses in this program */ say "Everybody cheer!"
say "2"; say "4" ; say "6" ; say "8" ; say "Who do we" -
"appreciate?"
\end{lstlisting}

\section{Special Variables}
We have seen that a \emph{variable} is a place where some data, be it
character date or numerical data, can be held. There are some special
variables, as shown in the following program.
\lstinputlisting[label=specialvars,caption=NetRexx Special Variables]{../../../examples/rosettacode/RCSpecialVariables.nrx}
\begin{description}
\item[\texttt{this}] The special variables \textbf{this} and \textbf{super} refer to the
current instance of the class and its superclass - what this means
will be explained in detail in the chapter \textbf{Classes} on page
\pageref{classes}, as is the case with the \textbf{class} variable.

\item[\texttt{digits}]The special variable \textbf{digits} shows the current setting for the
number of decimal digits - the current setting of \textbf{numeric
  digits}. The related variable \textbf{form} returns the current
setting of \textbf{numeric form} which is either \texttt{scientific}
or \texttt{engineering}.

\item[\texttt{null}]The special variable \textbf{null} denotes the \emph{empty
  reference}. It is there when a variable has no value.

\item[\texttt{source}]The \textbf{source} and \textbf{sourceline} variables are a good way to
show the sourcefile and sourceline of a program, for example in an
error message.

\item[\texttt{trace}]The \textbf{trace} variable returns the current trace setting, which
can be one of the words \texttt{off var methods all results}. 

\item[\texttt{version}]The \textbf{version} variable returns the version of the NetRexx
translator that was in use at the time the clause we processed; in
case of interpreted execution(see chapter \ref{interpreted} on \pageref{interpreted}, it returns
the level of the current translator in use. 
\end{description}
The result of executing this exec is as follows:
\begin{verbatim}
===== Exec: RCSpecialVariables =====
<super>RCSpecialVariables@4e99353f</super>
<this>RCSpecialVariables@4e99353f</this>
<class>class RCSpecialVariables</class>
<digits>9</digits>
<form>scientific</form>
<[1, 2, 3].length>
3
</[1, 2, 3].length>
<null>

</null>
<source>Java method RCSpecialVariables.nrx</source>
<sourceline>21</sourceline>
<trace>off</trace>
<version>NetRexx 3.02 27 Oct 2011</version>
Type an answer:
hello fifi
<ask>hello fifi</ask>
\end{verbatim}
It might be useful to note here that these special variables are not
fixed in the sense of that they are not \emph{Reserved Variables}. NetRexx
does not have reserved variables and any of these special variables
can be used as an ordinary variable. However, when it is used as an
ordinary variable, there is no way to retrieve the special behavior.
\chapter{NetRexx as a Scripting Language}
You can use NetRexx as a simple scripting language without having
knowledge of, using any of the features that is needed in a Java
program that runs on the JVM. 

Scripts can be written very fast. There is
no overhead, such as defining a class, constructors and methods, and the programs contain only
the necessary instructions.

The scripting feature can be used for test purposes. It is an easy and convenient way of entering some statements and testing them.
The scripting feature can also be used for the start sequence of a
NetRexx application.

Scripts can be interpreted or compiled - there is no rule that a
script needs to be interpreted. In both cases, interpreted or
compiled, the NetRexx translator adds the necessary overhead to enable
the JVM to execute the resulting program.

\chapter{NetRexx as an Interpreted Language}\label{interpreted}

\chapter{NetRexx as a Compiled Language}

\chapter{Calling non-JVM programs}
Although NetRexx currently misses the \texttt{Address} facility that
Classic Rexx and Object Rexx do have, it is easy to call non-JVM programs
from a NetRexx program - not as easy as calling a JVM class of course, but if
the following recipe is observed, it will show not to be a major
problem. The following example is reusable for many cases.
\lstinputlisting[label=nonjava,caption=Calling Non-JVM
Programs]{../../../examples/NrxRedBk/script/NonJava.nrx} 
Just firing off a program is no big deal, but this example (in script
style) shows how easy it is to access the in- and output handles for
the environment that executes the program, which enables you to
capture the output the non-jvm program produces and do useful things
with it.\footnote{This is akin to what one would do with \emph{queue}
  on z/VM CMS and \emph{outtrap} on z/OS TSO in Classic Rexx.}
Line 17 starts the external command using the JVM \texttt{Runtime}
class in a process called \texttt{child}. In line 20 we create a
\texttt{BufferedReader} from the \texttt{child} processes'
output. This is called an InputStream but it might as well have been
called an OutputStream- everything regarding I/O is relative - but
fortunately the designers of the JVM took care of deciding this for you.
In lines 25-35 we loop through the results and show the files stored
in the zipfile. Note that we \textbf{do} (line 14) have to \textbf{catch} (line
42) the \emph{IOException} that ensues if the runtime cannot find the
\texttt{unzip} program, maybe because it is not on the path or was not
delivered with your operating system. 
\chapter{Using NetRexx classes from Java}
If you are a Java programmer, using a NetRexx class from Java is just as easy as using a Java class from NetRexx. NetRexx compiles to Java classes that can be used by Java programs.
You should import the netrexx.lang package to be able to use the short
class name for the Rexx (NetRexx string and numerics) class.

A NetRexx method without a returns keyword can return nothing, which is the void type in Java, or a Rexx string. 
NetRexx is case independent\footnote{With the default of \texttt{options
  nostrictcase} in effect.}; Java is case dependent. NetRexx generates the Java code with the case used in the class and method instructions. For example, if you named your class Spider in the NetRexx source file, the resulting Java class file is Spider.class.
The public class name in your source program must match the NetRexx
source file name. For example, if your source file is \texttt{SPIDER.NRX}, and
your class is \texttt{Spider}, NetRexx generates a warning and changes the
class name to \texttt{SPIDER} to match the file name. A Java program using the
class name Spider would not find the generated class, because its name
is \texttt{SPIDER.class} - if the compile succeeded, which is not guaranteed in
case of casing mismatches.
If you have problems, compile your NetRexx program with the \textbf{options
-keepasjava -format}. You then can look at the generated java file for the correct spelling style and method parameters.

\chapter{Classes}\label{classes}
\section{Classes}
\section{Properties}
\section{Methods}
\section{Inheritance}
\section{Overriding Methods}
\section{Overriding Properties}
\chapter{Using Packages}
Any non-toy, non-trivial program needs to be in a package. Only
examples in programming books (present company included) have programs
without package statements. The reason
for this is that there is a fairly large chance that you will give
something a name that is already used by someone else for something
else. Things are not their names\footnote{Willard Van Orman Quine, Word
  and Object, MIT Press, 1960, ISBN 0-262-67001-1}, and the same names
are given to wildly dissimilar things. The \emph{package} construct is the JVM's approach to
introducing \emph{namespaces} into the total set of programs that
programmers make. Different people will probable write some method that is
called \texttt{listDifferences} sometime. With all my software in a
package called \texttt{com.frob.nitz} and yours in a package
called \texttt{com.frob.otzim}, there is no danger of our programs
calling the wrong class and listing the wrong differences.

It is imperative to understand this chapter before continuing - it is
a mechanical nuts-and-bolts issue but an essential one at that.

\section{The package statement}
The final words about the NetRexx \textbf{package} statement is in the
NetRexx Language Reference, but the final statement about the package
\emph{mechanism} is in the JVM documentation.
\section{Translator performance consequences}
Because the NetRexx translator has to scan all packages that it can
see (meaning a recursive scan of the directories below its own level
in the directory tree, and on its classpath, it is often advisable
(and certainly if . (a dot, representing the current directory) is part of the classpath)
to do development in a subdirectory, instead of, for example, the top
level home directory. If a large number of packages and classes are
visible to the translator, compile times will be negatively impacted. 

\section{Some NetRexx package history}
All IBM versions of NetRexx had the translator in a package called
\begin{verbatim}
COM.ibm.netrexx.process 
\end{verbatim}
The official, SUN ordained
convention for package names was, to prepend the reversed domain name
of the vendor to the package name, while uppercasing the top level
domain. NetRexx, being one of the first programs to make use of
packages, followed this convention, that was quickly dropped by SUN
afterwards, probably because someone experienced what trouble it could
cause with version management software that adapted to
case-\emph{sensitive} and case-\emph{insensitive} file systems. For
NetRexx, which had started out keenly observing the rules, this
insight came late, and it is a sober fact that as a result some needlessly profane
language was uttered on occasion by some in some projects that suffered the consequences of
this. With the first RexxLA release of NetRexx in 2011, the package
name was changed to \texttt{org.netrexx}, while the runtime package
name was kept as \texttt{netrexx.lang}, because some major other
languages also follow this convention.
\section{CLASSPATH}
Most implementations of Java use an environment variable called CLASSPATH to indicate a search path for Java classes. The Java Virtual Machine and the NetRexx translator rely on the CLASSPATH value to find directories, zip files, and jar files which may contain Java classes. 
The procedure for setting the CLASSPATH environment variable depends on your operating system (and there may be more than one way).
\begin{itemize}
\item For Linux and Unix (BASH, Korn, or Bourne shell), use:
\begin{verbatim}
        CLASSPATH=<newdir>:\$CLASSPATH 
        export CLASSPATH
\end{verbatim}

\item Changes for re-boot or opening of a new window should be placed in your /etc/profile, .login, or .profile file, as appropriate. 
\item For Linux and Unix (C shell), use:
\begin{verbatim}
        setenv CLASSPATH <newdir>:\$CLASSPATH 
\end{verbatim}
Changes for re-boot or opening of a new window should be placed in
your .cshrc file. If you are unsure of how to do this, check the
documentation you have for installing the Java toolkit.
\item For Windows operating systems, it is best to set the system wide
  environment, which is accessible using the Control Panel (a search
  for ``environment'' offsets the many attempts to relocate the exact
  dialog in successive Windows Control Panel versions somewhat).
\end{itemize}

\chapter{Incorporating Class Libraries}
\section{The Collection Classes}

\chapter{Input and Output}
\section{The File Class}
\section{Streams}
\section{Line mode I/O}
\subsection{Line mode I/O using BufferedReader and PrintWriter}
\subsection{Line mode I/O using BufferedReader and BufferedWriter}
\section{Byte Oriented I/O}
\section{Data Oriented I/O}
\section{Object Oriented I/O using Serialization}
\section{The NewIO (Change!) Approach}
\chapter{Algorithms in NetRexx}
\section{Factorial}
A \emph{factorial} is the product of an integer and all the integers
below it; the mathematical symbol used is ! (the exclamation mark). For
example 4! is equal to 24 (because 4*3*2*1=24). The
following program illustrates a recursive (a method calling itself)
and an iterative approach to calculating factorials.
\lstinputlisting[label=factorial,caption=Factorial]{../../../examples/rosettacode/RCFactorial.nrx}
Executing this program yields the following result:
\begin{verbatim}
===== Exec: RCFactorial =====
Input a number: 
42
42! = 1405006117752879898543142606244511569936384000000000 (using iteration)
42! = 1405006117752879898543142606244511569936384000000000 (using recursion)
\end{verbatim}
As you can see, fortunately, both approaches come to the same
conclusion about the results. In the above program, both
approaches are a bit intermingled; for more clarity about how to use
recursion, have a look at this:
\begin{lstlisting}[label=factorialrecursive, caption=Factorial Recursive]
class Factorial
numeric digits 64

  method main(args=String[]) static
    say factorial_(42)

  method factorial_(number) static
    if number = 0 then return 1
    else return number * factorial_(number-1)

\end{lstlisting}
In this program we can clearly see that the factorial\_ method, that
takes an argument \texttt{number} (which is of type Rexx if we do not
specify it to be another type), calls itself in the method body. This
means that at runtime, another copy of it is run, with as argument
number that the first invocation returns (the result of 42*41), and so
on.

In general, a recursive algorithm is considered more elegant, while an
iterative approach has a better runtime performance. Some language
environments are optimized for recursion, which means that their
processors can spot a recursive algorithm and optimize it by not
making many useless copies of the code. Some day in the near future
the JVM will be such an environment. Also, for some problems, for example
the processing of tree structures, using a recursive algorithm seems
much more natural, while an iterative algorithm seems complicated or forced.
\section{Fibonacci}
\lstinputlisting[label=fibonacci,caption=Fibonacci]{../../../examples/rosettacode/RCFibonacciSeq.nrx}
\chapter{Using Parse}
\chapter{Using Trace}

\include{nruappl}
\chapter{Network Programming}
\section{Using Uniform Resource Locators (URL)}
\section{TCP/IP Socket I/O}
\section{RMI: Remote Method Interface}

\chapter{Database Connectivity with JDBC}

\chapter{Threads}

\chapter{Component Based Programming: Beans}

\include{nruapi}
\chapter{Interfacing to Open Object Rexx}
\section{BSF4ooRexx}

\chapter{Editor support}\label{editors}
This chapter lists editors that have plugin support for NetRexx,
ranging from syntax coloring to full IDE support (specified), and
Rexx friendly editors, that are extensible using Rexx as a macro
language (which can be the first step to provide NetRexx editing support).
\section{JVM - All Platforms}
\begin{tabularx}{\textwidth}{>{\bfseries}lX}
\toprule
JEdit & Full support for NetRexx source code editing, to be found at
\url{http://www.jedit.org}.
\\\midrule
NetRexxDE & A revisions with additions of the NetRexx plugin for
jEdit, moving to a full IDE for NetRexx. \url{http://kenai.com/projects/netrexx-misc} 
\\\midrule
Eclipse & Eclipse has a NetRexx plugin that provides a complete IDE
environment for the development of NetRexx programs (in alpha release)
by Bill Fenlason. The project is situated at SourceForge (\url{http://eclipsenetrexx.sourceforge.net/}).
\\\bottomrule
\end{tabularx}
\section{MS Windows}
\begin{tabularx}{\textwidth}{>{\bfseries}lX}
\toprule
Emacs & netrexx-mode.el (in the NetRexx package in the \texttt{tools} directory) runs on GNU Emacs for
Windows. \url{http://www.gnu.org/software/emacs/windows/faq.html}.
\\\midrule
Vim & Vi with extensions
\\\bottomrule
\end{tabularx}
\section{MacOSX}
\begin{tabularx}{\textwidth}{>{\bfseries}lX}
\toprule
Aquamacs & A version of Emacs that is integrated with the MacOSX Aqua
look and feel. (\url{http://www.aquamacs.org}). NetRexx mode is
included in the NetRexx package in the \texttt{tools} directory.
\\\midrule
Emacs & netrexx-mode.el (in the NetRexx package) runs on GNU Emacs for
MacOSX. \url{http://www.gnu.org/software/emacs}.
\\\midrule
Vim & Vi with extensions
\\\bottomrule
\end{tabularx}

\backmatter
\listoffigures
\listoftables
\lstlistoflistings
\printindex
\clearpage
\psset{unit=1in}
\begin{pspicture}(3.5,1in)
  \psbarcode{978-90-819090-0-6}{includetext guardwhitespace}{isbn}
\end{pspicture}
\end{document} 
