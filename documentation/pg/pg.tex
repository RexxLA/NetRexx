 \documentclass[10pt]{book}
\usepackage[FINAL]{../boilerplate/rexx} 
\usepackage{hyperref}
\usepackage{graphics}
\usepackage{fontspec} 
%\setmainfont[Mapping=tex-text]{Garamond Premier Pro}
\setmainfont[Mapping=tex-text]{Times New Roman}
\setmonofont[Mapping=tex-text,Scale=0.95]{Courier New}
%\setmainfont[Mapping=tex-text]{Helvetica}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{makeidx}
\usepackage[all]{xy}
\usepackage{lingmacros}
\usepackage{color}
\usepackage{xcolor}
%\usepackage[usenames]{color}
\usepackage{listings}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\usepackage{listings}
\input{../boilerplate/netrexxformat}
\usepackage{../boilerplate/rail}
\usepackage{pst-barcode,pstricks-add}
\hyphenation{Net-Rexx Net-Rexx-A Net-Rexx-C Net-Rexx-R Mac-OSX}
\makeindex
% \usepackage{sectsty}
% \allsectionsfont{\fontspec[Scale=0.75]{Helvetica}}
\begin{document} 
\DeclareGraphicsExtensions{.jpg,.png}
\setcounter{tocdepth}{1} 
\title{NetRexx Programming Guide}
\author{RexxLA}
\date{Version 3.01 of \today}
\maketitle
\pagenumbering{Roman}
\pagestyle{plain}
\frontmatter
\pagenumbering{Roman}
\pagestyle{plain}
\section*{Temporary Disclaimer}
This is not official in any way yet
\newpage
\tableofcontents
\newpage
\pagenumbering{arabic}
\frontmatter
\large
\input{../boilerplate/series}
\input{../boilerplate/conventions}
\include {introduction}
\mainmatter
\chapter{Meet the Rexx Family}
\section{Once upon a Virtual Machine}
On the 22nd of March 1979, to be precise, Mike Cowlishaw of IBM had a
vision of an easier to use command processor for VM, and wrote down a
specification over the following days.
VM\textsuperscript{\texttrademark} (now called z/VM) is the original Virtual Machine operating system,  stemming from an
era in which time sharing was acknowledged to be the wave of the
future and when systems as CTSS (on the IBM 704) and TSS (on the IBM
360 Family of computers) were early timesharing systems, that offered
the user an illusion of having a large machine for their exclusive
use, but fell short of virtualising the entire hardware. The CP/CMS
system changed this; CP virtualised the hardware completely and CMS was the OS
running on CP. CMS knew a succession of command interpreters, called
EXEC, EXEC2 and Rexx\textsuperscript{\texttrademark}  (originally REX - until IBM Legal interfered) -
the EXEC roots are the explanation why some people refer to an NetRexx
program as an ``exec''. As a prime example of a \emph{backronym}, Rexx
stands for ``Restructured Extended Executor''. It
can be defended that Rexx came to be as a reaction on EXEC2, but it
must be noted that both command interpreters shipped around the same
time. From 1988 on Rexx was available on MVS/TSO and other systems,
like DOS, Amiga and various Unix systems. Rexx was branded the
official SAA procedures language and was implemented on all IBM's
Operating Systems; most people got to know Rexx on OS/2. In the late
eighties the Object-Oriented successor of Rexx, Object Rexx, was
designed by Simon Nash and his colleagues in the IBM Winchester
laboratory. Rexx was thereafter known as Classic Rexx. Several open
source versions of Classic Rexx were made over the years, of which
Regina is a good example.

\section{Once upon another Virtual Machine}
In 1995 Mike Cowlishaw ported Java\textsuperscript{\texttrademark} to OS/2\textsuperscript{\texttrademark} and soon after started with
an experiment to run Rexx on the JVM\textsuperscript{\texttrademark}. With Rexx generally considered
the first of the general purpose scripting languages, NetRexx\textsuperscript{\texttrademark}  is the
first alternative language for the JVM. The 0.50 release, from April
1996, contained the NetRexx runtime classes and a translator written
in Rexx but tokenized and turned into an OS/2 executable. The 1.00
release came available in January 1997 and contained a translator
bootstrapped to NetRexx. The Rexx string type that can also handle
unlimited precision numerics is called Rexx in Java and NetRexx.
Where Classic Rexx was positioned as a system \emph{glue} language and
application macro language, NetRexx is seen as the one language that
does it all, delivering system level programs or large applications.

Release 2.00 became available in August 2000 and was a major upgrade,
in which interpreted execution was added. Until that release, NetRexx
only knew \emph{ahead of time} compilation (AOT).

Mike Cowlishaw left IBM in March 2010. IBM announced the transfer of NetRexx source code to the Rexx Language Association (RexxLA) on June 8, 2011, 14 years after the v1.0 release.

On June 8th, 2011, IBM released the NetRexx source code to RexxLA
under the ICU open source license. RexxLA shortly after released this
as NetRexx 3.00 and has followed with updates.
\section{Features of NetRexx}
\begin{description}
\item[Ease of use]
The NetRexx language is easy to read and write because many instructions are meaningful English words. Unlike some lower level programming languages that use abbreviations, NetRexx instructions are common words, such as \textbf{say}, \textbf{ask}, \textbf{if...then...else}, \textbf{do...end}, and \textbf{exit}.
\item[Free format] There are few rules about NetRexx format. You need not start an instruction in a particular column, you can also skip spaces in a line or skip entire lines, you can have an instruction span many lines or have multiple instructions on one line, variables do not need to be pre-defined, and you can type instructions in upper, lower, or mixed case.
\item[Convenient built-in functions] NetRexx supplies built-in functions
  that perform various processing, searching, and comparison
  operations for both text and numbers. Other built-in functions
  provide formatting capabilities and arithmetic calculations.
\item[Easy to debug]
When a NetRexx exec contains an error, messages with meaningful explanations are displayed on the screen. In addition, the \textbf{trace} instruction provides a powerful debugging tool.
\item[Interpreted]
The NetRexx language is an interpreted language. When a NetRexx exec
runs, the language processor directly interprets each language
statement, or translates the program in JVM bytecode.
\item[Extensive parsing capabilities]
NetRexx includes extensive parsing capabilities for character
manipulation. This parsing capability allows you to set up a pattern
to separate characters, numbers, and mixed input.
\item[Seamless use of JVM Class Libraries]
NetRexx can use any class, and class library for the JVM (written in
Java or other JVM languages) in a seamless manner, that is, without
the need for extra declarations or definitions in the source code.
\end{description}

\chapter{Learning to program}
\section{Console Based Programs}
One way that a computer can communicate with a user is to ask
questions and then compute results based on the answers typed in. In
other words, the user has a conversation with the computer. You can
easily write a list of  NetRexx instructions that will conduct a conversation. We call such a list of instructions a program.
The following listing shows a sample NetRexx program. The sample program asks the user to give his name, and then responds to him by name. For instance, if the user types in the name Joe, the reply Hello Joe is displayed. Or else, if the user does not type anything in, the reply Hello stranger is displayed.
First, we shall discuss how it works; then you can try it out for
yourself.
\begin{lstlisting}[label=hello,caption=Hello Stranger]
/* A conversation */
say "Hello! What's your name?"
who=ask
if who = '' then say "Hello stranger"
else say "Hello" who
\end{lstlisting}
Briefly, the various pieces of the sample program are:
\begin{description}
\item[\texttt{/* ... */}] A comment explaining what the program is
  about. Where Rexx programs on several platforms must start with a comment, this is not
  a hard requirement for NetRexx anymore. Still, it is a good idea to start
  every program with a comment that explains what it does.
\item [\texttt{say}] An instruction to display Hello! What' s your name? on the screen.
\item [\texttt{ask}] An instruction to read the response entered from the keyboard and put it into the computer's memory.
\item [\texttt{who}] The name given to the place in memory where the user's response is put.
\item [\texttt{if}] An instruction that asks a question. 
\item [\texttt{who = ''}] A test to determine if who is empty.
\item [\texttt{then}] A direction to execute the instruction that follows, if the tested condition is true.
\item [\texttt{say}] An instruction to display Hello stranger on the screen.
\item [\texttt{else}] An alternative direction to execute the
  instruction that follows, if the tested condition is not true. Note
  that in NetRexx, else needs to be on a separate line.
\item [\texttt{say}] An instruction to display Hello, followed by whatever is in who on the screen.
\end{description}
The text of your program should be stored on a disk that you have
access to with the help of an \emph{editor} program. On Windows,
notepad or (notepad++), jEdit, X2 or SlickEdit are suitable
candidates. On Unix based systems, including MacOSX, vim or emacs are
plausible editors. If you are on z/VM or z/OS, XEDIT or ISPF/PDF are a
given. More about editing NetRexx code in chapter \ref{editors},
\emph{Editor Support}, on page \pageref{editors}. 

When the text of the program is stored in a file, let's say we called
it \texttt{hello.nrx}, and you installed NetRexx as indicated in the
\emph{NetRexx Quick Beginning Guide}, we can run it with
\begin{verbatim}
    nrc -exec hello
\end{verbatim}
and this will yield the result:
\begin{verbatim}
NetRexx portable processor, version NetRexx after3.01, build 1-20120406-1326
Copyright (c) RexxLA, 2011.  All rights reserved.
Parts Copyright (c) IBM Corporation, 1995,2008.
Program hello.nrx
===== Exec: hello =====
Hello! What’s your name?
\end{verbatim}
If you do not want to see the version and copyright message every
time, which would be understandable, then start the program with:
\begin{verbatim}
nrc -exec -nologo hello
\end{verbatim}
This is what happened when Fred tried it.
\begin{verbatim}
Program hello.nrx
===== Exec: hello =====
Hello! What’s your name?
Fred
Hello Fred
\end{verbatim}
The \textbf{ask} instruction paused, waiting for a reply. Fred typed
Fred on the command line and, when he pressed the ENTER key, the
\textbf{ask} instruction put the word Fred into the place in the
computer's memory called ``who''. The \textbf{if} instruction asked,
is ``who'' equal to nothing:
\begin{verbatim}
who = '' 
\end{verbatim}
meaning, is the value of ``who''  (in this case, Fred) equal to
nothing:
\begin{verbatim}
"Fred = ''
\end{verbatim}
This was not true; so, the instruction after \texttt{then} was not executed; but the instruction
after \texttt{else}, was.

But when Mike tried it, this happened:
\begin{verbatim}
Program hello.nrx
===== Exec: hello =====
Hello! What’s your name?

Hello stranger
Processing of 'hello.nrx' complete
\end{verbatim}
Mike did not understand that he had to type in his name. Perhaps the
program should have made it clearer to him. Anyhow, he just pressed
ENTER. The \textbf{ask} instruction put '' (nothing) into the place in the
computer's memory called ``who''. The \textbf{if} instruction asked, is:
\begin{verbatim}
who = ''
\end{verbatim}
meaning, is the value of ``who'' equal to nothing:
\begin{verbatim}
'' = ''
\end{verbatim}
 
In this case, it was true. So, the instruction after \textbf{then} was
executed; but the instruction after \textbf{else} was not.

\section{Comments in programs}
When you write a program, remember that you will almost certainly want to read it over later (before improving it, for example). Other readers of your program also need to know what the program is for, what kind of input it can handle, what kind of output it produces, and so on. You may also want to write remarks about individual instructions themselves. All these things, words that are to be read by humans but are not to be interpreted, are called comments.
To indicate which things are comments, use:
\begin{verbatim}
/* to mark the start of a" comment 
*/ to mark the end of a comment.
\end{verbatim}
The \texttt{/*} causes the translator to stop compiling and interpreting;
this starts again only after a \texttt{*/} is found, which may
be a few words or several lines later. For example,
\begin{verbatim}
/* This is a comment. */
say text /* This is on the same line as the instruction */
/* Comments may occupy more
than one line. */

\end{verbatim}
NetRexx also has line mode comments - those turn a line at a time into
a comment. They are composed of two dashes (in listings sometimes
fused to a typographical \emph{em dash} - remember that in reality
they are two \emph{n dashes}.
\begin{verbatim}
-- this is a line comment
\end{verbatim}
\section{Strings}
When the interpreter sees a quote (either II or ') it stops
interpreting and just goes along looking for the matching quote. The
string of characters inside the quotes is used just as it is. Examples
of strings are:
\begin{verbatim}
'Hello'
"Final result: "
\end{verbatim}
If you want to use a quotation mark within a string you should use
quotation marks of the other kind to delimit the whole string.
\begin{verbatim}
"Don't panic"
'He said, "Bother"'
\end{verbatim}
There is another way. Within a string, a pair of quotes (of the same
kind as was used to delimit the string) is interpreted as one of that
kind.
\begin{verbatim}
'Don''t panic' (same as "Don't panic" )
 "He said, ""Bother""" (same as 'He said, "Bother"')
\end{verbatim}
\section{Clauses}
Your NetRexx program consists of a number of \emph{clauses}. A clause
can be:
\begin{enumerate}
 \item A \emph{keyword instruction} that tells the interpreter to do something; for
   example,
\begin{verbatim}
say  "the word"
\end{verbatim}
In this case, the interpreter will display the word on the user's
screen. 
\item An \emph{assignment}; for example,
\begin{verbatim}
Message = 'Take care!'
\end{verbatim}
\item A \emph{null} clause, such as a completely blank line, or
\begin{verbatim}
    ;
\end{verbatim}
\item A \emph{method call instruction} which invokes a \emph{method}
    from a \emph{class}
\begin{verbatim}
'hiawatha'.left(2)
\end{verbatim}
\end{enumerate}
\section{When does a Clause End?}
It is sometimes useful to be able to write more than one clause on a
line, or to extend a clause over many lines. The rules are:
\begin{itemize}
\item Usually, each clause occupies one line.
\item If you want to put more than one clause on a line you must use a semicolon (;) to separate the clauses.
\item If you want a clause to span more than one line you must put a
  dash (hyphen) at the end of the line to indicate that the clause
  continues on the next line. If a line does not end in a dash, a
  semicolon is implied.
\end{itemize}
What will you see on the screen when this exec is run?
\begin{lstlisting}[label=rah,caption=RAH Exec]
/* Example: there are six clauses in this program */ say "Everybody cheer!"
say "2"; say "4" ; say "6" ; say "8" ; say "Who do we" -
"appreciate?"
\end{lstlisting}
\chapter{NetRexx as a Scripting Language}
You can use NetRexx as a simple scripting language without having
knowledge of, using any of the features that is needed in a Java
program that runs on the JVM. 

Scripts can be written very fast. There is
no overhead, such as defining a class, constructors and methods, and the programs contain only
the necessary instructions.

The scripting feature can be used for test purposes. It is an easy and convenient way of entering some statements and testing them.
The scripting feature can also be used for the start sequence of a
NetRexx application.

Scripts can be interpreted or compiled - there is no rule that a
script needs to be interpreted. In both cases, interpreted or
compiled, the NetRexx translator adds the necessary overhead to enable
the JVM to execute the resulting program.

\chapter{NetRexx as an Interpreted Language}

\chapter{NetRexx as a Compiled Language}

\chapter{Calling non-JVM programs}

\chapter{Using NetRexx classes from Java}
If you are a Java programmer, using a NetRexx class from Java is just as easy as using a Java class from NetRexx. NetRexx compiles to Java classes that can be used by Java programs.
You should import the netrexx.lang package to be able to use the short
class name for the Rexx (NetRexx string and numerics) class.

A NetRexx method without a returns keyword can return nothing, which is the void type in Java, or a Rexx string. 
NetRexx is case independent; Java is case dependent. NetRexx generates the Java code with the case used in the class and method instructions. For example, if you named your class Spider in the NetRexx source file, the resulting Java class file is Spider.class.
The public class name in your source program must match the NetRexx
source file name. For example, if your source file is SPIDER.NRX, and
your class is Spider, NetRexx generates a warning and changes the
class name to SPIDER to match the file name. A Java program using the
class name Spider would not find the generated class, because its name
is SPIDER.class - if the compile succeeded, which is not guaranteed in
case of casing mismatches.
If you have problems, compile your NetRexx program with the options
-keepasjava -format. You then can look at the generated java file for the correct spelling style and method parameters.

\chapter{Classes}
\section{Classes}
\section{Properties}
\section{Methods}
\section{Inheritance}
\section{Overriding Methods}
\section{Overriding Properties}
\chapter{Incorporating Class Libraries}
\section{The Collection Classes}
\section{CLASSPATH}
\chapter{Input and Output}
\section{The File Class}
\section{Streams}
\section{Line mode I/O}
\subsection{Line mode I/O using BufferedReader and PrintWriter}
\subsection{Line mode I/O using BufferedReader and BufferedWriter}
\section{Byte Oriented I/O}
\section{Data Oriented I/O}
\section{Object Oriented I/O using Serialization}
\chapter{Algorithms in NetRexx}
\section{Fibonacci}
\lstinputlisting[label=fibonacci,caption=Fibonacci]{../../../examples/rosettacode/RCFibonacciSeq.nrx}
\chapter{Using Parse}
\chapter{Using Trace}

\chapter{User Interfaces}
\section{AWT}
\section{Swing}
\subsection{Creating NetRexx Swing interfaces with NetBeans}
\section{Web Frameworks}
\subsection{JSF}
\chapter{Network Programming}
\section{Using Uniform Resource Locators (URL)}
\section{TCP/IP Socket I/O}
\section{RMI: Remote Method Interface}

\chapter{Database Connectivity with JDBC}

\chapter{Threads}

\chapter{Component Based Programming: Beans}

\chapter{Interfacing to Open Object Rexx}
\section{BSF4ooRexx}

\chapter{Editor support}\label{editors}
This chapter lists editors that have plugin support for NetRexx,
ranging from syntax coloring to full IDE support (specified), and
Rexx friendly editors, that are extensible using Rexx as a macro
language (which can be the first step to provide NetRexx editing support).
\section{JVM - All Platforms}
\begin{tabularx}{\textwidth}{>{\bfseries}lX}
\toprule
JEdit & Full support for NetRexx source code editing, to be found at
\url{http://www.jedit.org}.
\\\midrule
NetRexxDE & A revisions with additions of the NetRexx plugin for
jEdit, moving to a full IDE for NetRexx. \url{http://kenai.com/projects/netrexx-misc} 
\\\midrule
Eclipse & Eclipse has a NetRexx plugin that provides a complete IDE
environment for the development of NetRexx programs (in alpha release)
by Bill Fenlason. The project is situated at SourceForge (\url{http://eclipsenetrexx.sourceforge.net/}).
\\\bottomrule
\end{tabularx}
\section{MS Windows}
\begin{tabularx}{\textwidth}{>{\bfseries}lX}
\toprule
Emacs & netrexx-mode.el (in the NetRexx package in the \texttt{tools} directory) runs on GNU Emacs for
Windows. \url{http://www.gnu.org/software/emacs/windows/faq.html}.
\\\midrule
Vim & Vi with extensions
\\\bottomrule
\end{tabularx}
\section{MacOSX}
\begin{tabularx}{\textwidth}{>{\bfseries}lX}
\toprule
Aquamacs & A version of Emacs that is integrated with the MacOSX Aqua
look and feel. (\url{http://www.aquamacs.org}). NetRexx mode is
included in the NetRexx package in the \texttt{tools} directory.
\\\midrule
Emacs & netrexx-mode.el (in the NetRexx package) runs on GNU Emacs for
MacOSX. \url{http://www.gnu.org/software/emacs}.
\\\midrule
Vim & Vi with extensions
\\\bottomrule
\end{tabularx}

\backmatter
\listoffigures
\listoftables
\lstlistoflistings
\printindex
\clearpage
\psset{unit=1in}
\begin{pspicture}(3.5,1in)
  \psbarcode{978-90-819090-0-6}{includetext guardwhitespace}{isbn}
\end{pspicture}
\end{document} 
