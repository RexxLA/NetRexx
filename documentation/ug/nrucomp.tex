% .* ------------------------------------------------------------------
% .* NetRexx User's Guide                                              mfc
% .* Copyright (c) IBM Corporation 1996, 2000.  All Rights Reserved.
% .* ------------------------------------------------------------------
\chapter{Using the translator as a Compiler}
\index{/compiling/NetRexx programs}
\index{/using the translator/as a Compiler}
The installation instructions for the NetRexx translator describe how to
use the package to compile and run a simple NetRexx program
(\emph{hello.nrx}).  When using the translator in this way (as a
compiler), the translator parses and checks the NetRexx source code, and
if no errors were found then generates Java source code.  This Java code
(which is known to be correct) is then compiled into bytecodes
(\emph{.class} files) using a Java compiler.  By default,
the \emph{javac} compiler in the Java toolkit is used.

This section explains more of the options available to you when using
the translator as a compiler.
% .*
\section{The translator command}
\index{ /command/for compiling}

\index{ /NetRexxC/class}
The translator is invoked by running a Java program (class) which is
called \emph{COM.ibm.netrexx.process.NetRexxC} (:q.\emph{NetRexxC}:eq.,
for short).  This can be run by using the Java interpreter, for example,
by the command:
:xmp.
java COM.ibm.netrexx.process.NetRexxC
:exmp.
\index{ /scripts/NetRexxC}
\index{ /NetRexxC/scripts}
\index{ /scripts/nrc}
\index{ /nrc scripts}
:pc.or by using a system-specific script (such as \emph{NetRexxC.cmd}.
or \emph{nrc.bat}).  In either case, the compiler invocation is followed
by one or more file specifications (these are the names of the files
containing the NetRexx source code for the programs to be compiled).

\index{ /file specifications}
File specifications may include a path; if no path is given then
NetRexxC will look in the current (working) directory for the file.
NetRexxC will add the extension \emph{.nrx} to input program names (file
specifications) if no extension was given.

So, for example, to compile \emph{hello.nrx} in the current directory,
you could use any of:
:xmp.
java COM.ibm.netrexx.process.NetRexxC hello
java COM.ibm.netrexx.process.NetRexxC hello.nrx
NetRexxC hello.nrx
nrc hello
:exmp.
:pc.(the first two should always work, the last two require that the
system-specific script be available).  The resulting \emph{.class} file
is placed in the current directory, and the \emph{.crossref}
(cross-reference) file is placed in the same directory as the source
file (if there are any variables and the compilation has no errors).

Here's an example of compiling two programs, one of which is in the
directory \emph{d:\textbackslash myprograms}:
:xmp.
nrc hello d:\textbackslash myprograms\textbackslash test2.nrx
:exmp.
:pc.
In this case, again, the \emph{.class} file for each program is placed
in the current directory.

Note that when more than one program is specified, they are all compiled
within the same class context.  That is, they can :q.see:eq. the
classes, properties, and methods of the other programs being compiled,
much as though they were all in one file.
:fn.
The programs do, however, maintain their independence (that is, they may
have different :kw.options:ekw., :kw.import:ekw., and :kw.package:ekw.
instructions).
:efn.
This allows mutually interdependent programs and classes to be compiled
in a single operation.
Note that if you use the :kw.package:ekw. instruction you should also
read the more detailed :a id=compmult.:cit.Compiling multiple
programs:ecit. section:ea..

\index{ /completion codes, from translator}
\index{ /return codes, from translator}
On completion, the NetRexxC class will exit with one of three return
values: 0 if the compilation of all programs was successful, 1 if there
were one or more Warnings, but no errors, and 2 if there were one or
more Errors.

\index{ /option words}
\index{ /flags}
As well as file names, you can also specify various option words, which
are distinguished by the word being prefixed with :q.\emph{-}:eq..  These
flagged words (or :q.flags:eq.) may be any of the option words allowed
on the NetRexx :kw.options:ekw. instruction (see the NetRexx language
documentation).  These options words can be freely mixed with file
specifications.  To see a full list of options, execute the NetRexxC
command without specifying any files.

The translator also implements some additional option words, which
control compilation features.  These cannot be used on the
:kw.options:ekw. instruction, and are:
.cp 4
:dl termhi=4.
:dt id=optkeep.-keep
\index{ /option/keep}
\index{ /flag/keep}
\index{ /keep option}
:dd.
keep the intermediate \emph{.java} file for each program.  It is kept in
the same directory as the NetRexx source file as \emph{xxx.java.keep},
where \emph{xxx} is the source file name.  The file will also be kept
automatically if the \emph{javac} compilation fails for any reason.
.* - - - -
.cp 4
:dt id=optnocomp.-nocompile
\index{ /option/nocompile}
\index{ /flag/nocompile}
\index{ /nocompile option}
:dd.
do not compile (just translate).  Use this option when you want to use a
different Java compiler.  The \emph{.java} file for each program is kept
in the same directory as the NetRexx source file, as the
file \emph{xxx.java.keep} (where \emph{xxx} is the source file name).
.* - - - -
.cp 4
:dt id=optnocons.-noconsole
\index{ /option/noconsole}
\index{ /flag/noconsole}
\index{ /noconsole option}
:dd.
do not display compiler messages on the console (command display
screen).  This is usually used with the \emph{savelog} option.
.* - - - -
.cp 4
:dt id=optsavelog.-savelog
\index{ /option/savelog}
\index{ /flag/savelog}
\index{ /savelog option}
:dd.
write compiler messages to the file \emph{NetRexxC.log}, in the current
directory.
This is often used with the \emph{noconsole} option.
.* - - - -
.cp 4
:dt id=opttime.-time
\index{ /option/time}
\index{ /flag/time}
\index{ /time option}
:dd.
display translation, \emph{javac} compile, and total times (for the sum
of all programs processed).
.* - - - -
.cp 4
:dt id=optrun.-run
\index{ /option/run}
\index{ /flag/run}
\index{ /run option}
:dd.
run the resulting Java class as a stand-alone application, provided that
the compilation had no errors.
(See note below.)
:edl.
.cp 11

Here are some examples:
:xmp.
java COM.ibm.netrexx.process.NetRexxC hello -keep -strictargs
java COM.ibm.netrexx.process.NetRexxC -keep hello wordclock
java COM.ibm.netrexx.process.NetRexxC hello wordclock -nocompile
nrc hello
nrc hello.nrx
nrc -run hello
nrc -run Spectrum -keep
nrc hello -binary -verbose1
nrc hello -noconsole -savelog -format -keep
:exmp.

Option words may be specified in lowercase, mixed case, or uppercase.
File specifications are platform-dependent and may be case sensitive,
though NetRexxC will always prefer an exact case match over a mismatch.
.*
:note.The \emph{-run} option is implemented by a script (such
as \emph{nrc.bat} or \emph{NetRexxC.cmd}), not by the translator; some
scripts (such as the \emph{.bat} scripts) may require that
the \emph{-run} be the first word of the command arguments, and/or be in
lowercase.  They may also require that only the name of the file be
given if the \emph{-run} option is used.  Check the commentary at the
beginning of the script for details.
.*
.* = = = = = = = = = = =
\section{Compiling multiple programs and using packages}
\index{ /compiling/multiple programs}

When you specify more than one program for NetRexxC to compile, they are
all compiled within the same class context: that is, they can :q.see:eq.
the classes, properties, and methods of the other programs being
compiled, much as though they were all in one file.

This allows mutually interdependent programs and classes to be compiled
in a single operation.  For example, consider the following two programs
(assumed to be in your current directory, as the files \emph{X.nrx}
and \emph{Y.nrx}):
:xmp.
/* X.nrx */
class X
  why=Y null

/* Y.nrx */
class Y
  exe=X null
:exmp.
:pc.Each contains a reference to the other, so neither can be compiled in
isolation.  However, if you compile them together, using the command:
:xmp.
nrc X Y
:exmp.
:pc.then the cross-references will be resolved correctly.

The total elapsed time will be significantly less, too, as the classes
on the CLASSPATH need to be located only once, and the class files used
by the NetRexxC compiler or the programs themselves will also only be
loaded (and JIT-compiled) once.

\index{ /projects, compiling}
\index{ /packages, compiling}
\index{ /compiling/packages}
This example works as you would expect for programs that are not in
packages.  There's a restriction, though, if the classes you are
compiling :i.are:ei. in packages (that is, they include a
:kw.package:ekw. instruction).  Currently, NetRexxC uses the \emph{javac}
compiler to generate the \emph{.class} files, and for mutually-dependent
files like these, \emph{javac} requires that the source files be in the
Java CLASSPATH, in the sub-directory described by the :kw.package:ekw.
instruction.
.cp 3

So, for example, if your project is based on the tree:
:xmp.
D:\textbackslash myproject
:exmp.
:pc.then if the two programs above specified a package, thus:
:xmp.
/* X.nrx */
package foo.bar
class X
  why=Y null

/* Y.nrx */
package foo.bar
class Y
  exe=X null
:exmp.
:pc.then:
.cp 3
:ol.
:li.
You should put these source files in the directory:
\emph{D:\textbackslash myproject\textbackslash foo\textbackslash bar}
:li.
The directory \emph{D:\textbackslash myproject} should appear in your CLASSPATH
setting (if you don't do this, \emph{javac} will complain that it cannot
find one or other of the classes).
:li.
You should then make the current directory be \emph{D:\textbackslash
myproject\textbackslash foo\textbackslash bar}
and then compile the programs using the command :q.\emph{nrc X Y}:eq.,
as above.
:eol.

With this procedure, you should end up with the \emph{.class} files in
the same directory as the \emph{.nrx} (source) files, and therefore also
on the CLASSPATH and immediately usable by other packages.  In general,
this arrangement is recommended whenever you are writing programs that
reside in packages.
.cp 4
:b.Notes::eb.
:ol.
:li.
When \emph{javac} is used to generate the \emph{.class} files, no
new \emph{.class} files will be created if any of the programs being
compiled together had errors - this avoids accidentally generating
mixtures of new and old \emph{.class} files that cannot work with each
other.
:li.
If a class is abstract or is an adapter class then it should be placed
in the list before any classes that extend it (as otherwise any
automatically generated methods will not be visible to the subclasses).
:eol.
.*
.* = = = = = = = = = = =
\section{Compiling from another program}
\index{ /compiling/from another program}

The translator may be called from a NetRexx or Java program directly, by
invoking the \emph{main} method in the \emph{COM.ibm.netrexx.process.NetRexxC}
class described as follows:
:xmp.
method main(arg=Rexx, log=PrintWriter null) static returns int
:exmp.
:pc.The \emph{Rexx} string passed to the method can be any combination of
program names and options (except \emph{-run}), as described above.
Program names may optionally be enclosed in double-quote characters (and
must be if the name includes any blanks in its specification).
.cp 6

A sample NetRexx program that invokes the NetRexx compiler to compile a
program called \emph{test} is:
:xmp.
/* compiletest.nrx */
s='test -keep -verbose4 -utf8'
say COM.ibm.netrexx.process.NetRexxC.main(s)
:exmp.

Alternatively, the compiler may be called using the method:
:xmp.
method main2(arg=String[], log=PrintWriter null) static returns int
:exmp.
:pc.in which case each element of the \emph{arg} array must contain
either a name or an option (except \emph{-run}, as before).  In this
case, names must :i.not:ei. be enclosed in double-quote characters, and
may contain blanks.

\index{ /completion codes, from translator}
\index{ /return codes, from translator}
\index{ /PrintWriter stream for capturing translator output}
\index{ /capturing translator output}
For both methods, the returned \emph{int} value will be one of the
return values described above, and the second argument to the method is
an optional \emph{PrintWriter} stream.  If the \emph{PrintWriter} stream
is provided, translator messages will be written to that stream (in
addition to displaying them on the console, unless \emph{-noconsole} is
specified).
It is the responsibility of the caller to create the stream (autoflush
is recommended) and to close it after calling the compiler.
The \emph{-savelog} compiler option is ignored if a \emph{PrintWriter}
is provided (the \emph{-savelog} option normally creates
a \emph{PrintWriter} for the file \emph{NetRexxC.log}).
.*
:note.
NetRexxC is thread-safe (the only static properties are constants), but
it is not known whether \emph{javac} is thread-safe.  Hence the
invocation of multiple instances of NetRexxC on different threads should
probably specify \emph{-nocompile}, for safety.
