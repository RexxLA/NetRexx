.* ------------------------------------------------------------------
.* NetRexx User's Guide                                              mfc
.* Copyright (c) IBM Corporation 1996, 2000.  All Rights Reserved.
.* ------------------------------------------------------------------
:h2 id=useinter.Using the translator as an Interpreter
.pi /interpreting/NetRexx programs
.pi /using the translator/as an Interpreter
:p.
In addition to being used as a compiler, the translator also includes a
true NetRexx interpreter, allowing NetRexx programs to be run on the
Java 2 (1.2) platform without needing a compiler or generating .class
files.
:p.
The startup time for running programs can therefore be significantly
reduced as no Java source code or compilation is needed, and also the
interpreter can give better runtime support (for example, exception
tracebacks are localized to the programs being interpreted, and the
location of an exception will be identified often to the nearest token
in a term or expression).
:p.
Further, in a single run, a NetRexx program can be both interpreted and
then compiled.  This shares the parsing between the two processes, so
the :m..class:em. file is produced without the overhead of
re-translating and re-checking the source.
.* - - -
:h4.Interpreting programs
:p.
The NetRexx interpreter is currently designed to be fully compatible
with NetRexx programs compiled conventionally.  There are some minor
:a id=restint.restrictions:ea., but in general any program that NetRexxC
can compile without error should run.  In particular, multiple programs,
threads, event listeners, callbacks, and Minor (inner) classes are fully
supported.
:p.
To use the interpreter, use the NetRexxC command as usual and specify
either of the following command options (flags):
.cp 4
:dl termhi=4.
:dt id=optexec.-exec
.pi /option/exec
.pi /flag/exec
.pi /exec option
:dd.:p.
after parsing, execute (interpret) the program or programs by calling
the static :m.main(String[]):em. method on the first class, with an
empty array of strings as the argument.  (If there is no suitable :m.main:em.
method an error will be reported.)
:dt id=optarg.-arg words...
.pi /option/arg
.pi /flag/arg
.pi /arg option
:dd.:p.
as for :m.-exec:em., except that the remainder of the command argument
string passed to NetRexxC will be passed on to the main method as the
array of argument strings, instead of being treated as file
specifications or flags.  Specifying :m.-noarg:em. is equivalent to
specifying :m.-exec:em.; that is, an empty array of argument strings
will be passed to the main method (and any remaining words in the
command argument string are processed normally).
:edl.
:p.
When any of :m.-exec:em., :m.-arg:em., or :m.-noarg:em. is specified,
NetRexxC will first parse and check the programs listed on the command.
If no error was found, it will then run them by invoking the main method
of the first class interpretively.
:p.
Before the run starts, a line similar to:
:xmp.
===== Exec: hello =====
:exmp.
:pc.
.pi /option/verbose
.pi /flag/verbose
.pi /verbose option
will be displayed (you can stop this and other progress indicators being
displayed by using the :m.-verbose0:em. flag, as usual).
:p.
.pi /option/nojava
.pi /flag/nojava
.pi /nojava option
.pi /option/nocompile
.pi /flag/nocompile
.pi /nocompile option
Finally, after interpretation is complete, the programs are compiled in
the usual way, unless :m.-nojava:em.
:fn.
The :m.-nojava:em. flag stops any Java source being produced, so
prevents compilation.  This flag may be used to force syntax-checking of
a program while preventing compilation, and with optional
interpretation.
:efn.
or :m.-nocompile:em. was specified.
:p.
For example, to interpret the :q.hello world:eq. program without
compilation, the command:
:xmp.
nrc hello -exec -nojava
:exmp.
:pc.
can be used.  If you are likely to want to re-interpret the program (for
example, after changing the source file) then also specify
the :m.-prompt:em. flag, as described above.  This will give very much
better performance on the second and subsequent interpretations.
:p.
Similarly, the command:
:xmp.
nrc hello -nojava -arg Hi Fred!
:exmp.
:pc.
would invoke the program, passing the words :q.:m.Hi Fred!:em.:eq. as
the argument to the program (you might want to add the line :q.:m.say
arg:em.:eq. to the program to demonstrate this).
:p.
You can also invoke the interpreter directly from another NetRexx or
Java program, as described in the :a id=useapi.:cit.Using the NetRexxA
API:ecit. section:ea..
.*
.* ==========
.cp 8
:h4.Interpreting &dash. Hints and Tips
.pi /interpreting/hints and tipes
:p.
When using the translator as an interpreter, you may find these hints
useful:
:ul.
:li.
If you can, use the :m.-prompt:em. command line option (see above).
This will allow very rapid re-interpretation of programs after changing
their source.
:li.
If you don't want the programs to be compiled after interpretation,
specify the :m.-nojava:em. option, unless you want the Java source code
to be generated in any case (in which case specify :m.-nocompile:em.,
which implies :m.-keep:em.).
:li.
By default, NetRexxC runs fairly :q.noisily:eq. (with a banner and logo
display, and progress of parsing being shown).  To turn off these
messages during parsing (except error reports and warnings) use
the :m.-verbose0:em. flag.
:li.
.pi /option/trace1
.pi /flag/trace1
.pi /trace1 option
If you are watching NetRexx trace output while interpreting, it is often
a good idea to use the :m.-trace1:em. flag.  This directs trace output
to the standard output stream, which will ensure that trace output and
other output (for example, from :kw.say:ekw. instructions) are
synchronized.
:li.
Use the NetRexx :kw.exit:ekw. instruction (rather than the :m.System.exit():em.
method call) to end windowing (AWT) applications which are to be
interpreted.  This will allow the interpreter to correctly determine
when the application has ended.  This is discussed further in the
:a id=restint.:cit.Interpreter restrictions:ecit. section:ea..
:eul.
.*
.* ==========
.cp 8
:h4.Interpreting &dash. Performance
.pi /interpreting/performance
.pi /performance, while interpreting
:p.
The initial release of the interpreter, in the NetRexx 2.0 reference
implementation, directly and efficiently interprets NetRexx
instructions.  However, to assure the stability of the code, terms and
expressions within instructions are currently fully re-parsed and
checked each time they are executed.  This has the effect of slowing the
execution of terms and expressions significantly; performance
measurements on the initial release are therefore unlikely to be
representative of later versions that might be released in the future.
:p.
For example, at present a loop controlled using :q.:m.loop for
1000:em.:eq. will be interpreted around 50 times faster than a loop
controlled by :q.:m.loop i=1 to 1000:em.:eq., even in a binary method,
because the latter requires an expression evaluation each time around
the loop.
.* ===========
