.* ------------------------------------------------------------------
.* NetRexx User's Guide                                              mfc
.* Copyright (c) IBM Corporation 1996, 2000.  All Rights Reserved.
.* ------------------------------------------------------------------
:h1 id=restrict.Appendix: Current restrictions
.ty Page &restrict.: NRUsers Appendix ...
.pi /restrictions

The NetRexx translator is now functionally complete, though work
continues on usability and performance improvements.  As of this version
there are still a number of restrictions, listed below.

Please note that the presence of an item in this section is not a
commitment to remove a restriction in some future update; NetRexx
enhancements are dependent on on-going research, your feedback, and
available resources.  You should treat this list as a wish-list
(and please send in your wishes).
.*
:h4.General restrictions
.pi /restrictions/general
.pi /restrictions/translator
:ul.
:li.
The translator requires that Java :b.1.1.2:eb. or later be installed.
To use the interpreter functions, Java :b.1.2:eb. (Java 2) is required.
.*
:li.
Certain forward references (in particular, references to methods later
in a program from the argument list of an earlier method) are not
handled by the translator.  For these, try reordering the methods.
:eul.
.* ----------
.cp 7
:h4.Compiler restrictions
.pi /restrictions/compiler
.pi /javac/problems with
.pi /problems/javac

The following restrictions are due to the use of a translator for
compiling, and would probably only be lifted if a direct-to-bytecodes
NetRexx compiler were built.
:ul.
:li.
.pi /names/restrictions
.pi /names/$0...
Externally-visible names (property, method, and class names) cannot be
Java reserved words (you probably want to avoid these anyway, as people
who have to write in Java cannot refer to them), and cannot start with
:m.$0:em..
:li.
There are various restrictions on naming and the contents of programs
(the first class name must match the program name, &etc.), required to
meet Java rules.
:li.
The :m.javac:em. compiler requires that mutually-dependent source files
be on the CLASSPATH, so it can find the source files.
NetRexxC does not have this restriction, but when using :m.javac:em. for
the final compilation you will need to follow the convention described
in the :a id=compmult.:cit.Compiling multiple programs and using
packages:ecit. section:ea..
:li.
.pi /symbols option, restriction
.pi /option/symbols
The :m.symbols:em. option (which requests that debugging information be
added to generated :m..class:em. files) applies to all programs compiled
together if any of them specify that option.
:li.
.pi /underflow, binary
Some binary floating point underflows may be treated as zero instead
of being trapped as errors.
:li.
When \textbf{trace} is used, side-effects of calls to :m.this():em.
and :m.super():em. in constructors may be seen before the method and
method call instructions are traced &dash. this is because the Java
language does not permit tracing instructions to be added before the
call to :m.this():em. or :m.super():em..
:li.
The results of expressions consisting of the single term
:m.null:em. are not traced.
:li.
When a minor (inner) class is explicitly imported, its parent class or
classes must also be explicitly imported, or :m.javac:em. will report
that the class cannot be found.
:li.
.pi /illegal target of jump or branch
.pi /jump or branch, illegal target of
If you have a \textbf{loop} construct with a large number (perhaps
hundreds) of instructions inside it, running the compiled class may fail
with an \textbf{illegal target of jump or branch} verification error
(or, under Java 1.1, simply terminate execution after one iteration of
the loop).  This is due to a bug in :m.javac:em.;
:fn.
A :m.goto:em. bytecode instruction is being generated instead of
a :m.goto&underscore.w:em. instruction.
:efn.
one workaround is to move some of the code out of the loop, perhaps into
a private method.
.*
:li.
.pi /statement unreachable
.pi /variable may be uninitialized
.pi /uninitialized, variable
(The following problem may occur in larger methods, with Java 1.1.2; it
seems to have been fixed in later versions of Java):
NetRexxC does not restrict the number of local variables used or
generated.  However, the 1.1.2 :m.javac:em. compiler fails with
unrelated error messages (such as \textbf{statement unreachable} or
\textbf{variable may be uninitialized}) if asked to handle more than 63
local variables.
:eul.
.* ----------
.cp 7
:h4 id=restint.Interpreter restrictions
.pi /restrictions/interpreter
.pi /interpreting/restrictions

Interpreting Java-based programs is complex, and is constrained by
various security issues and the architecture of the Java Virtual
Machine.  As a result, the following restrictions apply; these will
not affect most uses of the interpreter.
:ul.
:li.
.pi /Java version/required for interpreting
For interpretation to proceed, when any of :m.-exec:em., :m.-arg:em.,
or :m.-noarg:em. is specified, you must be running a Java 2 JVM (Java
Virtual Machine).
That is, the command :m.java -version:em. should report a version
of :b.1.2:eb. or later.  Parsing and compilation, however, only require
Java 1.1.2.
.*
:li.
Certain built-in Java classes
(notably :m.java.lang.Object:em., :m.java.lang.String:em.,
and :m.java.lang.Throwable:em.) are constrained by the JVM in that they
are assumed to be pre-loaded.  An attempt to interpret them is allowed,
but will cause the later loading of any other classes to fail with a
class cast exception.
.*
:li.
.pi /class loaders, used in interpreting
Interpreted classes have a stub which is loaded by a private class
loader.  This means that they will usually not be visible to external
(non-interpreted) classes which attempt to find them explicitly using
reflection, :m.Class.forName():em., &etc.  Instead, these calls may find
compiled versions of the classes from the classpath.  Therefore, to find
the live classes being interpreted, use the NetRexxA interpreter
API interface (described below).
.*
:li.
An interpreter cannot completely emulate the actions taken by the Java
Virtual Machine as it closes down.  Therefore, special rules are
followed to determine when an application is assumed to have ended when
interpreting (that is, when any of :m.-exec:em., :m.-arg:em.,
or :m.-noarg:em. is specified):
:ul.
:li.
.pi /exit/method of java.lang.System
.pi /exit/NetRexx instruction
.pi /exit/from windowing applications
.pi /windowing applications, exit from
If the application being interpreted invokes the :m.exit:em. method of
the :m.java.lang.System:em. class, the run ends immediately (even
if :m.-prompt:em. was specified).  The call cannot be intercepted by the
interpreter, and is assumed to be an explicit request by the application
to terminate the process and release all resources.
:eul.

In other cases, NetRexxC has to decide when the application ends and
hence when to leave NetRexxC (or display the prompt, if :m.-prompt:em.
was specified).  The following rules apply:
:ul.
:li.
If any of the programs being interpreted contains the NetRexx
\textbf{exit} instruction and the application leaves extra user threads
active after the :m.main:em. method ends then NetRexxC will wait for an
exit instruction to be executed before assuming the application has
ended and exiting (or re-prompting).
:li.
Otherwise (that is, there are no extra threads, or no \textbf{exit}
instruction was seen) the application is assumed to have ended as soon
as the :m.main:em. method returns and in this case the run ends (or the
prompt is shown) immediately.  This rule allows a program such as
hello world to be run after a windowing application (which leaves
threads active) without a deadlocked wait.
:eul.

These rules normally do the right thing.  Applications which
create windows may, however, appear to exit prematurely unless they use
the NetRexx \textbf{exit} instruction to end their execution, because of
the last rule.

Applications which include both thread creation and an \textbf{exit}
instruction which is never executed will wait indefinitely and will need
to be interrupted by an external break request, or equivalent,
just as they would if run from compiled classes.
:li.
.pi /security managers, interpreting
.pi /interpreting/security managers
Interpreting programs which set up their own security managers may
prevent correct operation of the interpreter.
:eul.
